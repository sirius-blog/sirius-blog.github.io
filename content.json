{"meta":{"title":"Blog","subtitle":"","description":"","author":"Mr.T","url":"https://sirius-blog.github.io","root":"/"},"pages":[{"title":"","date":"2023-06-03T04:09:19.923Z","updated":"2023-05-23T14:32:16.475Z","comments":true,"path":"package.json","permalink":"https://sirius-blog.github.io/package.json","excerpt":"","text":"{\"name\":\"ariasakablog\",\"version\":\"1.0.17\",\"description\":\"SpeedUp!\",\"main\":\"index.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"author\":\"\",\"license\":\"ISC\"}"},{"title":"","date":"2023-06-03T04:09:19.892Z","updated":"2023-05-23T14:32:16.460Z","comments":true,"path":"manifest.json","permalink":"https://sirius-blog.github.io/manifest.json","excerpt":"","text":"{\"name\":\"Ariasakaの小窝\",\"short_name\":\"Ariasakaの小窝\",\"theme_color\":\"var(--lyx-theme)\",\"background_color\":\"var(--lyx-theme)\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"},{\"src\":\"/img/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"/img/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/img/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"/img/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/img/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/img/180.png\",\"sizes\":\"180X180\",\"type\":\"image/png\"},{\"src\":\"/img/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"},{\"src\":\"/img/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/img/256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"/img/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"分类","date":"2022-07-03T12:48:08.000Z","updated":"2023-05-23T14:32:16.217Z","comments":true,"path":"categories/index.html","permalink":"https://sirius-blog.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-03-30T07:57:51.000Z","updated":"2023-05-23T14:32:16.202Z","comments":true,"path":"about/index.html","permalink":"https://sirius-blog.github.io/about/index.html","excerpt":"","text":""},{"title":"fontawesome对照","date":"2022-11-25T00:16:09.000Z","updated":"2023-05-23T14:32:16.223Z","comments":true,"path":"fontawesome/index.html","permalink":"https://sirius-blog.github.io/fontawesome/index.html","excerpt":"","text":"window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight);"},{"title":"标签","date":"2022-07-03T12:51:29.000Z","updated":"2023-05-23T14:32:16.485Z","comments":true,"path":"tags/index.html","permalink":"https://sirius-blog.github.io/tags/index.html","excerpt":"","text":""},{"title":"时间线","date":"2022-07-02T11:56:00.000Z","updated":"2023-06-04T05:33:08.525Z","comments":true,"path":"timelines/index.html","permalink":"https://sirius-blog.github.io/timelines/index.html","excerpt":"","text":"更新日志一个时间线 2022 07-02 事件 07-03 事件 07-04 事件 07-05 事件 07-06 事件 07-08 事件 07-09 事件 07-14 事件 07-18 事件 07-22 事件 08-12 事件 08-25 事件 本站blog·预览 window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight); 主站site·预览 window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight); 分站tblog·预览 window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight); 分站thinking·预览 window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight); 分站tour·预览 window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight);"},{"title":"导航","date":"2023-03-11T17:22:43.000Z","updated":"2023-06-03T10:54:53.334Z","comments":true,"path":"notes/nav/index.html","permalink":"https://sirius-blog.github.io/notes/nav/index.html","excerpt":"","text":"冰糖红茶 “冰糖红茶”博客魔改组织的大佬们 小冰【冰】 做个有梦想的人！ Akilar【糖】 期待您的光临！ 张洪Heo【红】 分享设计与科技生活 贰猹【茶】 用这生命中的每一秒，给自己一个不后悔的未来"},{"title":"札记","date":"2022-08-04T03:38:05.000Z","updated":"2023-06-03T10:55:35.998Z","comments":true,"path":"notes/zhaji/index.html","permalink":"https://sirius-blog.github.io/notes/zhaji/index.html","excerpt":"","text":"一些博主搭建的其它的站点： PS：划掉的表示已挂 域名 用处 搭建原因 yisous.xyz 博客，也是主站（默认无www） 分享一些东西 oj.yisous.xyz OnlineJudge系统 用于自己练习信奥赛题目其实是搞来象征意义的 status.yisous.xyz 网站状态监控 用于监控网站的状态，基于uptimeRobot mc.yisous.xyz Minecraft服务器 用来联机玩，类似于粉丝服那种，还没弄好 tc.yisous.xyz Typecho测试站 看看typecho怎么样，搞来玩的，已经由Wordpress迁移至当前的Typecho，未来服务器文档之后可能会换用 yisous.tk/lyxop.xyz 短链接生成器 制作短链接，使用本站域名，技术有限，所以很丑 bbs.yisous.xyz LYXの论坛 交流一些事情，也可以闲聊，还没弄说是交流其实还是搞来象征意义搞来玩的 博主的一些域名 域名 用处 yisous.xyz 主要使用的域名，当时看到dynadot14块一年就买了，这个名字就是念起来顺口 lyxop.xyz 注册拿来给副站用的，使用blog.lyxop.xyz进入主站。由于域名续费太贵，所以打算以后换成yisous.tk，其余一样 ariasaka.top 在硅云白嫖的一个域名，后续可能会作为主域名使用 lyxoff2233.eu.org 以前的eu.org域名，还不错，后面要拿来想办法用一用 lyxofficial.eu.org 图一乐域名 yisous.tk 20年为了搭树莓派服搞的域名，可是树莓派没多久就被我超坏了，现在就买不起了，后来这个域名过期，现在又弄回来作为副站使用，使用blog.yisous.tk进入主站，www和根域名主站用于提供短域名服务（已挂）。 注意：本博客强制HTTPS，旧电脑可能会出现问题。 #article-container a:not(.post-meta__tags):not(img):not(a[data-fancybox]):hover{ border-radius: 6px; background-color: #425aef; text-decoration: none!important; color:#fff!important; border:none; box-shadow: #dadada 0 0 8px 2px; } #article-container a:not(.post-meta__tags):not(.headerlink):not(a[data-fancybox]){ /* padding:0 2px; */ /* text-decoration: 1px solid #425aef; */ /* text-decoration: underline; */ border-bottom: 2px solid #425aef; color:var(--font-color); padding:4px }"},{"title":"导航","date":"2022-01-29T07:23:17.000Z","updated":"2023-06-03T10:55:56.329Z","comments":true,"path":"practice/nav/index.html","permalink":"https://sirius-blog.github.io/practice/nav/index.html","excerpt":"","text":"与主机通讯中…… var fdataUser = { apiurl: '' }"},{"title":"随笔","date":"2023-03-11T17:22:43.000Z","updated":"2023-06-03T11:02:26.025Z","comments":true,"path":"practice/suibi/index.html","permalink":"https://sirius-blog.github.io/practice/suibi/index.html","excerpt":"","text":""}],"posts":[{"title":"NodePPT Demo","slug":"pptdemo","date":"2023-06-13T23:34:34.129Z","updated":"2023-06-14T23:51:24.926Z","comments":true,"path":"posts/2404377996.html","link":"","permalink":"https://sirius-blog.github.io/posts/2404377996.html","excerpt":"","text":"说明：本文仅为应用备份，各章节内容均来源于nodeppt ,源件查看推荐访问nodeppt ，感谢大佬开源。 index 详情 classes 详情 background 详情 component 详情 animation 详情 layout 详情 echarts 详情 mermaid 详情 media 详情","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-06-03T04:09:20.286Z","updated":"2023-05-23T14:32:16.199Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://sirius-blog.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"小知识(1) 什么是通道增益","slug":"study-ic-more/knowmore/001 小知识(1) 什么是通道增益","date":"2022-12-11T18:29:18.000Z","updated":"2023-06-18T11:36:47.592Z","comments":true,"path":"posts/3211157357.html","link":"","permalink":"https://sirius-blog.github.io/posts/3211157357.html","excerpt":"","text":"说明：知识拓展。 什么是通道增益？ 个人理解 我的理解： 某信号经设备后由小变大，这个信号的大小之间的差异就是增益，信号是经由通道输入、输出的，因此叫通道增益。 计算公式：通道增益 = 输出功率-输入功率。 科学芝士 官方解析： 暂无。","categories":[{"name":"IC小知识","slug":"IC小知识","permalink":"https://sirius-blog.github.io/categories/IC%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"微波认知","slug":"微波认知","permalink":"https://sirius-blog.github.io/tags/%E5%BE%AE%E6%B3%A2%E8%AE%A4%E7%9F%A5/"}]},{"title":"小知识(2) 什么是通道增益平坦度","slug":"study-ic-more/knowmore/002 小知识(2) 什么是通道增益平坦度","date":"2022-12-11T18:29:18.000Z","updated":"2023-06-18T12:55:23.231Z","comments":true,"path":"posts/3202538405.html","link":"","permalink":"https://sirius-blog.github.io/posts/3202538405.html","excerpt":"","text":"说明：知识拓展。 什么是通道增益平坦度？ 个人理解 我的理解： 不同频点的同等大小信号经设备通道增益后可能会出现不同的增益效果，最大最小的增益之间的差值就代表了增益的落差程度，也就是增益的起伏程度，起伏越小就表示设备通道增益越平稳，这就叫通道增益平坦度。 计算公式：增益差=增益最大值-增益最小值。 科学芝士 官方解析： 增益平坦度是指工作频带内功率增益的起伏，常用最高增益和最低增益之差，即DG来表示。","categories":[{"name":"IC小知识","slug":"IC小知识","permalink":"https://sirius-blog.github.io/categories/IC%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"微波认知","slug":"微波认知","permalink":"https://sirius-blog.github.io/tags/%E5%BE%AE%E6%B3%A2%E8%AE%A4%E7%9F%A5/"}]},{"title":"小知识(3) 什么是中频杂散","slug":"study-ic-more/knowmore/003 小知识(3) 什么是中频杂散","date":"2022-12-11T18:29:18.000Z","updated":"2023-06-18T11:32:25.157Z","comments":true,"path":"posts/1657519875.html","link":"","permalink":"https://sirius-blog.github.io/posts/1657519875.html","excerpt":"","text":"说明：知识拓展。 什么是中频杂散？ 个人理解 我的理解： 不同频点的同等大小信号经设备通道增益后可能会出现不同的增益效果，最大最小的增益之间的差值就代表了增益的落差程度，也就是增益的起伏程度，起伏越小就表示设备通道增益越平稳，这就叫通道增益平坦度。 计算公式：增益差=增益最大值-增益最小值。 科学芝士 官方解析： 暂无。","categories":[{"name":"IC小知识","slug":"IC小知识","permalink":"https://sirius-blog.github.io/categories/IC%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"微波认知","slug":"微波认知","permalink":"https://sirius-blog.github.io/tags/%E5%BE%AE%E6%B3%A2%E8%AE%A4%E7%9F%A5/"}]},{"title":"PCB拓展(2) 常见器件封装及焊接曲线","slug":"study-ic-schpcb/expansions-pcb/002 PCB拓展(2) 常见器件封装及焊接曲线","date":"2022-12-11T18:29:18.000Z","updated":"2023-06-18T06:07:04.478Z","comments":true,"path":"posts/425272644.html","link":"","permalink":"https://sirius-blog.github.io/posts/425272644.html","excerpt":"","text":"说明：本文章旨在记录器件封装的相关认知信息。 MT41J256M16M BGA器件。其焊接温度见Micron BGA焊接温度曲线。 点我查看曲线 XC7VX690TFFG1927 BGA器件。其焊接温度见XILINX BGA焊接温度曲线。 点我查看曲线 LTM4630IV 器件 点我查看曲线 LTM4630IV 器件 点我查看曲线 闲谈","categories":[{"name":"PCB 拓展","slug":"PCB-拓展","permalink":"https://sirius-blog.github.io/categories/PCB-%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"PCB","slug":"PCB","permalink":"https://sirius-blog.github.io/tags/PCB/"},{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"器件封装及焊接曲线","slug":"器件封装及焊接曲线","permalink":"https://sirius-blog.github.io/tags/%E5%99%A8%E4%BB%B6%E5%B0%81%E8%A3%85%E5%8F%8A%E7%84%8A%E6%8E%A5%E6%9B%B2%E7%BA%BF/"}]},{"title":"文档格式(1) 生产文档","slug":"study-ic-schpcb/tips/001 文档格式(1) 采购计划","date":"2022-12-11T18:29:18.000Z","updated":"2023-06-18T00:00:04.169Z","comments":true,"path":"posts/2708347695.html","link":"","permalink":"https://sirius-blog.github.io/posts/2708347695.html","excerpt":"","text":"说明：采购计划样板。 XXXXXX设备 2000年01月采购计划 序号 项目名称：XXXXXX设备 项目代号：MH370 设备编号：MH370-2000010001 采购物品名称 型号规格 生产厂家 计划数量 库存量 采购数量 计划到货期 备注 1 集成电路 集成电路TPS74401KTW Texas Instruments 200 50 150 2000.05.20 2 编制/日期 审核/日期 批准/日期","categories":[{"name":"PCB 拓展","slug":"PCB-拓展","permalink":"https://sirius-blog.github.io/categories/PCB-%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"文档格式","slug":"文档格式","permalink":"https://sirius-blog.github.io/tags/%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F/"}]},{"title":"文档格式(2) 进货检验记录","slug":"study-ic-schpcb/tips/002 文档格式(2) 进货检验记录","date":"2022-12-11T18:29:18.000Z","updated":"2023-06-18T02:20:18.598Z","comments":true,"path":"posts/3713435763.html","link":"","permalink":"https://sirius-blog.github.io/posts/3713435763.html","excerpt":"","text":"说明：进货检验记录样板。 XXXXXX公司 进货检验记录表 表单编号：XX-XX-XX NO： 日期 供方名称 产品 送检数量 抽检数量 质量检验情况 验证结果 备注 A B C D E 其它 合格 不合格 2000.01.01 AMD CPU 52 2 注：A 供货单位应符合要求；B 包装完好；C具有合格证明或相应的测试证明；D 规格、生产单位、数量要与入库单相符； E外型封装牢固、整齐，无裂缝、无气孔，引脚的镀层应平整，无氧化、锈蚀、断裂。符合要求用“√”表示，不符合要求用“×”表示。 质检人员","categories":[{"name":"PCB 拓展","slug":"PCB-拓展","permalink":"https://sirius-blog.github.io/categories/PCB-%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"文档格式","slug":"文档格式","permalink":"https://sirius-blog.github.io/tags/%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F/"}]},{"title":"PCB拓展(1) 器件封装认知","slug":"study-ic-schpcb/expansions-pcb/001 PCB拓展(1) 器件封装认知","date":"2022-12-11T18:29:18.000Z","updated":"2023-06-14T23:57:12.675Z","comments":true,"path":"posts/3661460522.html","link":"","permalink":"https://sirius-blog.github.io/posts/3661460522.html","excerpt":"","text":"说明：本文章旨在记录器件封装的相关认知信息。 AGP封装 详情器件 点我查看图纸 AMR封装 详情器件 点我查看图纸 AX14封装 详情器件 点我查看图纸 AX078封装 详情器件 点我查看图纸 BGA封装(Ball Grid Array Package) 球栅阵列封装，简称BGA(Ball Grid Array Package)。 BGA封装的I/O端子以圆形或柱状焊点按阵列形式分布在封装下面，BGA技术的优点是I/O引脚数虽然增加了，但引脚间距并没有减小反而增加了，从而提高了组装成品率。 详情器件 点我查看图纸 C-Bend Lead封装 详情器件 点我查看图纸 CERAMIC封装 详情器件 点我查看图纸 CERPACK封装 详情器件 点我查看图纸 CERQUAD封装 详情器件 点我查看图纸 CLCC封装 详情器件 点我查看图纸 CNR封装 详情器件 点我查看图纸 DIE封装 详情器件 点我查看图纸 DIMM封装 详情器件 点我查看图纸 DIP封装(dual in-line package) 详情双列直插封装（英语：dual in-line package） 也称为DIP封装或DIP包装，简称为DIP或DIL，是一种集成电路的封装方式，集成电路的外形为长方形，在其两侧则有两排平行的金属引脚，称为排针。DIP包装的元件可以焊接在印刷电路板电镀的贯穿孔中，或是插入在DIP插座（socket）上。 DIP包装的元件一般会简称为DIPn，其中n是引脚的个数，例如十四针的集成电路即称为DIP14。 DIP的引脚节距较大（为2.54mm），占用PCB板较多的控件，为此出现了SHDIP和SKDIP等改进形式，减小引脚节距和缩小体积上做了改进。但DIP的最大引脚数难以提高，最大64。 点我查看图纸 DO-4封装 详情器件 点我查看图纸 DO-5封装 详情器件 点我查看图纸 DO-8封装 详情器件 点我查看图纸 DO-9封装 详情器件 点我查看图纸 EISA封装 详情器件 点我查看图纸 FBGA封装 详情器件 点我查看图纸 Flat Pack封装 详情器件 点我查看图纸 FTO封装 详情器件 点我查看图纸 Gull Wing Leads封装 详情器件 点我查看图纸 HR-16封装 详情器件 点我查看图纸 HR-23封装 详情器件 点我查看图纸 HSOP封装 详情器件 点我查看图纸 HT16封装 详情器件 点我查看图纸 HT23封装 详情器件 点我查看图纸 HT29封装 详情器件 点我查看图纸 ISA封装 详情器件 点我查看图纸 ISOLATED封装 详情器件 点我查看图纸 ITO封装 详情器件 点我查看图纸 JLCC封装 详情器件 点我查看图纸 LAMINATE封装 详情器件 点我查看图纸 LCC封装 详情器件 点我查看图纸 LCCC封装 详情器件 点我查看图纸 LDCC封装 详情器件 点我查看图纸 LGA封装 详情器件 点我查看图纸 LLP封装 详情器件 点我查看图纸 LQFP封装 详情器件 点我查看图纸 MDIP封装 详情器件 点我查看图纸 METAL QUAD 101L封装 详情器件 点我查看图纸 MICRO ARRAY封装 详情器件 点我查看图纸 MICRO SMD封装 详情器件 点我查看图纸 MICRO SMDXT封装 详情器件 点我查看图纸 MINI SOIC封装 详情器件 点我查看图纸 PCI封装 详情器件 点我查看图纸 PCMCIA封装 详情器件 点我查看图纸 PGA封装(Pin Grid Array Package) 详情PGA封装，英文全称为(Pin Grid Array Package)，中文含义叫插针网格阵列封装技术，由这种技术封装的芯片内外有多个方阵形的插针，每个方阵形插针沿芯片的四周间隔一定距离排列，根据管脚数目的多少，可以围成2～5圈。安装时，将芯片插入专门的PGA插座。 点我查看图纸 PLCC封装 详情器件 点我查看图纸 POS封装 详情器件 点我查看图纸 PQFP封装(Plastic Quad Flat Package) PQFP封装(Plastic Quad Flat Package，塑料方块平面封装)是一种芯片封装形式。PQFP封装的芯片的四周均有引脚，其引脚总数一般都在100以上，而且引脚之间距离很小，管脚也很细，一般大规模或超大规模集成电路采用这种封装形式。 用这种形式封装的芯片必须采用SMT(Surface Mount Technology，表面组装技术)将芯片边上的引脚与主板焊接起来。采用SMT安装的芯片不必在主板上打孔，一般在主板表面上有设计好的相应管脚的焊点。将芯片各脚对准相应的焊点，即可实现与主板的焊接。PQFP封装适用于SMT表面安装技术在PCB上安装布线，适合高频使用，它具有操作方便、可靠性高、工艺成熟、价格低廉等优点。 但是，PQFP封装的缺点也很明显，由于芯片边长有限，使得PQFP封装方式的引脚数量无法增加，从而限制了图形加速芯片的发展。平行针脚也是阻碍PQFP封装继续发展的绊脚石，由于平行针脚在传输高频信号时会产生一定的电容，进而产生高频的噪声信号，再加上长长的针脚很容易吸收这种干扰噪音，就如同收音机的天线一样，几百根“天线”之间互相干扰，使得PQFP封装的芯片很难工作在较高频率下。此外，PQFP封装的芯片面积/封装面积比过小，也限制了PQFP封装的发展。90年代后期，随着BGA技术的不断成熟，PQFP终于被市场淘汰。 详情器件 点我查看图纸 PSDIP封装 详情器件 点我查看图纸 PSOP封装 详情器件 点我查看图纸 QFN封装(Quad Flat No-leads Package) QFN（Quad Flat No-leads Package，方形扁平无引脚封装），表面贴装型封装之一。QFN 是日本电子机械工业 会规定的名称。封装四侧配置有电极触点，由于无引脚，贴装占有面积比QFP 小，高度 比QFP 低。但是，当印刷基板与封装之间产生应力时，在电极接触处就不能得到缓解。因此电 极触点 难于做到QFP 的引脚那样多，一般从14 到100 左右。 材料有陶瓷和塑料两种。 QFN是一种无引脚封装，呈正方形或矩形，封装底部中央位置有一个大面积裸露焊盘用来导热，围绕大焊盘的封装外围四周有实现电气连结的导电焊盘。 XQFN16, plastic, extremely thin quad flat package; no leads; 16 terminals; 0.4 mm pitch, 2.6 mm x 1.8 mm x 0.5 mm body. Pitch纯粹是指板面两“单元”其中心间之距离，PCB业美式表达常用mil-pitch，即指两焊垫中心线跨距mil而言。中距Pitch与间距Spacing不同，后者通常是指两导体间“隔离板面”。 详情器件 点我查看图纸 QFP封装 详情器件 点我查看图纸 QGP封装 详情器件 点我查看图纸 RIMM封装 详情器件 点我查看图纸 SBGA封装 详情器件 点我查看图纸 SC-70封装 详情器件 点我查看图纸 SC-71封装 详情器件 点我查看图纸 SIMM封装 详情器件 点我查看图纸 SIP封装 详情器件 点我查看图纸 SLOT封装 详情器件 点我查看图纸 SNAPTK封装 详情器件 点我查看图纸 SNAPZP封装 详情器件 点我查看图纸 SO封装 详情器件 点我查看图纸 SOCKET封装 详情器件 点我查看图纸 SOH封装 详情器件 点我查看图纸 SOIC封装 详情器件 点我查看图纸 SOJ封装 详情器件 点我查看图纸 SOP封装 详情器件 点我查看图纸 SOT-220封装 详情器件 点我查看图纸 SOT-89封装 详情器件 点我查看图纸 SOT封装 详情器件 点我查看图纸 SOT-223封装 详情器件 点我查看图纸 SOT-23封装 详情器件 点我查看图纸 SSOP封装 详情器件 点我查看图纸 TEPBGA封装 详情器件 点我查看图纸 TO-252封装 详情器件 点我查看图纸 TO-263封装 详情器件 点我查看图纸 TO-268封装 详情器件 点我查看图纸 TO-100封装 详情器件 点我查看图纸 TO-126封装 详情器件 点我查看图纸 TO-127封装 详情器件 点我查看图纸 TO-18封装 详情器件 点我查看图纸 TO-202封装 详情器件 点我查看图纸 TO-218封装 详情器件 点我查看图纸 TO-220封装 详情器件 点我查看图纸 TO-247封装 详情器件 点我查看图纸 TO-264封装 详情器件 点我查看图纸 TO-3封装 详情器件 点我查看图纸 TO-46封装 详情器件 点我查看图纸 TO-48封装 详情器件 点我查看图纸 TO-5封装 详情器件 点我查看图纸 TO-52封装 详情器件 点我查看图纸 TO-55封装 详情器件 点我查看图纸 TO-65封装 详情器件 点我查看图纸 TO-71封装 详情器件 点我查看图纸 TO-72封装 详情器件 点我查看图纸 TO-78封装 详情器件 点我查看图纸 TO-8封装 详情器件 点我查看图纸 TO-83封装 详情器件 点我查看图纸 TO-92封装 详情器件 点我查看图纸 TO-93封装 详情器件 点我查看图纸 TO-94封装 详情器件 点我查看图纸 TO-99封装 详情器件 点我查看图纸 TQFP封装 详情器件 点我查看图纸 TSOP封装 详情器件 点我查看图纸 TSSOP封装 详情器件 点我查看图纸 TVSOP封装 详情器件 点我查看图纸 VL Bus封装 详情器件 点我查看图纸 WAFER封装 详情器件 点我查看图纸 XT Bus封装 详情器件 点我查看图纸 ZIP封装 详情器件 点我查看图纸 闲谈","categories":[{"name":"PCB 拓展","slug":"PCB-拓展","permalink":"https://sirius-blog.github.io/categories/PCB-%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"PCB","slug":"PCB","permalink":"https://sirius-blog.github.io/tags/PCB/"},{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"}]},{"title":"GD32F30x 库函数实践（1）新建工程模板","slug":"study-ic-arm/practices-mcu/gd32f1/gd32f1-vlibrary-001","date":"2022-12-08T21:29:18.000Z","updated":"2023-03-11T18:21:09.984Z","comments":true,"path":"posts/101669955.html","link":"","permalink":"https://sirius-blog.github.io/posts/101669955.html","excerpt":"","text":"国产器件，实践过程参考STM32F系列例程。 器件 主芯片：GigaDevice GD32F303VET6 。 目的 新建以官方标准固件库为基础的工程模板。 创建步骤 布局工程结构 文件夹名称及作用： 序号 名称 说明 备注 1 CMSIS 放置内核驱动程序文件 2 LIB 放置官方固件库源码文件 3 PROJECT 放置工程文件 4 STARTUP 放置启动引导文件 5 USER 放置应用程序文件 导入相关官方文件 导入内核驱动程序文件： 导入引导程序文件： 导入官方固件库文件： 导入应用函数文件： 新建工程文件 新建工程并存放在PROJECT文件夹中： 选择目标器件型号： 取消该弹窗应用： 源码关联 将源文件关联到工程中： 头文件关联 将头文件关联到工程中： 添加宏定义 将相关宏定义添加到工程中： 最终关联效果： 编译检查 有错误： 无错误： 闲谈 章节目的 本章主要是熟悉库函数基础工程的创建过程。 程序段分析 无。","categories":[{"name":"MCU 实践","slug":"MCU-实践","permalink":"https://sirius-blog.github.io/categories/MCU-%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"GigaDevice (国产)","slug":"GigaDevice-国产","permalink":"https://sirius-blog.github.io/tags/GigaDevice-%E5%9B%BD%E4%BA%A7/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"库函数版实践","slug":"库函数版实践","permalink":"https://sirius-blog.github.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88%E5%AE%9E%E8%B7%B5/"},{"name":"GD32F30x","slug":"GD32F30x","permalink":"https://sirius-blog.github.io/tags/GD32F30x/"}]},{"title":"SCH应用拓展(6) LTM4633器件应用电路参考","slug":"study-ic-schpcb/expansions-sch/【未完】006 SCH应用拓展(6) LTM4633器件应用电路参考","date":"2022-12-08T00:59:18.000Z","updated":"2023-06-10T23:04:12.612Z","comments":true,"path":"posts/2536084828.html","link":"","permalink":"https://sirius-blog.github.io/posts/2536084828.html","excerpt":"","text":"说明：原理图应用已经验证，本文章旨在记录并备忘相关细节。 器件 主芯片：LTM4633 。 目的 28V转12V。 应用电路电路 配置全局： 点我查看图纸细节 配置细节1： 点我查看图纸细节 特别说明 运行结果： 略 闲谈","categories":[{"name":"SCH 应用拓展","slug":"SCH-应用拓展","permalink":"https://sirius-blog.github.io/categories/SCH-%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"Schematic","slug":"Schematic","permalink":"https://sirius-blog.github.io/tags/Schematic/"}]},{"title":"SCH应用拓展(5) LTM4613器件应用电路参考","slug":"study-ic-schpcb/expansions-sch/【未完】005 SCH应用拓展(5) LTM4613器件应用电路参考","date":"2022-12-08T00:49:18.000Z","updated":"2023-06-10T23:04:15.081Z","comments":true,"path":"posts/1500395655.html","link":"","permalink":"https://sirius-blog.github.io/posts/1500395655.html","excerpt":"","text":"说明：原理图应用已经验证，本文章旨在记录并备忘相关细节。 器件 主芯片：LTM4613 。 目的 28V转12V。 应用电路电路 配置全局： 点我查看图纸细节 配置细节1： 点我查看图纸细节 特别说明 运行结果： 略 闲谈","categories":[{"name":"SCH 应用拓展","slug":"SCH-应用拓展","permalink":"https://sirius-blog.github.io/categories/SCH-%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"Schematic","slug":"Schematic","permalink":"https://sirius-blog.github.io/tags/Schematic/"}]},{"title":"SCH应用拓展(4) LTM4630器件应用电路参考","slug":"study-ic-schpcb/expansions-sch/【未完】004 SCH应用拓展(4) LTM4630器件应用电路参考","date":"2022-12-08T00:29:18.000Z","updated":"2023-06-10T22:59:52.421Z","comments":true,"path":"posts/1565234317.html","link":"","permalink":"https://sirius-blog.github.io/posts/1565234317.html","excerpt":"","text":"说明：原理图应用已经验证，本文章旨在记录并备忘相关细节。 器件 主芯片：LTM4630 。 目的 28V转12V。 应用电路电路 配置全局： 点我查看图纸细节 配置细节1： 点我查看图纸细节 特别说明 运行结果： 略 闲谈","categories":[{"name":"SCH 应用拓展","slug":"SCH-应用拓展","permalink":"https://sirius-blog.github.io/categories/SCH-%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"Schematic","slug":"Schematic","permalink":"https://sirius-blog.github.io/tags/Schematic/"}]},{"title":"SCH应用拓展(3) TPS74401器件应用电路参考","slug":"study-ic-schpcb/expansions-sch/【未完】003 SCH应用拓展(3) TPS4401器件应用电路参考","date":"2022-12-07T23:29:18.000Z","updated":"2023-06-10T22:59:46.950Z","comments":true,"path":"posts/3307741104.html","link":"","permalink":"https://sirius-blog.github.io/posts/3307741104.html","excerpt":"","text":"说明：原理图应用已经验证，本文章旨在记录并备忘相关细节。 器件 主芯片：TPS74401 。 目的 28V转12V。 应用电路电路 配置全局： 点我查看图纸细节 配置细节1： 点我查看图纸细节 特别说明 运行结果： 略 闲谈","categories":[{"name":"SCH 应用拓展","slug":"SCH-应用拓展","permalink":"https://sirius-blog.github.io/categories/SCH-%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"Schematic","slug":"Schematic","permalink":"https://sirius-blog.github.io/tags/Schematic/"}]},{"title":"SCH应用拓展(2) TPS51200器件应用电路参考","slug":"study-ic-schpcb/expansions-sch/【未完】002 SCH应用拓展(2) TPS51200器件应用电路参考","date":"2022-12-07T19:29:18.000Z","updated":"2023-06-10T22:59:41.187Z","comments":true,"path":"posts/3523837585.html","link":"","permalink":"https://sirius-blog.github.io/posts/3523837585.html","excerpt":"","text":"说明：原理图应用已经验证，本文章旨在记录并备忘相关细节。 器件 主芯片：TPS51200 。 目的 28V转12V。 应用电路电路 配置全局： 点我查看图纸细节 配置细节1： 点我查看图纸细节 特别说明 运行结果： 略 闲谈","categories":[{"name":"SCH 应用拓展","slug":"SCH-应用拓展","permalink":"https://sirius-blog.github.io/categories/SCH-%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"Schematic","slug":"Schematic","permalink":"https://sirius-blog.github.io/tags/Schematic/"}]},{"title":"SCH应用拓展(1) LTM4644器件应用电路参考","slug":"study-ic-schpcb/expansions-sch/【未完】001 SCH应用拓展(1) LTM4644器件应用电路参考","date":"2022-12-07T18:29:18.000Z","updated":"2023-06-10T22:59:34.643Z","comments":true,"path":"posts/3367940287.html","link":"","permalink":"https://sirius-blog.github.io/posts/3367940287.html","excerpt":"","text":"说明：原理图应用已经验证，本文章旨在记录并备忘相关细节。 器件 主芯片：LTM4644 。 目的 28V转12V。 应用电路电路 配置全局： 点我查看图纸细节 配置细节1： 点我查看图纸细节 特别说明 运行结果： 略 闲谈","categories":[{"name":"SCH 应用拓展","slug":"SCH-应用拓展","permalink":"https://sirius-blog.github.io/categories/SCH-%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"Schematic","slug":"Schematic","permalink":"https://sirius-blog.github.io/tags/Schematic/"}]},{"title":"STM32F1应用练习(7) 驱动HTG8518器件","slug":"study-ic-arm/practices-mcu/stm32f1/007 STM32F1应用练习(7) 驱动HTG8518器件","date":"2022-12-07T02:29:59.000Z","updated":"2023-06-10T23:41:14.915Z","comments":true,"path":"posts/3706745101.html","link":"","permalink":"https://sirius-blog.github.io/posts/3706745101.html","excerpt":"","text":"说明：应用代码段已经验证，本文章旨在移植及适配 STM32F1。 器件 主芯片：ST STM32F103 。 驱动器件：HTG8518 。 目的 驱动IIC接口器件HTG8518。 电路 硬件连接关系： 点我查看图纸细节 MCU管脚分配： 信号 方向 管脚 说明 FIBER1_SCL output PB5 IIC接口时钟端 FIBER1_SDA inout PB6 IIC接口数据端 思路 使用模拟IIC接口对HTG8518器件进行访问。 驱动 htg8518.c 123// htg8518.c/******************* END OF FILE *********/ htg8518.h 123// htg8518.h/******************* END OF FILE *********/ user_spi.c 123//user_spi.c/******************* END OF FILE *********/ user_spi.h 123//user_spi.h/******************* END OF FILE *********/ main.c 1234//main.c/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈","categories":[{"name":"MCU 应用练习","slug":"MCU-应用练习","permalink":"https://sirius-blog.github.io/categories/MCU-%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"库函数应用练习","slug":"库函数应用练习","permalink":"https://sirius-blog.github.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1应用练习(6) 驱动HTG8538器件","slug":"study-ic-arm/practices-mcu/stm32f1/006 STM32F1应用练习(6) 驱动HTA8538器件","date":"2022-12-07T01:59:59.000Z","updated":"2023-06-11T09:16:51.864Z","comments":true,"path":"posts/2315063985.html","link":"","permalink":"https://sirius-blog.github.io/posts/2315063985.html","excerpt":"","text":"说明：应用代码段已经验证，本文章旨在移植及适配 STM32F1。 器件 主芯片：ST STM32F103 。 驱动器件：HTA8538 。 目的 驱动IIC接口器件HTA8538。 电路 硬件连接关系： 点我查看图纸细节 MCU管脚分配： 信号 方向 管脚 说明 FIBER_TX_SCL output PB5 IIC接口时钟端 FIBER_TX_SDA inout PB6 IIC接口数据端 思路 使用模拟IIC接口对HTA8538器件进行访问。 驱动 hta8538.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// hta8538.c#include &quot;hta8538.h&quot;#include &quot;user_iic.h&quot;FIBRE_PWR fibreRxReg; void iicHTA8538RegInit()&#123; memset(&amp;fibreRxReg, 0, sizeof(FIBRE_PWR));&#125; int iicHTA8538Write(uint8_t Regaddr, uint8_t Regdata)&#123; int rc = HTA8538_DECV_ADDR | IIC_WRITE;// rc = IIC_Write1Byte( rc &amp; 0xFF, Regaddr, Regdata); return rc;&#125;int iicHTA8538Read( uint8_t Regaddr)&#123; int rc = HTA8538_DECV_ADDR | IIC_WRITE;// rc = IIC_Read1Byte( rc &amp; 0xFF, Regaddr, HTA8538_DECV_ADDR | IIC_READ, 0); return rc;&#125;int HTA8538_GetV(void)&#123; uint16_t regdata; regdata = (iicHTA8538Read(HTA8538Vaddr0)) &lt;&lt; 8; regdata += iicHTA8538Read(HTA8538Vaddr1); return regdata;&#125; int HTA8538_GetT(void)&#123; uint8_t regdata; regdata = iicHTA8538Read(HTA8538Taddr0); return regdata;&#125;int iicHTA8538powerRegs_READ(int index)&#123; int val,rc; int regaddr = HTA8538LightPwr_addr0 + (index &lt;&lt; 1);//跨度2byte val = iicHTA8538Read(regaddr); regaddr ++; rc = iicHTA8538Read(regaddr); fibreRxReg.reg[index] = (val &lt;&lt;8) + (rc &amp; 0xFF); return index;&#125;void HTA8538_GetLightPower(void)&#123; int i; for(i=0;i&lt;12;i++) &#123; iicHTA8538powerRegs_READ(i); &#125;&#125;void HTA8538_MONIT(void)&#123; HTA8538_GetV(); HTA8538_GetT(); HTA8538_GetLightPower();&#125;/******************* END OF FILE *********/ hta8538.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// hta8538.h#ifndef __HTA8538_H#define __HTA8538_H#include &quot;sys.h&quot;#include &quot;string.h&quot; typedef struct fibre_reg_data_strcut&#123; int16_t channel1_power; int16_t channel2_power; int16_t channel3_power; int16_t channel4_power; int16_t channel5_power; int16_t channel6_power; int16_t channel7_power; int16_t channel8_power; int16_t channel9_power; int16_t channel10_power; int16_t channel11_power; int16_t channel12_power;&#125;FIBRE_PWR_st;typedef union fibre_12channel_power_status_register_union_pkg&#123; FIBRE_PWR_st power; uint16_t reg[12];&#125;FIBRE_PWR;#define HTA8538_DECV_ADDR (0xa0)#define IIC_WRITE (0 &lt;&lt; 0)#define IIC_READ (1 &lt;&lt; 0)#define HTA8538Taddr0 (0x11) //&#x27;d17, MSB#define HTA8538Taddr1 (0x12) //&#x27;d18, LSB#define HTA8538Vaddr0 (0x72) //&#x27;d114, MSB#define HTA8538Vaddr1 (0x73) //&#x27;d115, LSB#define HTA8538LightPwr_addr0 (0x42) //&#x27;d66, MSBextern void iicHTA8538RegInit(void);extern int iicHTA8538Write(uint8_t Regaddr, uint8_t Regdata);extern int iicHTA8538Read( uint8_t Regaddr);extern int HTA8538_GetT(void); extern int HTA8538_GetV(void);extern int iicHTA8538powerRegs_READ(int index);extern void HTA8538_GetLightPower(void);extern void HTA8538_MONIT(void);#endif/******************* END OF FILE *********/ user_iic.c 123//user_iic.c/******************* END OF FILE *********/ user_iic.h 123//user_iic.h/******************* END OF FILE *********/ main.c 1234//main.c/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈","categories":[{"name":"MCU 应用练习","slug":"MCU-应用练习","permalink":"https://sirius-blog.github.io/categories/MCU-%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"库函数应用练习","slug":"库函数应用练习","permalink":"https://sirius-blog.github.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1应用练习(5) 驱动HTA8533器件","slug":"study-ic-arm/practices-mcu/stm32f1/005 STM32F1应用练习(5) 驱动HTA8533器件","date":"2022-12-07T01:49:18.000Z","updated":"2023-06-11T09:13:59.988Z","comments":true,"path":"posts/2540161730.html","link":"","permalink":"https://sirius-blog.github.io/posts/2540161730.html","excerpt":"","text":"说明：应用代码段已经验证，本文章旨在移植及适配 STM32F1。 器件 主芯片：ST STM32F103 。 驱动器件：HTA8533 。 目的 驱动IIC接口器件HTA8533。 电路 硬件连接关系： 点我查看图纸细节 MCU管脚分配： 信号 方向 管脚 说明 FIBER_TX_SCL output PB5 IIC接口时钟端 FIBER_TX_SDA inout PB6 IIC接口数据端 思路 使用模拟IIC接口对HTA8533器件进行访问。 驱动 hta8533.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// hta8533.c#include &quot;hta8533.h&quot;#include &quot;user_iic.h&quot;FIBRE_PWR fibreTxReg; void iicHTA8533RegInit(void)&#123; memset(&amp;fibreTxReg, 0, sizeof(FIBRE_PWR));&#125; int iicHTA8533Write(uint8_t Regaddr, uint8_t Regdata)&#123; int rc = HTA8533_DECV_ADDR | IIC_WRITE;// rc = IIC_Write1Byte(rc &amp; 0xFF, Regaddr, Regdata); return rc;&#125;int iicHTA8533Read( uint8_t Regaddr)&#123; int rc = HTA8533_DECV_ADDR | IIC_WRITE;// rc = IIC_Read1Byte(rc &amp; 0xFF, Regaddr, HTA8533_DECV_ADDR | IIC_READ, 0); return rc;&#125;int HTA8533_GetV(void)&#123; uint16_t regdata; regdata = (iicHTA8533Read(HTA8533Vaddr0)) &lt;&lt; 8; regdata += iicHTA8533Read(HTA8533Vaddr1); return regdata;&#125; int HTA8533_GetT(void)&#123; uint8_t regdata; regdata = iicHTA8533Read(HTA8533Taddr0); return regdata;&#125;void HTA8533_MONIT(void)&#123; HTA8533_GetV(); HTA8533_GetT();&#125;/******************* END OF FILE *********/ hta8533.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// hta8533.h#ifndef __HTA8533_H#define __HTA8533_H#include &quot;sys.h&quot;#include &quot;string.h&quot; typedef struct fibre_reg_data_strcut&#123; int16_t channel1_power; int16_t channel2_power; int16_t channel3_power; int16_t channel4_power; int16_t channel5_power; int16_t channel6_power; int16_t channel7_power; int16_t channel8_power; int16_t channel9_power; int16_t channel10_power; int16_t channel11_power; int16_t channel12_power;&#125;FIBRE_PWR_st;typedef union fibre_12channel_power_status_register_union_pkg&#123; FIBRE_PWR_st power; uint16_t reg[12];&#125;FIBRE_PWR;#define HTA8533_DECV_ADDR (0xa0)#define IIC_WRITE (0 &lt;&lt; 0)#define IIC_READ (1 &lt;&lt; 0)#define HTA8533Vaddr0 (0x72)#define HTA8533Vaddr1 (0x73)#define HTA8533Taddr0 (0x11)#define HTA8533Taddr1 (0x12)extern void iicHTA8533RegInit(void);extern int iicHTA8533Write(uint8_t Regaddr, uint8_t Regdata);extern int iicHTA8533Read( uint8_t Regaddr);extern int HTA8533_GetT(void); extern int HTA8533_GetV(void);extern void HTA8533_MONIT(void); #endif /******************* END OF FILE *********/ user_iic.c 123//user_iic.c/******************* END OF FILE *********/ user_iic.h 123//user_iic.h/******************* END OF FILE *********/ main.c 1234//main.c/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈","categories":[{"name":"MCU 应用练习","slug":"MCU-应用练习","permalink":"https://sirius-blog.github.io/categories/MCU-%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"库函数应用练习","slug":"库函数应用练习","permalink":"https://sirius-blog.github.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1应用练习(4) 驱动AT24C04器件","slug":"study-ic-arm/practices-mcu/stm32f1/004 STM32F1应用练习(4) 驱动AT24C04器件","date":"2022-12-07T01:29:18.000Z","updated":"2023-06-10T23:25:08.376Z","comments":true,"path":"posts/2540161729.html","link":"","permalink":"https://sirius-blog.github.io/posts/2540161729.html","excerpt":"","text":"说明：应用代码段已经验证，本文章旨在移植及适配 STM32F1。 器件 主芯片：ST STM32F103 。 驱动器件：AT24C04 。 目的 驱动IIC接口器件AT24C04。 电路 硬件连接关系： 点我查看图纸细节 MCU管脚分配： 信号 方向 管脚 说明 TMP_I2C_SCL output PB5 IIC接口时钟端 TMP_I2C_SDA inout PB6 IIC接口数据端 思路 使用模拟IIC接口对AT24C04器件进行访问。 驱动 at24c04.c 123// at24c04.c/******************* END OF FILE *********/ at24c04.h 123// at24c04.h/******************* END OF FILE *********/ user_spi.c 123//user_spi.c/******************* END OF FILE *********/ user_spi.h 123//user_spi.h/******************* END OF FILE *********/ main.c 1234//main.c/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈","categories":[{"name":"MCU 应用练习","slug":"MCU-应用练习","permalink":"https://sirius-blog.github.io/categories/MCU-%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"库函数应用练习","slug":"库函数应用练习","permalink":"https://sirius-blog.github.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1应用练习(3) 驱动AD9516-3器件","slug":"study-ic-arm/practices-mcu/stm32f1/003 STM32F1应用练习(3) 驱动AD9516-3器件","date":"2022-12-07T00:59:18.000Z","updated":"2023-06-10T23:13:48.988Z","comments":true,"path":"posts/2540161728.html","link":"","permalink":"https://sirius-blog.github.io/posts/2540161728.html","excerpt":"","text":"说明：应用代码段已经验证，本文章旨在移植及适配 STM32F1。 器件 主芯片：ST STM32F103 。 驱动器件：AD9516-3 。 目的 驱动SPI接口器件AD9516-3。 电路 硬件连接关系： 点我查看图纸细节 MCU管脚分配： 信号 方向 管脚 说明 CLK_CSN output PA4 SPI接口cs CLK_SCLK output PA5 SPI接口sck CLK_SDO input PA6 SPI接口miso CLK_SDIO output PA7 SPI接口mosi CLK_RESET output PA7 AD9516-3复位接口RESETN CLK_REF_SEL output PA7 AD9516-3其它接口 CLK_SYNCN output PA7 AD9516-3其它接口 CLK_RMON output PA7 AD9516-3其它接口 CLK_LDT output PA7 AD9516-3其它接口 CLK_STAT output PA7 AD9516-3其它接口 思路 使用模拟SPI接口对AD9516-3器件进行访问。 驱动 ad9516_3.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795// ad9516_3.c#include &quot;delay.h&quot;#include &quot;ad9516_3.h&quot;#include &quot;user_spi.h&quot;AD9516REG ad9516reg;AD9516PIN_STATUS ad9516PinStatus;BDBITPKG bdBITPkg;int AD9516Reg_init(void)&#123; memset(&amp;ad9516reg, 0, sizeof(AD9516REG)); memset(&amp;bdBITPkg, 0, sizeof(BDBITPKG)); memset(&amp;ad9516PinStatus,0,sizeof(ad9516PinStatus)); return 0;&#125;///////////////////////AD9516功能端口控制//AD9516的复位int ad9516_reset(void)&#123; GPIO_ResetBits (GPIOD,GPIO_Pin_5); return 0;&#125;//AD9516的复位释放int ad9516_release(void)&#123; GPIO_SetBits(GPIOD,GPIO_Pin_5); return 0;&#125;//AD9516的REF_SEL端拉低int ad9516_RefSel_Down(void)&#123; GPIO_ResetBits (GPIOD,GPIO_Pin_3); return 0;&#125;//AD9516的REF_SEL端拉高int ad9516_RefSel_Up(void)&#123; GPIO_SetBits(GPIOD,GPIO_Pin_3); return 0;&#125;//AD9516的SYNCN端拉低int ad9516_SYNCN_Down(void)&#123; GPIO_ResetBits (GPIOD,GPIO_Pin_4); return 0;&#125;//AD9516的SYNCN端拉高int ad9516_SYNCN_Up(void)&#123; GPIO_SetBits(GPIOD,GPIO_Pin_4); return 0;&#125;//AD9516的LD端状态int ad9516_LDT_State(void)&#123; return (GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_1));&#125;//AD9516的STAT端状态int ad9516_STAT_State(void)&#123; return (GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_2));&#125;//AD9516的RMON端状态int ad9516_RMON_State(void)&#123; return (GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_0));&#125;//配置相关模式://配置为MSB_first;//配置为SDO回读;int ad9516_init(void)&#123; ad9516_config(); return 0;&#125;//ad9516-3配置int ad9516_config(void)&#123; #if 1 //2021.02.03_2 所有寄存器全部列出（含默认设置）陈*提供参考,// //VCO = 2000 MHZ : R=3, A=12 ;B=18 ;P=16/17mode ;VCO_Div=2 ;Div0=8 ;OUT0=125Mhz(理论值) ; //输出实测124.99Mhz,输出正确（国产板和进口板测试都可以输出125Mhz，但杂质可能有干扰） //Serial Port Configuration ad9516_write(0x000, 0x99);//设置SDO为回读端，默认MSB_first方式 ad9516_write(0x004, 0x01);//回读寄存器 //PLL ad9516_write(0x010, 0x7C);//PFD和CP设置 ad9516_write(0x011, 0x03);//R的LSB值R[7:0] ad9516_write(0x012, 0x00);//R的MSB值R[13:8] ad9516_write(0x013, 0x0C);//A的值A[5:0] ad9516_write(0x014, 0x12);//B的LSB值R[7:0] ad9516_write(0x015, 0x00);//B的MSB值R[12:8] ad9516_write(0x016, 0x05);//PLL_Control_1中P的值P[2:0] ,DM 8/9mode ad9516_write(0x017, 0x00);//PLL_Control_2中STATUS pin control设为&quot;default (GND)&quot;;默认2.9ns ad9516_write(0x018, 0x06);//PLL_Control_3中VCO_cal_div为默认16; 重置校准 ad9516_write(0x019, 0x00);//PLL_Control_3中默认 ad9516_write(0x01A, 0x00);//PLL_Control_5中LD pin control设为&quot;默认DLD&quot; ad9516_write(0x01B, 0x60);//PLL_Control_6中REFMON pin control设为&quot;默认GND&quot;,启用REF1&amp;2频率监控 ad9516_write(0x01C, 0x46);//PLL_Control_7中enable REF buffer；根据实际电路改选REF1；//原0x42//测试0x02也可以 ad9516_write(0x01D, 0x00);//PLL_Control_8中默认全关闭 ad9516_write(0x01E, 0x00);//PLL Control 9 ：Reserved ad9516_write(0x01F, 0x5B);//PLL readback：read-only ad9516_write(0x232, 0x01); delay_us(10);// ad9516_write(0x018, 0x07);//PLL_Control_3中VCO_cal_div为默认16; 初始化校准// ad9516_write(0x232, 0x01);// delay_us(500000); //===此处与本硬件设计部分无关 //===LVDS/CMOS输出通道设置 ad9516_write(0x0A0, 0x01);//OUT6 delay bypass：设为跳过（bypass），OUT6在206B项目被悬空 ad9516_write(0x0A1, 0x00);//OUT6 delay full-scale ad9516_write(0x0A2, 0x00);//OUT6 delay fraction ad9516_write(0x0A3, 0x01);//OUT7 delay bypass：设为跳过（bypass），OUT7在206B项目被悬空 ad9516_write(0x0A4, 0x00);//OUT7 delay full-scale ad9516_write(0x0A5, 0x00);//OUT7 delay fraction ad9516_write(0x0A6, 0x01);//OUT8 delay bypass：设为跳过（bypass），OUT8在206B项目被悬空 ad9516_write(0x0A7, 0x00);//OUT8 delay full-scale ad9516_write(0x0A8, 0x00);//OUT8 delay fraction ad9516_write(0x0A9, 0x01);//OUT9 delay bypass：设为跳过（bypass），OUT9在206B项目被悬空 ad9516_write(0x0AA, 0x00);//OUT9 delay full-scale; ad9516_write(0x0AB, 0x00);//OUT9 delay fraction; //===LVPECL输出通道设置 ad9516_write(0x0F0, 0x08);//OUT0，不取反，LVPECL输出差分电压设为 780mV（默认）,并启用该输出; ad9516_write(0x0F1, 0x08);//OUT1，不取反，LVPECL输出差分电压设为 780mV（默认）,并启用该输出; ad9516_write(0x0F2, 0x18);//OUT2，取反，LVPECL输出差分电压设为 780mV（默认）,并启用该输出; ad9516_write(0x0F3, 0x03);//OUT3，不取反，LVPECL输出差分电压设为 400mV,并完全关闭该输出; ad9516_write(0x0F4, 0x1B);//OUT4，取反，LVPECL输出差分电压设为 780mV（默认）,并完全关闭该输出; ad9516_write(0x0F5, 0x0B);//OUT5，不取反，LVPECL输出差分电压设为 780mV（默认）,并完全关闭该输出; //===此处与本硬件设计部分无关 //===LVDS/CMOS输出通道设置 ad9516_write(0x140, 0x13);//OUT6，关闭该输出; 该端口信号的极性、电平类型、电流以及是否输出等设置; ad9516_write(0x141, 0x93);//OUT7，关闭该输出; 该端口信号的极性、电平类型、电流以及是否输出等设置; ad9516_write(0x142, 0x13);//OUT8，关闭该输出; 该端口信号的极性、电平类型、电流以及是否输出等设置; ad9516_write(0x143, 0x53);//OUT9，关闭该输出; 该端口信号的极性、电平类型、电流以及是否输出等设置; //===LVPECL输出通道分频器设置 //便于当前示波器观察，将输出调至100MHZ以内 //0x190寄存器：Dx=M+1+N+1，其中M,N为寄存器设置值 ad9516_write(0x190, 0x33);//Divider 0(PECL)，Div_0分频系数（占空比）设置，（如设置的值0x33表示8分频，占空比50%）; ad9516_write(0x191, 0x00);//Divider 0(PECL)，Div_0分频器的启用与否、及相关输出配置等; ad9516_write(0x192, 0x00);//Divider 0(PECL)，选择输出是否经过Div_0分频器、是否启用Duty-cycle correction; ad9516_write(0x193, 0x33);//Divider 1(PECL)，Div_1分频系数（占空比）设置，（如设置的值0x22表示4分频，占空比50%）;//Dx=M+1+N+1，其中M,N为寄存器设置值 ad9516_write(0x194, 0x10);//Divider 1(PECL)，Div_1分频器的启用与否、及相关输出配置等; ad9516_write(0x195, 0x00);//Divider 1(PECL)，选择输出是否经过Div_1分频器、是否启用Duty-cycle correction; ad9516_write(0x196, 0x10);//Divider 2(PECL)，Div_2分频系数（占空比）设置，（如设置的值0xAA表示20分频，占空比50%）; ad9516_write(0x197, 0x80);//Divider 2(PECL)，Div_2分频器的启用与否、及相关输出配置等; ad9516_write(0x198, 0x01);//Divider 2(PECL)，选择输出是否经过Div_2分频器、是否启用Duty-cycle correction; //===此处与本硬件设计部分无关 //===LVDS/CMOS通道分频器设置 ad9516_write(0x199, 0x22);//Divider 3(LVDS/CMOS)，Div_3一级分频系数（占空比）设置; ad9516_write(0x19A, 0x00);//Divider 3(LVDS/CMOS)，Div_3一&amp;二级分频相位偏移; ad9516_write(0x19B, 0x22);//Divider 3(LVDS/CMOS)，Div_3二级分频系数（占空比）设置; ad9516_write(0x19C, 0x20);//Divider 3(LVDS/CMOS)，Div_3分频器的启用与否、及相关输出配置等; ad9516_write(0x19D, 0x00);//Divider 3(LVDS/CMOS)，Div_3分频器是否启用Duty-cycle correction; ad9516_write(0x19E, 0x22);//Divider 4(LVDS/CMOS)，Div_4一级分频系数（占空比）设置; ad9516_write(0x19F, 0x00);//Divider 4(LVDS/CMOS)，Div_4一&amp;二级分频相位偏移; ad9516_write(0x1A0, 0x22);//Divider 4(LVDS/CMOS)，Div_4二级分频系数（占空比）设置; ad9516_write(0x1A1, 0x20);//Divider 4(LVDS/CMOS)，Div_4分频器的启用与否、及相关输出配置等; ad9516_write(0x1A2, 0x00);//Divider 4(LVDS/CMOS)，Div_4分频器是否启用Duty-cycle correction; //===VCO分频器设置 ad9516_write(0x1E0, 0x00);//VCO divider;有2、3、4、5、6、static共6种选择, 这里根据需要选择4;//0x01 ad9516_write(0x1E1, 0x02);//Input CLKs:涉及CLK、VCO的选择与启用，这里设置为使用内部VCO ad9516_write(0x230, 0x00);//Power-down and sync：default; 这里设置为启用软件SYNC ad9516_write(0x231, 0x00);//valid //Update All Registers ad9516_write(0x232, 0x01); delay_us(10);// ad9516_write(0x018, 0x06);//PLL_Control_3中VCO_cal_div为默认16; 重置校准// ad9516_write(0x232, 0x01); delay_us(10); ad9516_write(0x018, 0x07);//PLL_Control_3中VCO_cal_div为默认16; 初始化校准 ad9516_write(0x232, 0x01);// delay_us(500000); #endif return 0;&#125;//ad9516-3内部寄存器读取//单Byte,MSB_first方式读int ad9516_read(uint16_t addr)&#123; int rc = 0; uint16_t cmd = 0; uint8_t pdata = 0; cmd = AD9516_SPI_REG_READ | AD9516_MODE0_MASK|(addr &amp; AD9516_SPI_REG_ADDR_MASK); rc = spi1_oprate(cmd, 0 , NULL, 0); pdata = rc &amp; AD9516_SPI_REG_DATA_MASK; //其它模式 return pdata;&#125;//ad9516-3寄存器配值//单Byte,MSB_first方式写int ad9516_write(uint16_t addr, uint8_t pdata)&#123; int rc = 0; uint16_t cmd = 0; cmd = AD9516_SPI_REG_WRITE | (AD9516_MODE0_MASK)|(addr &amp; AD9516_SPI_REG_ADDR_MASK); rc = spi1_oprate(cmd, pdata , NULL, 0); return rc;&#125;int ad9516_readReg(void)&#123; uint16_t RegAddr[64] = &#123; 0x0000,0x0003,0x0004, 0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F, 0x00A0,0x00A1,0x00A2,0x00A3,0x00A4,0x00A5,0x00A6,0x00A7,0x00A8,0x00A9,0x00AA,0x00AB, 0x00F0,0x00F1,0x00F2,0x00F3,0x00F4,0x00F5, 0x0140,0x0141,0x0142,0x043, 0x0190,0x0191,0x0192,0x0193,0x0194,0x0195,0x0196,0x0197,0x0198,0x0199,0x019A,0x019B,0x019C,0x019D,0x019E,0x09F, 0x01A0,0x01A1,0x01A2, 0x01E0,0x01E1, 0x0230,0x0232 &#125;; //16bit-addr uint8_t *pReg = (uint8_t *)(&amp;ad9516reg.h000__Serial_port_configuration); for(int i=0; i&lt;AD9516REG_LEN;i++) &#123; pReg[i] = ad9516_read(RegAddr[i]); //执行读操作流程 &#125; return 0;&#125;int ad9516_STATUS_PIN(void)&#123; uint8_t signal_num = 0x3F; uint8_t temp = 0; int i=0; for(i=0;i&lt;=signal_num;i++) &#123; temp = 0xFC&amp;(i&lt;&lt;2); //0xBF表示寄存器0x17[1:0] = 00b ad9516_write(0x017, temp); //设置PLL_Control_2中STATUS pin control ad9516_write(0x232, 0x01); //更新寄存器 delay_us(10); ad9516PinStatus.STAT_Status[i] = ad9516_STAT_State();//获取STAT脚状态 // ad9516PinStatus_TEST(STAT_TEST,i); &#125; signal_num = 0x3F; for(i=0;i&lt;=signal_num;i++) &#123; temp = 0x3F&amp;i; //0xBF表示寄存器0x1A[7:6] = 00b ad9516_write(0x01A, temp); //设置PLL_Control_2中LDT pin control ad9516_write(0x232, 0x01); //更新寄存器 delay_us(10); ad9516PinStatus.LDT_Status[i] = ad9516_LDT_State();//获取LDT脚状态 // ad9516PinStatus_TEST(LDT_TEST,i); &#125; signal_num = 0x1F; for(i=0;i&lt;=signal_num;i++) &#123; temp = 0xFF&amp;i; //0xBF表示寄存器0x1B[7:5] = 111b ad9516_write(0x01B, temp); //设置PLL_Control_2中RMON pin control ad9516_write(0x232, 0x01); //更新寄存器 delay_us(10); ad9516PinStatus.RMON_Status[i] = ad9516_RMON_State();//获取RMON脚状态 if(i==16) //VS (PLL supply). &#123; delay_us(1); &#125;// ad9516PinStatus_TEST(RMON_TEST,i); &#125; return 0;&#125;//========================================//访问AD9516-3的底层SPI//CMD ：16bits ; DATA : N*8bits ;//前沿采样，后沿输出（SPI 0模式）// __ ______ // CS \\_______________________________________________/// _____ _____ _____ _____// SCK ____| |_____| |_____| |_____| |___ T(max)=25Mhz, t(HIGH)&gt;16ns, t(LOW)&gt;16ns, // ________ ___________ ___________ ___________ ________ // SDIO --X________X___________X___________X___________X_______ //uint32_t spi1_oprate(uint16_t data0, uint8_t data1, void* pbuf, int len)&#123; uint32_t readdata = 0; uint8_t* pdata = (uint8_t*)(pbuf); spi1_mass_low (); readdata |= spi1_writeread ( (data0&gt;&gt;8)); readdata = readdata &lt;&lt; 8; readdata |= spi1_writeread ( data0); readdata = readdata &lt;&lt; 8; readdata |= spi1_writeread ( data1); if(len &gt; 1) &#123; readdata = readdata &lt;&lt; 8; for(int i = 1;i &lt; len;i++) &#123; readdata |= spi1_writeread ( *pdata); readdata = readdata &lt;&lt; 8; pdata++; &#125; &#125; delay_us(5); spi1_mass_high (); return readdata;&#125;int ad9516PinStatus_TEST(int PinTest,int i)&#123; //LDT_PIN_TEST if(PinTest == LDT_TEST) &#123; if(i==0) //Digital lock detect (high = lock, low = unlock) (default). &#123; delay_us(1); &#125; if(i==1) //P-channel, open-drain lock detect (analog lock detect). &#123; delay_us(1); &#125; if(i==2) //N-channel, open-drain lock detect (analog lock detect). &#123; delay_us(1); &#125; if(i==3) //High-Z LD pin. &#123; delay_us(1); &#125; if(i==4) //Current source lock detect (110 μA when DLD is true). &#123; delay_us(1); &#125; if(i==33) //REF1 clock (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==34) //REF2 clock (not available in differential mode). &#123; delay_us(1); &#125; if(i==35) //Selected reference to PLL (differential reference when indifferential mode). &#123; delay_us(1); &#125; if(i==36) //Unselected reference to PLL (not available in differential mode). &#123; delay_us(1); &#125; if(i==37) //Status of selected reference (status of differential reference); active high. &#123; delay_us(1); &#125; if(i==38) //Status of unselected reference (not available in differential mode); active high. &#123; delay_us(1); &#125; if(i==39) //Status REF1 frequency (active high). &#123; delay_us(1); &#125; if(i==40) //Status REF2 frequency (active high). &#123; delay_us(1); &#125; if(i==41) //(Status REF1 frequency) AND (status REF2 frequency). &#123; delay_us(1); &#125; if(i==42) //(DLD) AND (status of selected reference) AND (status of VCO). &#123; delay_us(1); &#125; if(i==43) //Status of VCO frequency (active high). &#123; delay_us(1); &#125; if(i==44) //Selected reference (low = REF1, high = REF2). &#123; delay_us(1); &#125; if(i==45) //Digital lock detect (DLD); active high. &#123; delay_us(1); &#125; if(i==46) //Holdover active (active high). &#123; delay_us(1); &#125; if(i==47) //Not available. Do not use. &#123; delay_us(1); &#125; if(i==48) //VS (PLL supply). &#123; delay_us(1); &#125; if(i==49) //(取反) ，REF1 clock (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==50) //(取反) ，REF2 clock (not available in differential mode). &#123; delay_us(1); &#125; if(i==51) //(取反) ，Selected reference to PLL (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==52) //(取反) ，Unselected reference to PLL (not available when in differential mode). &#123; delay_us(1); &#125; if(i==53) //Status of selected reference (status of differential reference); active low. &#123; delay_us(1); &#125; if(i==54) //Status of unselected reference (not available in differential mode); active low. &#123; delay_us(1); &#125; if(i==55) //Status of REF1 frequency (active low). &#123; delay_us(1); &#125; if(i==56) //Status of REF2 frequency (active low). &#123; delay_us(1); &#125; if(i==57) //(取反)， (Status of REF1 frequency) AND (status of REF2 frequency). &#123; delay_us(1); &#125; if(i==58) //(取反)， (DLD) AND (status of selected reference) AND (status of VCO). &#123; delay_us(1); &#125; if(i==59) //Status of VCO frequency (active low). &#123; delay_us(1); &#125; if(i==60) //Selected reference (low = REF2, high = REF1). &#123; delay_us(1); &#125; if(i==61) //Digital lock detect (DLD); active low. &#123; delay_us(1); &#125; if(i==62) //Holdover active (active low). &#123; delay_us(1); &#125; if(i==63) //Not available. Do not use. &#123; delay_us(1); &#125; &#125; //RMON_PIN_TEST if(PinTest == RMON_TEST) &#123; if(i==0) //Ground (dc) (default). &#123; delay_us(1); &#125; if(i==1) //REF1 clock (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==2) //REF2 clock (not available in differential mode). &#123; delay_us(1); &#125; if(i==3) //Selected reference to PLL (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==4) //Unselected reference to PLL (not available in differential mode). &#123; delay_us(1); &#125; if(i==5) //Status of selected reference (status of differential reference); active high. &#123; delay_us(1); &#125; if(i==6) //Status of unselected reference (not available in differential mode); active high. &#123; delay_us(1); &#125; if(i==7) //Status REF1 frequency (active high). &#123; delay_us(1); &#125; if(i==8) //Status REF2 frequency (active high). &#123; delay_us(1); &#125; if(i==9) //(Status REF1 frequency) AND (status REF2 frequency). &#123; delay_us(1); &#125; if(i==10) //(DLD) AND (status of selected reference) AND (status of VCO). &#123; delay_us(1); &#125; if(i==11) //Status of VCO frequency (active high). &#123; delay_us(1); &#125; if(i==12) //Selected reference (low = REF1, high = REF2). &#123; delay_us(1); &#125; if(i==13) //Digital lock detect (DLD); active low. &#123; delay_us(1); &#125; if(i==14) //Holdover active (active high). &#123; delay_us(1); &#125; if(i==15) //LD pin comparator output (active high). &#123; delay_us(1); &#125; if(i==16) //VS (PLL supply). &#123; delay_us(1); &#125; if(i==17) //(取反) ,REF1 clock (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==18) //(取反) ,REF2 clock (not available in differential mode). &#123; delay_us(1); &#125; if(i==19) //(取反) ,Selected reference to PLL (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==20) //(取反) ,Unselected reference to PLL (not available when in differential mode). &#123; delay_us(1); &#125; if(i==21) //Status of selected reference (status of differential reference); active low. &#123; delay_us(1); &#125; if(i==22) //Status of unselected reference (not available in differential mode); active low. &#123; delay_us(1); &#125; if(i==23) //Status of REF1 frequency (active low). &#123; delay_us(1); &#125; if(i==24) //Status of REF2 frequency (active low). &#123; delay_us(1); &#125; if(i==25) //(取反) ,(Status of REF1 frequency) AND (Status of REF2 frequency). &#123; delay_us(1); &#125; if(i==26) //(取反) ,(DLD) AND (Status of selected reference) AND (Status of VCO). &#123; delay_us(1); &#125; if(i==27) //Status of VCO frequency (active low). &#123; delay_us(1); &#125; if(i==28) //Selected reference (low = REF2, high = REF1). &#123; delay_us(1); &#125; if(i==29) //Digital lock detect (DLD); active low. &#123; delay_us(1); &#125; if(i==30) //Holdover active (active low). &#123; delay_us(1); &#125; if(i==31) //LD pin comparator output (active low). &#123; delay_us(1); &#125; &#125; //STAT_PIN_TEST if(PinTest == STAT_TEST) &#123; if(i==0) //Ground (dc) (default). &#123; delay_us(1); &#125; if(i==1) //N divider output (after the delay). &#123; delay_us(1); &#125; if(i==2) //R divider output (after the delay). &#123; delay_us(1); &#125; if(i==3) //A divider output. &#123; delay_us(1); &#125; if(i==4) //Prescaler output. &#123; delay_us(1); &#125; if(i==5) //PFD up pulse. &#123; delay_us(1); &#125; if(i==6) //PFD down pulse. &#123; delay_us(1); &#125; if(i==32) //Ground (dc). &#123; delay_us(1); &#125; if(i==33) //REF1 clock (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==34) //REF2 clock (not available in differential mode). &#123; delay_us(1); &#125; if(i==35) //Selected reference to PLL (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==36) //Unselected reference to PLL (not available in differential mode). &#123; delay_us(1); &#125; if(i==37) //Status of selected reference (status of differential reference); active high. &#123; delay_us(1); &#125; if(i==38) //Status of unselected reference (not available in differential mode); active high. &#123; delay_us(1); &#125; if(i==39) //Status REF1 frequency (active high). &#123; delay_us(1); &#125; if(i==40) //Status REF2 frequency (active high). &#123; delay_us(1); &#125; if(i==41) //(Status REF1 frequency) AND (status REF2 frequency). &#123; delay_us(1); &#125; if(i==42) //(DLD) AND (status of selected reference) AND (status of VCO). &#123; delay_us(1); &#125; if(i==43) //Status of VCO frequency (active high). &#123; delay_us(1); &#125; if(i==44) //Selected reference (low = REF1, high = REF2). &#123; delay_us(1); &#125; if(i==45) //Digital lock detect (DLD); active high. &#123; delay_us(1); &#125; if(i==46) //Holdover active (active high). &#123; delay_us(1); &#125; if(i==47) //LD pin comparator output (active high). &#123; delay_us(1); &#125; if(i==48) //VS (PLL supply). &#123; delay_us(1); &#125; if(i==49) //(取反) ,REF1 clock (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==50) //(取反) ,REF2 clock (not available in differential mode). &#123; delay_us(1); &#125; if(i==51) //(取反) ,Selected reference to PLL (differential reference when in differential mode). &#123; delay_us(1); &#125; if(i==52) //(取反) ,Unselected reference to PLL (not available when in differential mode). &#123; delay_us(1); &#125; if(i==53) //Status of selected reference (status of differential reference); active low. &#123; delay_us(1); &#125; if(i==54) //Status of unselected reference (not available in differential mode); active low. &#123; delay_us(1); &#125; if(i==55) //Status of REF1 frequency (active low). &#123; delay_us(1); &#125; if(i==56) //Status of REF2 frequency (active low). &#123; delay_us(1); &#125; if(i==57) //(取反) ,(Status of REF1 frequency) AND (status of REF2 frequency). &#123; delay_us(1); &#125; if(i==58) //(取反) ,(DLD) AND (status of selected reference) AND (status of VCO). &#123; delay_us(1); &#125; if(i==59) //Status of VCO frequency (active low). &#123; delay_us(1); &#125; if(i==60) //Selected reference (low = REF2, high = REF1). &#123; delay_us(1); &#125; if(i==61) //Digital lock detect (DLD) (active low). &#123; delay_us(1); &#125; if(i==62) //Holdover active (active low). &#123; delay_us(1); &#125; if(i==63) //LD pin comparator output (active low). &#123; delay_us(1); &#125; &#125; return 0;&#125;/******************* END OF FILE *********/ ad9516_3.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166// ad9516_3.h#ifndef __AD9516_3_H__#define __AD9516_3_H__#include &quot;sys.h&quot;#include &quot;string.h&quot; //域#define AD9516_SPI_REG_ADDR_MASK (0x1FFF) //访问AD9516寄存器地址域#define AD9516_SPI_REG_DATA_MASK (0xFF) //访问AD9516寄存器数据域//读写控制#define AD9516_SPI_REG_READ (1 &lt;&lt; 15) //读AD9516寄存器#define AD9516_SPI_REG_WRITE (0 &lt;&lt; 15) //写AD9516寄存器//Byte传输数#define AD9516_MODE0_MASK (0&lt;&lt;13) //1Byte传输#define AD9516_MODE1_MASK (1&lt;&lt;13) //2Byte传输#define AD9516_MODE2_MASK (2&lt;&lt;13) //3Byte传输#define AD9516_MODE3_MASK (3&lt;&lt;13) //Streaming mode 连续传输（LSB或者MSB,均以0x232结尾）//状态脚观察测试#define LDT_TEST (0) //LDT脚切换#define RMON_TEST (1) //LDT脚切换#define STAT_TEST (2) //LDT脚切换//模板typedef struct Board_Bits_Manager_Struct_Pkg&#123; uint16_t F1GA; uint16_t power_stat; //phy电源状态 uint16_t switch_stat; //switch工作状态 uint16_t ad9516_LDT_stat; //AD9516_LDT状态 uint16_t ad9516_STAT_stat; //AD9516_STAT状态 uint16_t ad9516_RMON_stat; //AD9516_RMON状态 uint16_t rsvd[2]; &#125;BDBITPKG;typedef struct AD9516_Struct_REG&#123; //Serial Port Configuration , addr:0x000~0x004; uint8_t h000__Serial_port_configuration; // (address 000h ,8bit) uint8_t h003__Part_ID; // (address 003h ,8bit) uint8_t h004__Readback_control; // (address 004h ,8bit) //PLL , addr:0x010~0x01F; uint8_t h010__PFD_and_charge_pump; // (address 010h ,8bit) uint8_t h011__R_counter_LSB; // (address 011h ,8bit) uint8_t h012__R_counter_MSB; // (address 012h ,8bit) uint8_t h013__A_counter; // (address 013h ,8bit) uint8_t h014__B_counter_LSB; // (address 014h ,8bit) uint8_t h015__B_counter_MSB; // (address 015h ,8bit) uint8_t h016__PLL_Control1; // (address 016h ,8bit) uint8_t h017__PLL_Control2; // (address 017h ,8bit) uint8_t h018__PLL_Control3; // (address 018h ,8bit) uint8_t h019__PLL_Control4; // (address 019h ,8bit) uint8_t h01A__PLL_Control5; // (address 01Ah ,8bit) uint8_t h01B__PLL_Control6; // (address 01Bh ,8bit) uint8_t h01C__PLL_Control7; // (address 01Ch ,8bit) uint8_t h01D__PLL_Control8; // (address 01Dh ,8bit) uint8_t h01E__PLL_Control9; // (address 01Eh ,8bit) uint8_t h01F__PLL_readback; // (address 01Fh ,8bit) //Delay Adjust - OUT6 to OUT9 , addr:0x0A0~0x0AB; uint8_t h0A0__OUT6_delay_bypass; // (address 0A0h ,8bit) uint8_t h0A1__OUT6_delay_full_scale; // (address 0A1h ,8bit) uint8_t h0A2__OUT6_delay_fraction; // (address 0A2h ,8bit) uint8_t h0A3__OUT7_delay_bypass; // (address 0A3h ,8bit) uint8_t h0A4__OUT7_delay_full_scale; // (address 0A4h ,8bit) uint8_t h0A5__OUT7_delay_fraction; // (address 0A5h ,8bit) uint8_t h0A6__OUT8_delay_bypass; // (address 0A6h ,8bit) uint8_t h0A7__OUT8_delay_full_scale; // (address 0A7h ,8bit) uint8_t h0A8__OUT8_delay_fraction; // (address 0A8h ,8bit) uint8_t h0A9__OUT9_delay_bypass; // (address 0A9h ,8bit) uint8_t h0AA__OUT9_delay_full_scale; // (address 0AAh ,8bit) uint8_t h0AB__OUT9_delay_fraction; // (address 0ABh ,8bit) //LVPECL Outputs , addr:0x0F0~0x0F5; uint8_t h0F0__OUT0; // (address 0F0h ,8bit) uint8_t h0F1__OUT1; // (address 0F1h ,8bit) uint8_t h0F2__OUT2; // (address 0F2h ,8bit) uint8_t h0F3__OUT3; // (address 0F3h ,8bit) uint8_t h0F4__OUT4; // (address 0F4h ,8bit) uint8_t h0F5__OUT5; // (address 0F5h ,8bit) //LVDS/CMOS Outputs , addr:0x140~0x143; uint8_t h140__OUT6; // (address 140h ,8bit) uint8_t h141__OUT7; // (address 141h ,8bit) uint8_t h142__OUT8; // (address 142h ,8bit) uint8_t h143__OUT9; // (address 143h ,8bit) //LVPECL Channel Dividers , addr:0x190~0x198; uint8_t h190__Divider0_1; // (address 190h ,8bit) uint8_t h191__Divider0_2; // (address 191h ,8bit) uint8_t h192__Divider0_3; // (address 192h ,8bit) uint8_t h193__Divider1_1; // (address 193h ,8bit) uint8_t h194__Divider1_2; // (address 194h ,8bit) uint8_t h195__Divider1_3; // (address 195h ,8bit) uint8_t h196__Divider2_1; // (address 196h ,8bit) uint8_t h197__Divider2_2; // (address 197h ,8bit) uint8_t h198__Divider2_3; // (address 198h ,8bit) //LVDS/CMOS Channel Dividers , addr:0x199~0x1A2; uint8_t h199__Divider3_1; // (address 199h ,8bit) uint8_t h19A__Divider3_2; // (address 19Ah ,8bit) uint8_t h19B__Divider3_3; // (address 19Bh ,8bit) uint8_t h19C__Divider3_4; // (address 19Ch ,8bit) uint8_t h19D__Divider3_5; // (address 19Dh ,8bit) uint8_t h19E__Divider4_1; // (address 19Eh ,8bit) uint8_t h19F__Divider4_2; // (address 19Fh ,8bit) uint8_t h1A0__Divider4_3; // (address 1A0h ,8bit) uint8_t h1A1__Divider4_4; // (address 1A1h ,8bit) uint8_t h1A2__Divider4_5; // (address 1A2h ,8bit) //VCO Divider and CLK Input , addr:0x1E0~0x1E1; uint8_t h1E0__VCO_divider; // (address 1E0h ,8bit) uint8_t h1E1__Input_CLKs; // (address 1E1h ,8bit) //System , addr:0x000~0x004; uint8_t h230__Power_down_and_sync; // (address 230h ,8bit) //Update all registers, addr:0x000~0x004; uint8_t h232__Update_all_registers; // (address 232h ,8bit) //自动清零// uint8_t rsvd[3];&#125;AD9516REG;typedef struct AD9516_Struct_Pin_Status&#123; uint8_t LDT_Status[64]; uint8_t STAT_Status[64]; uint8_t RMON_Status[32]; uint8_t rsvd[1]; &#125;AD9516PIN_STATUS;#define AD9516REG_LEN (sizeof(AD9516REG))extern BDBITPKG bdBITPkg;extern int AD9516Reg_init(void);extern AD9516REG ad9516reg;extern AD9516PIN_STATUS ad9516PinStatus;extern int ad9516_init(void);extern int ad9516_read(uint16_t addr);extern int ad9516_write(uint16_t addr, uint8_t pdata);extern int ad9516_config(void);extern int ad9516_readReg(void);extern int ad9516_STATUS_PIN(void);extern int ad9516PinStatus_TEST(int PinTest,int i);extern int ad9516_reset(void);extern int ad9516_release(void);extern int ad9516_RefSel_Up(void);extern int ad9516_RefSel_Down(void);extern int ad9516_SYNCN_Up(void);extern int ad9516_SYNCN_Down(void);extern int ad9516_LDT_State(void);extern int ad9516_STAT_State(void);extern int ad9516_RMON_State(void);extern uint32_t spi1_oprate(uint16_t data0, uint8_t data1, void* pbuf, int len);#endif //__AD9516_3_H__/******************* END OF FILE *********/ user_spi.c 12345678910111213141516171819202122232425262728293031323334//user_spi.c#include &quot;user_spi.h&quot;int spi1_mass_low ( void )&#123; // return 0;&#125;int spi1_mass_high ( void )&#123; // return 0;&#125;int spi1_masck_low ( void )&#123; // return 0;&#125;int spi1_masck_high ( void )&#123; // return 0;&#125;uint8_t spi1_writeread ( uint8_t data)&#123; return 0;&#125;/******************* END OF FILE *********/ user_spi.h 1234567891011121314151617181920//user_spi.h#ifndef __USER_SPI_H#define __USER_SPI_H#include &quot;sys.h&quot;extern void spi1_init(void);extern int spi1_mass_low ( void );extern int spi1_mass_high ( void );extern int spi1_masck_low ( void );extern int spi1_masck_high ( void );extern uint8_t spi1_writeread (uint8_t data);#endif /* __USER_SPI_H *//******************* END OF FILE *********/ main.c 1234567891011121314151617181920212223242526272829303132333435363738394041//main.c#include &quot;sys.h&quot;#include &quot;delay.h&quot;#include &quot;ad9516_3.h&quot;int main(void) &#123; AD9516Reg_init(); ad9516_SYNCN_Up(); delaysoft(200); ad9516_RefSel_Down(); delaysoft(200); ad9516_SYNCN_Up(); delaysoft(200); ad9516_reset(); delaysoft(20000); ad9516_release(); delaysoft(200); // ad9516_SYNCN_Down();// delaysoft(200);// ad9516_SYNCN_Up();// delaysoft(200); ad9516_config(); delaysoft(20); while(1) &#123; bdBITPkg.ad9516_LDT_stat = ad9516_LDT_State(); bdBITPkg.ad9516_STAT_stat = ad9516_STAT_State(); bdBITPkg.ad9516_RMON_stat = ad9516_RMON_State(); ad9516_readReg();// ad9516_STATUS_PIN(); &#125;&#125;/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈","categories":[{"name":"MCU 应用练习","slug":"MCU-应用练习","permalink":"https://sirius-blog.github.io/categories/MCU-%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"库函数应用练习","slug":"库函数应用练习","permalink":"https://sirius-blog.github.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1应用练习(2) 驱动BCM5396器件","slug":"study-ic-arm/practices-mcu/stm32f1/002 STM32F1应用练习(2) 驱动BCM5396器件","date":"2022-12-07T00:29:18.000Z","updated":"2023-06-10T23:13:26.400Z","comments":true,"path":"posts/842477263.html","link":"","permalink":"https://sirius-blog.github.io/posts/842477263.html","excerpt":"","text":"说明：应用代码段已经验证，本文章旨在移植及适配 STM32F1。 器件 主芯片：ST STM32F103 。 驱动器件：BCM5396 。 目的 驱动SPI接口器件BCM5396。 电路 硬件连接关系： 点我查看图纸细节 MCU管脚分配： 信号 方向 管脚 说明 MCU_SWSS output PA4 SPI接口cs MCU_SWSCK output PA5 SPI接口sck MCU_SWMISO input PA6 SPI接口miso MCU_SWMOSI output PA7 SPI接口mosi SWRESET_3V3 output PA7 BCM5396复位接口RESETB 思路 使用模拟SPI接口对BCM5396器件进行访问。 驱动 bcm5396.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019// bcm5396.c#include &quot;delay.h&quot;#include &quot;bcm5396.h&quot; #include &quot;user_spi.h&quot;CTLREGPKG ctlregPKG; //Page:00h,Status RegSTATREGPKG statregPKG; //Page:01h,Status RegMMREGPKG mmregPKG; //Page 02h Management Mode registersARLCREGPKG arlcregPKG; //Page 04h ARL Control registersARLAREGPKG arlaregPKG; //Page 05h ARL Access registersISDREGPKG isdregPKG[16]; //Page 10h-1Fh Port0-15 Integrated SerDes registersQOSREGPKG qosregPKG; //Page 30h QoS registersVLANREGPKG vlanregPKG; //Page 31h VLAN registersTRUNKREGPKG trunkregPKG;//Page 32h Trunking registersIEEEVREGPKG ieeevregPKG;//Page 34h IEEE Standard 802.1Q VLAN registersJUMBOREGPKG JumboregPKG;//Page 40h Jumbo registersBSSREGPKG bssregPKG;//Page 41h Broadcast Storm Suppression registersIEEEMREGPKG ieeemregPKG;//Page 43h IEEE Standard 802.1s Multiple Spanning Tree registersEXTERPHYREGPKG exterphyregPKG[16];//Page 80h, External PHY Registers (Serial Ports0) GLOBALREGPKG globalregPKG;int GlobalBit_init(void)&#123; memset(&amp;globalregPKG, 0, sizeof(GLOBALREGPKG)); return 0;&#125;//初始化BCM396 （配置各端口模式）int bcm5396_init(void)&#123; int value = 0; int i = 0; value = bcm5396_config(0, BCM5396_NOR_MODE, 0, BCM5396_100M_SPD); //LRM PHY 100M value = bcm5396_config(1, BCM5396_NOR_MODE, 1, BCM5396_1000M_SPD); //LRM SGMII 1000M ： SW value = bcm5396_config(2, BCM5396_NOR_MODE, 0, BCM5396_100M_SPD); //J30J SGMII 100M ： MCU value = bcm5396_config(3, BCM5396_NOR_MODE, 0, BCM5396_1000M_SPD); //DSP0 SGMII 1000M ：DSP0 value = bcm5396_config(4, BCM5396_NOR_MODE, 0, BCM5396_1000M_SPD); //DSP1 SGMII 1000M ：DSP1 value = bcm5396_config(5, BCM5396_NOR_MODE, 0, BCM5396_1000M_SPD); //FPGA0 SGMII 1000M ：FPGA1 value = bcm5396_config(6, BCM5396_NOR_MODE, 0, BCM5396_1000M_SPD); //FPGA1 SGMII 1000M ：FPGA2 for(i = 7;i &lt; 16;i++) &#123; bcm5396_config(i, BCM5396_DIS_MODE, 0, BCM5396_100M_SPD); &#125; return value;&#125;//BCM396读数据操作int bcm5396_read(int page, int addr, void* pbuf ,int len)&#123; int rc = 0; int i; uint8_t temData; uint8_t wrcmd; uint8_t cmd; uint8_t* pdata = (uint8_t*)(pbuf); cmd = 0xfe; wrcmd = BCM_READ_CMD; for(i = 0;i &lt; SPI_WAIT_TIMEOUT;i++) &#123; rc = spi_oprate(wrcmd, cmd, 0, NULL, 0); if ((rc &amp; 0x80) == 0) break; &#125; if (i == SPI_WAIT_TIMEOUT) &#123; /* reset */ cmd = 0xff; wrcmd = BCM_WRITE_CMD; temData = rc &amp; 0xFF; rc = spi_oprate(wrcmd, cmd, temData , NULL, 0); return -1; &#125; cmd = 0xff; wrcmd = BCM_WRITE_CMD; temData = page; rc = spi_oprate(wrcmd, cmd, temData, NULL, 0); cmd = addr; wrcmd = BCM_READ_CMD; rc = spi_oprate(wrcmd, cmd, 0 , NULL, 0); cmd = 0xfe; wrcmd = BCM_READ_CMD; for(i = 0;i &lt; SPI_WAIT_TIMEOUT;i++) &#123; rc = spi_oprate(wrcmd, cmd, 0, NULL, 0); if ((rc &amp; 0x20) != 0) break; &#125; if (i == SPI_WAIT_TIMEOUT) &#123; /* reset */ cmd = 0xff; wrcmd = BCM_WRITE_CMD; temData = rc &amp; 0xFF; rc = spi_oprate(wrcmd, cmd, temData , NULL, 0); return -1; &#125; wrcmd = BCM_READ_CMD; for (i = 0; i &lt; len; i++) &#123; cmd = 0xf0 + i; rc = spi_oprate(wrcmd, cmd, 0 , NULL, 0); pdata[i] = rc &amp; 0xFF; &#125; return len;&#125;//BCM396写数据操作int bcm5396_write(int page, int addr, void* pbuf ,int len)&#123; int rc = 0; int i; uint8_t temData; uint8_t wrcmd; uint8_t cmd; uint8_t* pdata = (uint8_t*)(pbuf); cmd = 0xfe; wrcmd = BCM_READ_CMD; for(i = 0;i &lt; SPI_WAIT_TIMEOUT;i++) &#123; rc = spi_oprate(wrcmd, cmd, 0, NULL, 0); if ((rc &amp; 0x80) == 0) break; &#125; if (i == SPI_WAIT_TIMEOUT) &#123; /* reset */ cmd = 0xff; wrcmd = BCM_WRITE_CMD; temData = rc &amp; 0xFF; rc = spi_oprate(wrcmd, cmd, temData , NULL, 0); return -1; &#125; cmd = 0xff; wrcmd = BCM_WRITE_CMD; temData = page; rc = spi_oprate(wrcmd, cmd, temData, NULL, 0); wrcmd = BCM_WRITE_CMD; cmd = addr; temData = pdata[0]; rc = spi_oprate(wrcmd, cmd, temData , &amp;pdata[1], len); return len;&#125;//BCM396配置操作int bcm5396_config(int port, int mode, int swmode, int speed)&#123; int value = 0; int addr = 0; int setval = 0; int i = 0; if((mode &lt; 0) || (mode &gt; BCM5396_FORWARD_MODE)) mode = BCM5396_DIS_MODE; if(mode != BCM5396_DIS_MODE) &#123; addr = port + 0x60; if(speed == BCM5396_1000M_SPD) setval = 0x8b; //有更改 else setval = 0x87; for(i = 0;i &lt; 10;i++) &#123; value = bcm5396_write(0x0, addr, &amp;setval, 1); //page-00h , addr-60~6Fh delay_us(1000); &#125; bcm5396_write(0x0, addr, &amp;setval, 1); //page-00h , addr-60~6Fh value = bcm5396_read(0x0, addr, &amp;setval, 1); addr = port + 0x10; if(swmode) &#123; setval = 0x01F1; &#125; else &#123; setval = 0x01f0; &#125; bcm5396_write(addr, 0x20, &amp;setval, 2); //page-10~1Fh , addr-20h value = bcm5396_read(addr, 0x20, &amp;setval, 2); if(speed == BCM5396_1000M_SPD) &#123; setval = 0x1340; //有更改 &#125; else &#123; setval = 0x3300; &#125; bcm5396_write(addr, 0x00, &amp;setval, 2); //page-10~1Fh , addr-00h value = bcm5396_read(addr, 0x00, &amp;setval, 2); &#125; setval = mode &lt;&lt; BCM5396_MODE_LFSB; bcm5396_write(0x00, port, &amp;setval, 1); //page-00h , addr-00~0Fh value = bcm5396_read(0x00, port, &amp;setval, 1); return value;&#125;//BCM396读各PAGE寄存器操作//===================================================//=== BCM5396 ,Page:00h ,Control registers ==========int ControlBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;ctlregPKG, 0, sizeof(CTLREGPKG)); return 0;&#125;//8bit-Reg Readint BCM5396_ControlReg1(void)&#123; uint8_t RegAddr[45] = &#123;0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f, 0x10,0x20,0x3b,0x50,0x51,0x52,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69, 0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x77,0x86,0x88,0x89,0x90,0xa0&#125;; //8bit-Reg addr uint8_t *pReg = (uint8_t *)(&amp;ctlregPKG.Port_Control_reg0); for(int i = 0;i &lt; 45;i++) &#123; bcm5396_read(0x00, RegAddr[i], &amp;pReg[i], 1); //执行读操作流程 &#125; return 0;&#125;//16bit-Reg Readint BCM5396_ControlReg2(void)&#123; uint8_t RegAddr[3] = &#123;0x24,0x84,0x8a&#125;; //16bit-Reg addr uint16_t *pReg = (uint16_t *)(&amp;ctlregPKG.LED_Control_reg); for(int i = 0;i &lt; 3;i++) &#123; bcm5396_read(0x00, RegAddr[i], &amp;pReg[i], 2); &#125; return 0;&#125;//32bit-Reg Readint BCM5396_ControlReg3(void)&#123; uint8_t RegAddr[3] = &#123;0x58,0x78,0x80&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;ctlregPKG.Failed_Forward_Map_reg); for(int i = 0;i &lt; 3;i++) &#123; bcm5396_read(0x00, RegAddr[i], &amp;pReg[i], 4); &#125; return 0;&#125;//=============================================//=== BCM5396 ,Page:01h ,Status Reg ==========int StatusBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;statregPKG, 0, sizeof(STATREGPKG)); return 0;&#125;//8bit-Reg Readint BCM5396_StatusReg1(void)&#123; uint8_t RegAddr[16] = &#123;0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f&#125;; //8bit-Reg addr uint8_t *pReg = (uint8_t *)(&amp;statregPKG.Port_PHY_Status_reg0); for(int i=0; i&lt;16;i++) &#123; bcm5396_read(0x01, RegAddr[i], &amp;pReg[i], 1); //执行读操作流程 &#125; return 0;&#125;//16bit-Reg Readint BCM5396_StatusReg2(void)&#123; uint8_t RegAddr[1] = &#123;0x40&#125;; //16bit-Reg addr uint16_t *pReg = (uint16_t *)(&amp;statregPKG.SerDes_Signal_Detection_Status_reg); for(int i=0; i&lt;1;i++) &#123; bcm5396_read(0x01, RegAddr[i], &amp;pReg[i], 2); //执行读操作流程 &#125; return 0;&#125;//32bit-Reg Readint BCM5396_StatusReg3(void)&#123; uint8_t RegAddr[6] = &#123;0x70,0x00,0x04,0x10,0x14,0x18&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;statregPKG.Strap_Value_reg); for(int i=0; i&lt;6;i++) &#123; bcm5396_read(0x01, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//64bit-Reg Readint BCM5396_StatusReg4(void)&#123; uint8_t RegAddr[1] = &#123;0x08&#125;; //64bit-Reg addr uint64_t *pReg = (uint64_t *)(&amp;statregPKG.Port_Speed_Summary_reg); for(int i=0; i&lt;1;i++) &#123; bcm5396_read(0x01, RegAddr[i], &amp;pReg[i], 8); //执行读操作流程 &#125; return 0;&#125;//==============================================================//=== BCM5396 ,Page 02h , Management Mode registers ==========int ManageBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;mmregPKG, 0, sizeof(MMREGPKG)); return 0;&#125;//8bit-Reg Readint BCM5396_ManageReg1(void)&#123; uint8_t RegAddr[3] = &#123;0x00,0x30,0x40&#125;; //8bit-Reg addr uint8_t *pReg = (uint8_t *)(&amp;mmregPKG.Global_Manage_Config); for(int i=0; i&lt;3;i++) &#123; bcm5396_read(0x02, RegAddr[i], &amp;pReg[i], 1); //执行读操作流程 &#125; return 0;&#125;//16bit-Reg Readint BCM5396_ManageReg2(void)&#123; uint8_t RegAddr[2] = &#123;0x10,0x16&#125;; //16bit-Reg addr uint16_t *pReg = (uint16_t *)(&amp;mmregPKG.Mirror_Capture_Control); for(int i=0; i&lt;2;i++) &#123; bcm5396_read(0x02, RegAddr[i], &amp;pReg[i], 2); //执行读操作流程 &#125; return 0;&#125;//32bit-Reg Readint BCM5396_ManageReg3(void)&#123; uint8_t RegAddr[3] = &#123;0x0c,0x12,0x1c&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;mmregPKG.Aging_Time_Control); for(int i=0; i&lt;3;i++) &#123; bcm5396_read(0x02, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//==============================================================//=== BCM5396 ,Page 04h , ARL Control registers ==========int ARLCBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;arlcregPKG, 0, sizeof(ARLCREGPKG)); return 0;&#125;//8bit-Reg Readint BCM5396_ARLControlReg1(void)&#123; uint8_t RegAddr[1] = &#123;0x00&#125;; //8bit-Reg addr uint8_t *pReg = (uint8_t *)(&amp;arlcregPKG.Global_ARL_Config); for(int i=0; i&lt;1;i++) &#123; bcm5396_read(0x04, RegAddr[i], &amp;pReg[i], 1); //执行读操作流程 &#125; return 0;&#125;//32bit-Reg Readint BCM5396_ARLControlReg3(void)&#123; uint8_t RegAddr[2] = &#123;0x16,0x26&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;arlcregPKG.Multiport_Address1); for(int i=0; i&lt;2;i++) &#123; bcm5396_read(0x04, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//64bit-Reg Readint BCM5396_ARLControlReg4(void)&#123; uint8_t RegAddr[3] = &#123;0x04,0x10,0x20&#125;; //64bit-Reg addr uint64_t *pReg = (uint64_t *)(&amp;arlcregPKG.BPDU_Multicast_Address); for(int i=0; i&lt;3;i++) &#123; bcm5396_read(0x04, RegAddr[i], &amp;pReg[i], 8); //执行读操作流程 &#125; return 0;&#125;//=============================================//=== BCM5396 ,Page:05h ,ARL Access registers ==========int ARLABit_init(void)&#123;//初始化寄存器结构体· memset(&amp;arlaregPKG, 0, sizeof(ARLAREGPKG)); return 0;&#125;//8bit-Reg Readint BCM5396_ARLAccessReg1(void)&#123; uint8_t RegAddr[3] = &#123;0x00,0x30,0x60&#125;; //8bit-Reg addr uint8_t *pReg = (uint8_t *)(&amp;arlaregPKG.ARL_RW_Control); for(int i=0; i&lt;3;i++) &#123; bcm5396_read(0x05, RegAddr[i], &amp;pReg[i], 1); //执行读操作流程 &#125; return 0;&#125;//16bit-Reg Readint BCM5396_ARLAccessReg2(void)&#123; uint8_t RegAddr[3] = &#123;0x08,0x31,0x61&#125;; //16bit-Reg addr uint16_t *pReg = (uint16_t *)(&amp;arlaregPKG.VLAN_ID_Index); for(int i=0; i&lt;3;i++) &#123; bcm5396_read(0x05, RegAddr[i], &amp;pReg[i], 2); //执行读操作流程 &#125; return 0;&#125;//32bit-Reg Readint BCM5396_ARLAccessReg3(void)&#123; uint8_t RegAddr[4] = &#123;0x18,0x28,0x3b,0x48&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;arlaregPKG.ARL_FWD_Entry0); for(int i=0; i&lt;4;i++) &#123; bcm5396_read(0x05, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//64bit-Reg Readint BCM5396_ARLAccessReg4(void)&#123; uint8_t RegAddr[6] = &#123;0x02,0x10,0x20,0x33,0x40,0x63&#125;; //64bit-Reg addr uint64_t *pReg = (uint64_t *)(&amp;arlaregPKG.MAC_Address_Index); for(int i=0; i&lt;6;i++) &#123; bcm5396_read(0x05, RegAddr[i], &amp;pReg[i], 8); //执行读操作流程 &#125; return 0;&#125;//==============================================================//=== BCM5396 ,Page:10~1Fh ,Integrated SerDes registers ==========int IsdregBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;isdregPKG[0], 0, sizeof(ISDREGPKG) * 16); return 0;&#125;int BCM5396_ISDReg2_0(int index)&#123; uint8_t page = 0x10 + index; //8bit-Reg page uint8_t RegAddr[20] = &#123;0x00,0x02,0x08,0x0a,0x0c,0x1e,0x20,0x22,0x24,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x3a,0x3c,0x3e&#125;; //8bit-Reg addr uint16_t *pReg = (uint16_t *)(&amp;isdregPKG[index].MII_Control_Register); for(int i=0; i&lt;17;i++) &#123; bcm5396_read(page, RegAddr[i], &amp;pReg[i], 2); //执行读操作流程 &#125; return 0;&#125;//=============================================//=== BCM5396 ,Page:30h ,QoS registers ==========int QOSBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;qosregPKG, 0, sizeof(QOSREGPKG)); return 0;&#125;//8bit-Reg Readint BCM5396_QOSReg1(void)&#123; uint8_t RegAddr[7] = &#123;0x00,0x80,0x81,0x82,0x83,0x84,0xa4&#125;; //8bit-Reg addr uint8_t *pReg = (uint8_t *)(&amp;qosregPKG.QoS_Global_Control_Reg); for(int i=0; i&lt;7;i++) &#123; bcm5396_read(0x30, RegAddr[i], &amp;pReg[i], 1); //执行读操作流程 &#125; return 0;&#125;//16bit-Reg Readint BCM5396_QOSReg2(void)&#123; uint8_t RegAddr[18] = &#123;0x01,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e, 0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70&#125;; //16bit-Reg addr uint16_t *pReg = (uint16_t *)(&amp;qosregPKG.QoS_Threshold_Control_Reg); for(int i=0; i&lt;18;i++) &#123; bcm5396_read(0x30, RegAddr[i], &amp;pReg[i], 2); //执行读操作流程 &#125; return 0;&#125;//32bit-Reg Readint BCM5396_QOSReg3(void)&#123; uint8_t RegAddr[5] = &#123;0x04,0x08,0x10,0x88,0xa0&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;qosregPKG.QoS_1P_Enable_Reg); for(int i=0; i&lt;5;i++) &#123; bcm5396_read(0x30, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//64bit-Reg Readint BCM5396_QOSReg4(void)&#123; uint8_t RegAddr[4] = &#123;0x30,0x36,0x3c,0x42&#125;; //64bit-Reg addr uint64_t *pReg = (uint64_t *)(&amp;qosregPKG.DiffServ_Priority_Map_Reg0); for(int i=0; i&lt;4;i++) &#123; bcm5396_read(0x30, RegAddr[i], &amp;pReg[i], 8); //执行读操作流程 &#125; return 0;&#125;//=============================================//=== BCM5396 ,Page:31h ,VLAN registers ==========int VLANBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;vlanregPKG, 0, sizeof(VLANREGPKG)); return 0;&#125;//32bit-Reg Readint BCM5396_VLANReg3(void)&#123; uint8_t RegAddr[17] = &#123;0x00,0x04,0x08,0x0c,0x10,0x14,0x18,0x1c, 0x20,0x24,0x28,0x2c,0x30,0x34,0x38,0x3c,0x40&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;vlanregPKG.Port_VLAN_Reg0); for(int i=0; i&lt;17;i++) &#123; bcm5396_read(0x30, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//=============================================//=== BCM5396 ,Page:32h ,Trunking registers ==========int TrunkBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;trunkregPKG, 0, sizeof(TRUNKREGPKG)); return 0;&#125;//8bit-Reg Readint BCM5396_TrunkReg1(void)&#123; uint8_t RegAddr[1] = &#123;0x01&#125;; //8bit-Reg addr uint8_t *pReg = (uint8_t *)(&amp;trunkregPKG.MAC_Trunk_Control_Reg); for(int i=0; i&lt;1;i++) &#123; bcm5396_read(0x32, RegAddr[i], &amp;pReg[i], 1); //执行读操作流程 &#125; return 0;&#125;//32bit-Reg Readint BCM5396_TrunkReg3(void)&#123; uint8_t RegAddr[4] = &#123;0x90,0x94,0x98,0x9c&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;trunkregPKG.Trunk_Group0_in_chip0); for(int i=0; i&lt;4;i++) &#123; bcm5396_read(0x32, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//=============================================//=== BCM5396 ,Page:34h ,IEEE Standard 802.1Q VLAN registers ==========int IEEEVBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;ieeevregPKG, 0, sizeof(IEEEVREGPKG)); return 0;&#125;//8bit-Reg Readint BCM5396_IEEEVLANReg1(void)&#123; uint8_t RegAddr[6] = &#123;0x00,0x01,0x02,0x07,0x08,0x09&#125;; //8bit-Reg addr uint8_t *pReg = (uint8_t *)(&amp;ieeevregPKG.Global_Control_Reg0); for(int i=0; i&lt;6;i++) &#123; bcm5396_read(0x34, RegAddr[i], &amp;pReg[i], 1); //执行读操作流程 &#125; return 0;&#125;//16bit-Reg Readint BCM5396_IEEEVLANReg2(void)&#123; uint8_t RegAddr[17] = &#123;0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e, 0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30&#125;; //16bit-Reg addr uint16_t *pReg = (uint16_t *)(&amp;ieeevregPKG.Default_IEEE_Standard_Tag_Port0); for(int i=0; i&lt;17;i++) &#123; bcm5396_read(0x34, RegAddr[i], &amp;pReg[i], 2); //执行读操作流程 &#125; return 0;&#125;//32bit-Reg Readint BCM5396_IEEEVLANReg3(void)&#123; uint8_t RegAddr[2] = &#123;0x03,0x0c&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;ieeevregPKG.Global_Control_Reg3); for(int i=0; i&lt;2;i++) &#123; bcm5396_read(0x34, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//=============================================//=== BCM5396 ,Page:40h ,Jumbo registers ==========int JumboBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;JumboregPKG, 0, sizeof(JUMBOREGPKG)); return 0;&#125;//32bit-Reg Readint BCM5396_JumboReg3(void)&#123; uint8_t RegAddr[1] = &#123;0x01&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;JumboregPKG.Jumbo_Frame_Port_Mask_Reg); for(int i=0; i&lt;1;i++) &#123; bcm5396_read(0x40, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//=============================================//=== BCM5396 ,Page:41h ,Broadcast Storm Suppression registers ==========int BSSBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;bssregPKG, 0, sizeof(BSSREGPKG)); return 0;&#125;//16bit-Reg Readint BCM5396_BSSReg2(void)&#123; uint8_t RegAddr[16] = &#123;0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e, 0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e&#125;; //16bit-Reg addr uint16_t *pReg = (uint16_t *)(&amp;bssregPKG.Port_Receive_Rate_Control_Reg0); for(int i=0; i&lt;16;i++) &#123; bcm5396_read(0x41, RegAddr[i], &amp;pReg[i], 2); //执行读操作流程 &#125; return 0;&#125;//32bit-Reg Readint BCM5396_BSSReg3(void)&#123; uint8_t RegAddr[17] = &#123;0x00,0x10,0x14,0x18,0x1c,0x20,0x24,0x28,0x2c, 0x30,0x34,0x38,0x3c,0x40,0x44,0x48,0x4c&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;bssregPKG.Suppression_Control_Reg); for(int i=0; i&lt;17;i++) &#123; bcm5396_read(0x41, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//=============================================//=== BCM5396 ,Page:43h ,IEEE Standard 802.1s Multiple Spanning Tree registers ==========int IEEEMBit_init(void)&#123;//初始化寄存器结构体· memset(&amp;ieeemregPKG, 0, sizeof(IEEEMREGPKG)); return 0;&#125;//8bit-Reg Readint BCM5396_IEEEMReg1(void)&#123; uint8_t RegAddr[1] = &#123;0x00&#125;; //8bit-Reg addr uint8_t *pReg = (uint8_t *)(&amp;ieeemregPKG.MSPT_Control_Reg); for(int i=0; i&lt;1;i++) &#123; bcm5396_read(0x43, RegAddr[i], &amp;pReg[i], 1); //执行读操作流程 &#125; return 0;&#125;//64bit-Reg Readint BCM5396_IEEEMReg4(void)&#123; uint8_t RegAddr[32] = &#123;0x10,0x16,0x1c,0x22,0x28,0x2e,0x34,0x3a, 0x40,0x46,0x4c,0x52,0x58,0x5e,0x64,0x6a, 0x70,0x76,0x7c,0x82,0x88,0x8e,0x94,0x9a, 0xa0,0xa6,0xac,0xb2,0xb8,0xbe,0xc4,0xca&#125;; //64bit-Reg addr uint64_t *pReg = (uint64_t *)(&amp;ieeemregPKG.MST_Table_Reg0); for(int i=0; i&lt;32;i++) &#123; bcm5396_read(0x43, RegAddr[i], &amp;pReg[i], 8); //执行读操作流程 &#125; return 0;&#125;//=============================================//=== BCM5396 ,Page:80h ,External PHY Registers (Serial Ports) ==========int EXTERPHYBit_init_0(void)&#123;//初始化寄存器结构体· memset(&amp;exterphyregPKG[0], 0, sizeof(EXTERPHYREGPKG) * 16); return 0;&#125;//16bit-Reg Readint BCM5396_EXTERPHYReg2_0(int index)&#123; uint8_t page = 0x80 + index; uint8_t RegAddr[10] = &#123;0x00,0x02,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x1e&#125;; //16bit-Reg addr uint16_t *pReg = (uint16_t *)(&amp;exterphyregPKG[index].MII_Control_Register); for(int i=0; i&lt;10;i++) &#123; bcm5396_read(page, RegAddr[i], &amp;pReg[i], 2); //执行读操作流程 &#125; return 0;&#125;//32bit-Reg Readint BCM5396_EXTERPHYReg3_0(int index)&#123; uint8_t page = 0x80 + index; uint8_t RegAddr[1] = &#123;0x04&#125;; //32bit-Reg addr uint32_t *pReg = (uint32_t *)(&amp;exterphyregPKG[index].PHY_Identifier_Register); for(int i=0; i&lt;1;i++) &#123; bcm5396_read(page, RegAddr[i], &amp;pReg[i], 4); //执行读操作流程 &#125; return 0;&#125;//-------------------------------------//打印BCM5396所有寄存器void showBCM5396Regs(void)&#123; int i = 0; //=== BCM5396 ,Page:00h ,Control registers ========== BCM5396_ControlReg1(); BCM5396_ControlReg2(); BCM5396_ControlReg3(); //=== BCM5396 ,Page:01h ,Status Reg ========== BCM5396_StatusReg1(); BCM5396_StatusReg2(); BCM5396_StatusReg3(); BCM5396_StatusReg4(); //=== BCM5396 ,Page 02h , Management Mode registers ========== BCM5396_ManageReg1(); BCM5396_ManageReg2(); BCM5396_ManageReg3(); //=== BCM5396 ,Page 04h , ARL Control registers ========== BCM5396_ARLControlReg1(); BCM5396_ARLControlReg3(); BCM5396_ARLControlReg4(); //=== BCM5396 ,Page:05h ,ARL Access registers ========== BCM5396_ARLAccessReg1(); BCM5396_ARLAccessReg2(); BCM5396_ARLAccessReg3(); BCM5396_ARLAccessReg4(); //=== BCM5396 ,Page:10~1Fh ,Integrated SerDes registers ========== //Page:10h ~ 1Fh for(i = 0;i &lt; 16;i++) &#123; BCM5396_ISDReg2_0(i); &#125; //=== BCM5396 ,Page:30h ,QoS registers ========== BCM5396_QOSReg1(); BCM5396_QOSReg2(); BCM5396_QOSReg3(); BCM5396_QOSReg4(); //=== BCM5396 ,Page:31h ,VLAN registers ========== BCM5396_VLANReg3(); //=== BCM5396 ,Page:32h ,Trunking registers ========== BCM5396_TrunkReg1(); BCM5396_TrunkReg3(); //=== BCM5396 ,Page:34h ,IEEE Standard 802.1Q VLAN registers ========== BCM5396_IEEEVLANReg1(); BCM5396_IEEEVLANReg2(); BCM5396_IEEEVLANReg3(); //=== BCM5396 ,Page:40h ,Jumbo registers ========== BCM5396_JumboReg3(); //=== BCM5396 ,Page:41h ,Broadcast Storm Suppression registers ========== BCM5396_BSSReg2(); BCM5396_BSSReg3(); //=== BCM5396 ,Page:43h ,IEEE Standard 802.1s Multiple Spanning Tree registers ========== BCM5396_IEEEMReg1(); BCM5396_IEEEMReg4(); //=== BCM5396 ,Page:80~8Fh ,External PHY Registers (Serial Ports) ========== //Page:80h ~ 8Fh for(i = 0;i &lt; 16;i++) &#123; BCM5396_EXTERPHYReg2_0(i); BCM5396_EXTERPHYReg3_0(i); &#125;&#125;//5396复位使能int bcm5396_reset(void)&#123; //5396的复位 GPIO_ResetBits (GPIOC, GPIO_Pin_9); return 0;&#125;int bcm5396_release(void)&#123; //5396的复位释放 GPIO_SetBits(GPIOC, GPIO_Pin_9); return 0;&#125;//========================================//访问BCM5396//写读写数据data为 1Bytes (8bits)//spi_WR_1Byte(8bit命令,8bit地址, 8bit数据,SPI模式)uint32_t spi_oprate(uint8_t data0, uint8_t data1, uint8_t data2, void* pbuf, int len)&#123; uint32_t readdata = 0; uint8_t* pdata = (uint8_t*)(pbuf); #if (SPI_MODE == 0) uint8_t mode = 3; #elif(SPI_MODE == 1) uint8_t mode = 1; #endif //根据BCM5396手册中的SPI Timing ,(P154,Figure 35) spi_mass_low (); readdata |= spi_writeread ( data0,mode); //后沿采样(类如标准的SPI[CPOL=1,CPHA=1]) readdata = readdata &lt;&lt; 8; readdata |= spi_writeread ( data1,mode); readdata = readdata &lt;&lt; 8; readdata |= spi_writeread ( data2,mode); if(len &gt; 1) &#123; readdata = readdata &lt;&lt; 8; for(int i = 1;i &lt; len;i++) &#123; readdata |= spi_writeread ( *pdata, mode); readdata = readdata &lt;&lt; 8; pdata++; &#125; &#125; delay_us(10); spi_mass_high (); return readdata;&#125;/******************* END OF FILE *********/ bcm5396.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546// bcm5396.h#ifndef __BCM5396_H__#define __BCM5396_H__#include &quot;sys.h&quot;#include &quot;string.h&quot; #define BCM5396_MODE_LFSB (5)#define BCM5396_NOR_MODE (0)#define BCM5396_DIS_MODE (1)#define BCM5396_BLOCK_MODE (2)#define BCM5396_LISTEN_MODE (3)#define BCM5396_LEARN_MODE (4)#define BCM5396_FORWARD_MODE (5)#define BCM5396_1000M_SPD (0)#define BCM5396_100M_SPD (1)#define INTER_DBG_MODE //#define BCM_READ_CMD (0x60)//#define BCM_WRITE_CMD (0x61)//#define SPI_WAIT_TIMEOUT (100)////---- Page struct ----//Global Registerstypedef struct Global_Registers_Struct_Pkg&#123; uint8_t SPI_Data_IO_Reg0; //SPI Data I/O 0 (address F0h ,8bit) uint8_t SPI_Data_IO_Reg1; //SPI Data I/O 1 (address F1h ,8bit) uint8_t SPI_Data_IO_Reg2; //SPI Data I/O 2 (address F2h ,8bit) uint8_t SPI_Data_IO_Reg3; //SPI Data I/O 3 (address F3h ,8bit) uint8_t SPI_Data_IO_Reg4; //SPI Data I/O 4 (address F4h ,8bit) uint8_t SPI_Data_IO_Reg5; //SPI Data I/O 5 (address F5h ,8bit) uint8_t SPI_Data_IO_Reg6; //SPI Data I/O 6 (address F6h ,8bit) uint8_t SPI_Data_IO_Reg7; //SPI Data I/O 7 (address F7h ,8bit) uint8_t SPI_Status_Reg; //SPI Status register (address FEh ,8bit) uint8_t Page_Reg; //Page register (address FFh ,8bit) uint8_t rsvd[3];&#125;GLOBALREGPKG;//Page 00h Control registerstypedef struct Control_Registers_Struct_Pkg&#123; uint8_t Port_Control_reg0; // Port Control register 0 (address 00h, 8bit) uint8_t Port_Control_reg1; // Port Control register 1 (address 01h, 8bit) uint8_t Port_Control_reg2; // Port Control register 2 (address 02h, 8bit) uint8_t Port_Control_reg3; // Port Control register 3 (address 03h, 8bit) uint8_t Port_Control_reg4; // Port Control register 4 (address 04h, 8bit) uint8_t Port_Control_reg5; // Port Control register 5 (address 05h, 8bit) uint8_t Port_Control_reg6; // Port Control register 6 (address 06h, 8bit) uint8_t Port_Control_reg7; // Port Control register 7 (address 07h, 8bit) uint8_t Port_Control_reg8; // Port Control register 8 (address 08h, 8bit) uint8_t Port_Control_reg9; // Port Control register 9 (address 09h, 8bit) uint8_t Port_Control_reg10; // Port Control register 10 (address 0Ah, 8bit) uint8_t Port_Control_reg11; // Port Control register 11 (address 0Bh, 8bit) uint8_t Port_Control_reg12; // Port Control register 12 (address 0Ch, 8bit) uint8_t Port_Control_reg13; // Port Control register 13 (address 0Dh, 8bit) uint8_t Port_Control_reg14; // Port Control register 14 (address 0Eh, 8bit) uint8_t Port_Control_reg15; // Port Control register 15 (address 0Fh, 8bit) uint8_t IMP_Port_Control_reg; // IMP Port (Port 16) Control register (address 10h ,8bit) uint8_t Switch_Mode_reg; // Switch Mode register (address 20h ,8bit) uint8_t New_Control_reg; // New Control register (address 3Bh ,8bit) uint8_t Multicast_Control_reg; // Reserved—Multicast Control register (address 50h ,8bit) uint8_t Update_Rate_Control_reg; // Load Meter Update Rate Control register (address 51h ,8bit) uint8_t TXq_Flush_Mode_reg; // TXq Flush Mode register(address 52h ,8bit) uint8_t Port_State_Override_reg0; // Port 0 Port State Override register (address 60h ,8bit) uint8_t Port_State_Override_reg1; // Port 1 Port State Override register (address 61h ,8bit) uint8_t Port_State_Override_reg2; // Port 2 Port State Override register (address 62h ,8bit) uint8_t Port_State_Override_reg3; // Port 3 Port State Override register (address 63h ,8bit) uint8_t Port_State_Override_reg4; // Port 4 Port State Override register (address 64h ,8bit) uint8_t Port_State_Override_reg5; // Port 5 Port State Override register (address 65h ,8bit) uint8_t Port_State_Override_reg6; // Port 6 Port State Override register (address 66h ,8bit) uint8_t Port_State_Override_reg7; // Port 7 Port State Override register (address 67h ,8bit) uint8_t Port_State_Override_reg8; // Port 8 Port State Override register (address 68h ,8bit) uint8_t Port_State_Override_reg9; // Port 9 Port State Override register (address 69h ,8bit) uint8_t Port_State_Override_reg10; // Port 10 Port State Override register (address 6Ah ,8bit) uint8_t Port_State_Override_reg11; // Port 11 Port State Override register (address 6Bh ,8bit) uint8_t Port_State_Override_reg12; // Port 12 Port State Override register (address 6Ch ,8bit) uint8_t Port_State_Override_reg13; // Port 13 Port State Override register (address 6Dh ,8bit) uint8_t Port_State_Override_reg14; // Port 14 Port State Override register (address 6Eh ,8bit) uint8_t Port_State_Override_reg15; // Port 15 Port State Override register (address 6Fh ,8bit) uint8_t Port_State_Override_reg16; // Port 16 (IMP) Port State Override register (address 70h ,8bit) uint8_t IEEE_Standard_Control_reg1; // IEEE Standard 802.1x Control register 1 (address 77h ,8bit) uint8_t External_PHY_Scan_Control_reg; // External PHY Scan Control register (address 86h ,8bit) uint8_t Fast_Aging_Control_reg; // Fast Aging Control register (address 88h ,8bit) uint8_t Fast_Aging_Port_reg; // Fast Aging Port register (address 89h ,8bit) uint8_t Pause_Frame_Detection_Control_reg; // Pause Frame Detection Control register (address 90h ,8bit) uint8_t RGMII_Control_reg; // RGMII Control register (address A0h ,8bit) uint16_t LED_Control_reg; // LED Control register (address 24h–25h ,16bit) uint16_t SD_SEL_EARLY_reg; // SD_SEL_EARLY register (address 84h–85h ,16bit) uint16_t Fast_Aging_VID_reg; // Fast Aging VID register (address 8Ah–8Bh ,16bit) uint32_t Failed_Forward_Map_reg; // Multicast Lookup Failed Forward Map register(address 58h–5Bh ,32bit) uint32_t IEEE_Standard_Control_reg2; // IEEE Standard 802.1x Control register 2 (address 78h–7Bh ,32bit) uint32_t SD_Default_reg; // SD Default register (address 80h–83h ,32bit) uint8_t rsvd[1]; &#125;CTLREGPKG;//Page 01h Status registerstypedef struct Status_Registers_Struct_Pkg&#123; uint8_t Port_PHY_Status_reg0; // Port 0 PHY Status register(address 20h ,8bit) uint8_t Port_PHY_Status_reg1; // Port 1 PHY Status register(address 21h ,8bit) uint8_t Port_PHY_Status_reg2; // Port 2 PHY Status register(address 22h ,8bit) uint8_t Port_PHY_Status_reg3; // Port 3 PHY Status register(address 23h ,8bit) uint8_t Port_PHY_Status_reg4; // Port 4 PHY Status register(address 24h ,8bit) uint8_t Port_PHY_Status_reg5; // Port 5 PHY Status register(address 25h ,8bit) uint8_t Port_PHY_Status_reg6; // Port 6 PHY Status register(address 26h ,8bit) uint8_t Port_PHY_Status_reg7; // Port 7 PHY Status register(address 27h ,8bit) uint8_t Port_PHY_Status_reg8; // Port 8 PHY Status register(address 28h ,8bit) uint8_t Port_PHY_Status_reg9; // Port 9 PHY Status register(address 29h ,8bit) uint8_t Port_PHY_Status_reg10; // Port 10 PHY Status register(address 2Ah ,8bit) uint8_t Port_PHY_Status_reg11; // Port 11 PHY Status register(address 2Bh ,8bit) uint8_t Port_PHY_Status_reg12; // Port 12 PHY Status register(address 2Ch ,8bit) uint8_t Port_PHY_Status_reg13; // Port 13 PHY Status register(address 2Dh ,8bit) uint8_t Port_PHY_Status_reg14; // Port 14 PHY Status register(address 2Eh ,8bit) uint8_t Port_PHY_Status_reg15; // Port 15 PHY Status register(address 2Fh ,8bit) uint16_t SerDes_Signal_Detection_Status_reg; //SerDes Signal Detection Status register(address 40h ,16bit) uint32_t Strap_Value_reg; //Strap Value register(address 70h–73h ,32bit) uint32_t Link_Status_Summary_reg; // Link Status Summary register(address 00h–03h ,32bit) uint32_t Link_Status_Change_reg; // Link Status Change register(address 04h–07h ,32bit) uint32_t Duplex_Status_Summary_reg; // Duplex Status Summary register(address 10h–13h ,32bit) uint32_t TX_PAUSE_Status_Summary_reg; // TX PAUSE Status Summary register(address 14h–17h ,32bit) uint32_t RX_PAUSE_Status_Summary_reg; // RX PAUSE Status Summary register(address 18h–1Bh ,32bit) uint64_t Port_Speed_Summary_reg; // Port Speed Summary register(address 08h–0Fh ,64bit) uint8_t rsvd[2];&#125;STATREGPKG;//Page 02h Management Mode registerstypedef struct Management_Mode_Registers_Struct_Pkg&#123; uint8_t Global_Manage_Config; // Global Management Configuration (address 00h ,8bit) uint8_t MODEL_ID_reg; // MODEL ID register (address 30h ,8bit) uint8_t Revision_ID_reg; // Revision ID register (address 40h ,8bit) uint16_t Mirror_Capture_Control; // Mirror Capture Control (address 10h–11h ,16bit) uint16_t Ingress_Mirror_Divider; // Ingress Mirror Divider (address 16h–17h ,16bit) uint32_t Aging_Time_Control; // Aging Time Control (address 0Ch–0Fh ,32bit) uint32_t Ingress_Mirror_Control; // Ingress Mirror Control (address 12h–15h ,32bit) uint32_t Egress_Mirror_Control; // Egress Mirror Control (address 1Ch–1Fh ,32bit) uint8_t rsvd[1]; &#125;MMREGPKG;//Page 04h ARL Control registerstypedef struct ARL_Control_Struct_Pkg&#123; uint8_t Global_ARL_Config; // Global ARL Configuration (address 00h ,8bit) uint32_t Multiport_Vector1; // Multiport Vector 1 (address 16h–19h ,32bit) uint32_t Multiport_Vector2; // Multiport Vector 2 (address 26h–29h ,32bit) uint64_t BPDU_Multicast_Address; // BPDU Multicast Address (address 04h–09h ,48bit) uint64_t Multiport_Address1; // Multiport Address 1 (address 10h–15h ,48bit) uint64_t Multiport_Address2; // Multiport Address 2 (address 20h–25h ,48bit) uint8_t rsvd[3]; &#125;ARLCREGPKG;//Page 05h ARL Access registerstypedef struct ARL_Access_Struct_Pkg&#123; uint8_t ARL_RW_Control; // ARL Read/Write Control(address 00h ,8bit) uint8_t ARL_Search_Control; // ARL Search Control(address 30h ,8bit) uint8_t VLAN_RW_Control; // VLAN/TABLE Read/Write Control(address 60h ,8bit) uint16_t VLAN_ID_Index; // VLAN ID Index(address 08h–09h ,12bit) uint16_t ARL_Search_Address; // ARL Search Address(address 31h–32h ,16bit) uint16_t VLAN_TABLE_Address_Index; // VLAN TABLE Address Index(address 61h–62h ,16bit) uint32_t ARL_FWD_Entry0; // ARL FWD Entry 0(address 18h–1Bh ,32bit) uint32_t ARL_FWD_Entry1; // ARL FWD Entry 1(address 28h–2Bh ,32bit) uint32_t ARL_Search_Result0; // ARL Search Result 0(address 3Bh–3Eh ,32bit) uint32_t ARL_Search_Result1; // ARL Search Result 1(address 48h–4Bh ,32bit) uint64_t MAC_Address_Index; // MAC Address Index(address 02h–07h ,48bit) uint64_t ARL_MAC_Entry0; // ARL MAC/VID Entry 0(address 10h–17h ,64bit) uint64_t ARL_MAC_Entry1; // ARL MAC/VID Entry 1(address 20h–27h ,64bit) uint64_t ARL_Search_MAC_Result0; // ARL Search MAC/VID Result 0(address 33h–3Ah ,64bit) uint64_t ARL_Search_MAC_Result1; // ARL Search MAC/VID Result 1(address 40h–47h ,64bit) uint64_t VLAN_TABLE_Entry; // VLAN TABLE Entry(address 63h–6Ah ,64bit) uint8_t rsvd[3]; &#125;ARLAREGPKG;//Page 10h-1Fh Port 0-15 Integrated SerDes registers (10/100/1000 Port 0-15)typedef struct Integrated_SerDes_Struct_Pkg&#123; uint16_t MII_Control_Register; // MII Control Register (address 00h–01h ,16bit) uint16_t MII_Status_Register; // MII Status Register (address 02h–03h ,16bit) uint16_t Auto_Negot_Advert_Reg; // Auto-Negotiation Advertisement Register (address 08h–09 ,16bit) uint16_t Auto_Negot_Link_Partner_Reg; // Auto-Negotiation Link Partner Ability Register (address 0Ah–0Bh ,16bit) uint16_t Auto_Negot_Expansion_Reg; // Auto-Negotiation Expansion Register (address 0Ch–0Dh ,16bit) uint16_t Extended_Status_Reg; // Extended Status Register (address 1Eh–1Fh ,16bit) uint16_t SerDes_Control_Reg1; // SerDes/SGMII Control 1 Register in Block 0;Analog Transmit Register in Block 1(address 20h–21h ,16bit) uint16_t SerDes_Control_Reg2; // SerDes/SGMII Control 2 Register in Block 0 (address 22h–23h ,16bit) uint16_t SerDes_Control_Reg3; // SerDes/SGMII Control 3 Register in Block 0 (address 24h–25h ,16bit) uint16_t SerDes_Status_Reg1; // SerDes/SGMII Status 1 Register (address 28h–29h ,16bit) uint16_t SerDes_Status_Reg2; // SerDes/SGMII Status 2 Register (address 2Ah–2Bh ,16bit) uint16_t SerDes_Status_Reg3; // SerDes/SGMII Status 3 Register (address 2Ch–2Dh ,16bit) uint16_t CRC_Error_Count_Reg; // BER/CRC Error Counter Register (address 2Eh–2Fh ,16bit) uint16_t PRBS_Control_Reg; // PRBS Control Register (address 30h-31h ,16bit) uint16_t PRBS_Status_Reg; // PRBS Status Register (address 32h-33h ,16bit) uint16_t Pattern_Generator_Control_Reg; // Pattern Generator Control Register (address 34h-35h ,16bit) uint16_t Pattern_Generator_Status_Reg; // Pattern Generator Status Register (address 36h-37h ,16bit) uint16_t Force_Transmit_Reg1_0; // Force Transmit 1 Register (address 3Ah-3Bh ,16bit) uint16_t Force_Transmit_Reg1_1; // Force Transmit 1 Register (address 3Ch-3Dh ,16bit) uint16_t Block_Address_Number; // Block Address Number (address 3Eh-3Fh ,16bit)// uint8_t rsvd[1];&#125;ISDREGPKG;//Page 30h QoS registerstypedef struct QoS_Struct_Pkg&#123; uint8_t QoS_Global_Control_Reg; // QoS Global Control Register (address 00h ,8bit) uint8_t QoS_TX_Control_Reg; // QoS TX Control Register(address 80h ,8bit) uint8_t TX_Queue_Weight_Reg0; // TX Queue 0 Weight Register(address 81h ,8bit) uint8_t TX_Queue_Weight_Reg1; // TX Queue 1 Weight Register(address 82h ,8bit) uint8_t TX_Queue_Weight_Reg2; // TX Queue 2 Weight Register(address 83h ,8bit) uint8_t TX_Queue_Weight_Reg3; // TX Queue 3 Weight Register(address 84h ,8bit) uint8_t Priority_Remap_Reg; // Traffic Priority Remap Register(address A4h ,8bit) uint16_t QoS_Threshold_Control_Reg; // QoS Threshold Control Register (address 01h–02h ,16bit) uint16_t QoS_RX_Port_Control_Reg0 ; // QoS RX Port 0 Control Register (address 50h–51h ,16bit) uint16_t QoS_RX_Port_Control_Reg1 ; // QoS RX Port 1 Control Register (address 52h–53h ,16bit) uint16_t QoS_RX_Port_Control_Reg2 ; // QoS RX Port 2 Control Register (address 54h–55h ,16bit) uint16_t QoS_RX_Port_Control_Reg3 ; // QoS RX Port 3 Control Register (address 56h–57h ,16bit) uint16_t QoS_RX_Port_Control_Reg4 ; // QoS RX Port 4 Control Register (address 58h–59h ,16bit) uint16_t QoS_RX_Port_Control_Reg5 ; // QoS RX Port 5 Control Register (address 5Ah–5Bh ,16bit) uint16_t QoS_RX_Port_Control_Reg6 ; // QoS RX Port 6 Control Register (address 5Ch–5Dh ,16bit) uint16_t QoS_RX_Port_Control_Reg7 ; // QoS RX Port 7 Control Register (address 5Eh–5Fh ,16bit) uint16_t QoS_RX_Port_Control_Reg8 ; // QoS RX Port 8 Control Register (address 60h–61h ,16bit) uint16_t QoS_RX_Port_Control_Reg9 ; // QoS RX Port 9 Control Register (address 62h–63h ,16bit) uint16_t QoS_RX_Port_Control_Reg10; // QoS RX Port 10 Control Register (address 64h–65h ,16bit) uint16_t QoS_RX_Port_Control_Reg11; // QoS RX Port 11 Control Register (address 66h–67h ,16bit) uint16_t QoS_RX_Port_Control_Reg12; // QoS RX Port 12 Control Register (address 68h–69h ,16bit) uint16_t QoS_RX_Port_Control_Reg13; // QoS RX Port 13 Control Register (address 6Ah–6Bh ,16bit) uint16_t QoS_RX_Port_Control_Reg14; // QoS RX Port 14 Control Register (address 6Ch–6Dh ,16bit) uint16_t QoS_RX_Port_Control_Reg15; // QoS RX Port 15 Control Register (address 6Eh–6Fh ,16bit) uint16_t QoS_RX_Port_Control_Reg16; // QoS RX Port 16 Control Register (address 70h–71h ,16bit) uint32_t QoS_1P_Enable_Reg; // QoS 1P Enable Register (address 04h–07h ,32bit) uint32_t QoS_DiffServ_Enable_Reg; // QoS DiffServ Enable Register(address 08h–0Bh ,32bit) uint32_t IEEE_Standard_Priority_Map_Reg; //IEEE Standard 802.1P Priority Map Register(address 10h–13h ,32bit) uint32_t Ether_Priority_Control_Reg; // EtherType Priority Control Register(address 88h–8Bh ,32bit) uint32_t En_Priority_Remap_Control_Reg; // Enable Traffic Priority Remap Control Register (address A0h–A3h ,32bit) uint64_t DiffServ_Priority_Map_Reg0 ; // DiffServ Priority Map 0 Register (address 30h–35h ,48bit) uint64_t DiffServ_Priority_Map_Reg1 ; // DiffServ Priority Map 1 Register (address 36h–3Bh ,48bit) uint64_t DiffServ_Priority_Map_Reg2 ; // DiffServ Priority Map 2 Register (address 3Ch–41h ,48bit) uint64_t DiffServ_Priority_Map_Reg3 ; // DiffServ Priority Map 3 Register (address 42h–47h ,48bit) uint8_t rsvd[1]; &#125;QOSREGPKG;//Page 31h VLAN registerstypedef struct VLAN_Struct_Pkg&#123; uint32_t Port_VLAN_Reg0; // Port 0 VLAN Register(address 00h–03h ,32bit) uint32_t Port_VLAN_Reg1; // Port 1 VLAN Register(address 04h–07h ,32bit) uint32_t Port_VLAN_Reg2; // Port 2 VLAN Register(address 08h–0Bh ,32bit) uint32_t Port_VLAN_Reg3; // Port 3 VLAN Register(address 0Ch–0Fh ,32bit) uint32_t Port_VLAN_Reg4; // Port 4 VLAN Register(address 10h–13h ,32bit) uint32_t Port_VLAN_Reg5; // Port 5 VLAN Register(address 14h–17h ,32bit) uint32_t Port_VLAN_Reg6; // Port 6 VLAN Register(address 18h–1Bh ,32bit) uint32_t Port_VLAN_Reg7; // Port 7 VLAN Register(address 1Ch–1Fh ,32bit) uint32_t Port_VLAN_Reg8; // Port 8 VLAN Register(address 20h–23h ,32bit) uint32_t Port_VLAN_Reg9; // Port 9 VLAN Register(address 24h–27h ,32bit) uint32_t Port_VLAN_Reg10; // Port 10 VLAN Register(address 28h–2Bh ,32bit) uint32_t Port_VLAN_Reg11; // Port 11 VLAN Register(address 2Ch–2Fh ,32bit) uint32_t Port_VLAN_Reg12; // Port 12 VLAN Register(address 30h–33h ,32bit) uint32_t Port_VLAN_Reg13; // Port 13 VLAN Register(address 34h–37h ,32bit) uint32_t Port_VLAN_Reg14; // Port 14 VLAN Register(address 38h–3Bh ,32bit) uint32_t Port_VLAN_Reg15; // Port 15 VLAN Register(address 3Ch–3Fh ,32bit) uint32_t Port_VLAN_Reg16; // Port 16 VLAN Register(address 40h–43h ,32bit) // uint8_t rsvd[1];&#125;VLANREGPKG;//Page 32h Trunking registerstypedef struct Trunking_Struct_Pkg&#123; uint8_t MAC_Trunk_Control_Reg; // MAC Trunk Control Register(address 01h ,8bit) uint32_t Trunk_Group0_in_chip0; // Trunk Group 0 in chip0(address 90h–93h ,32bit) uint32_t Trunk_Group1_in_chip0; // Trunk Group 1 in chip0(address 94h–97h ,32bit) uint32_t Trunk_Group2_in_chip0; // Trunk Group 2 in chip0(address 98h–9Bh ,32bit) uint32_t Trunk_Group3_in_chip0; // Trunk Group 3 in chip0(address 9Ch–9Fh ,32bit) uint8_t rsvd[3]; &#125;TRUNKREGPKG;//Page 34h IEEE Standard 802.1Q VLAN registerstypedef struct IEEE_VLAN_Struct_Pkg&#123; uint8_t Global_Control_Reg0; // Global Control 0 Register (address 00h ,8bit) uint8_t Global_Control_Reg1; // Global Control 1 Register (address 01h ,8bit) uint8_t Global_Control_Reg2; // Global Control 2 Register (address 02h ,8bit) uint8_t Global_Control_Reg4; // Global Control 4 Register (address 07h ,8bit) uint8_t Global_Control_Reg5; // Global Control 5 Register (address 08h ,8bit) uint8_t Global_Control_Reg6; // Global Control 6 Register (address 09h ,8bit) uint16_t Default_IEEE_Standard_Tag_Port0; // Default IEEE Standard 802.1Q Tag Port 0(address 10h–11h ,16bit) uint16_t Default_IEEE_Standard_Tag_Port1; // Default IEEE Standard 802.1Q Tag Port 1(address 12h–13h ,16bit) uint16_t Default_IEEE_Standard_Tag_Port2; // Default IEEE Standard 802.1Q Tag Port 2(address 14h–15h ,16bit) uint16_t Default_IEEE_Standard_Tag_Port3; // Default IEEE Standard 802.1Q Tag Port 3(address 16h–17h ,16bit) uint16_t Default_IEEE_Standard_Tag_Port4; // Default IEEE Standard 802.1Q Tag Port 4(address 18h–19h ,16bit) uint16_t Default_IEEE_Standard_Tag_Port5; // Default IEEE Standard 802.1Q Tag Port 5(address 1Ah–1Bh ,16bit) uint16_t Default_IEEE_Standard_Tag_Port6; // Default IEEE Standard 802.1Q Tag Port 6(address 1Ch–1Dh ,16bit) uint16_t Default_IEEE_Standard_Tag_Port7; // Default IEEE Standard 802.1Q Tag Port 7(address 1Eh–1Fh ,16bit) uint16_t Default_IEEE_Standard_Tag_Port8; // Default IEEE Standard 802.1Q Tag Port 8(address 20h–21h ,16bit) uint16_t Default_IEEE_Standard_Tag_Port9; // Default IEEE Standard 802.1Q Tag Port 9(address 22h–23h ,16bit) uint16_t Default_IEEE_Standard_Tag_Port10; // Default IEEE Standard 802.1Q Tag Port 10(address 24h–25h ,16bit) uint16_t Default_IEEE_Standard_Tag_Port11; // Default IEEE Standard 802.1Q Tag Port 11(address 26h–27h ,16bit) uint16_t Default_IEEE_Standard_Tag_Port12; // Default IEEE Standard 802.1Q Tag Port 12(address 28h–29h ,16bit) uint16_t Default_IEEE_Standard_Tag_Port13; // Default IEEE Standard 802.1Q Tag Port 13(address 2Ah–2Bh ,16bit) uint16_t Default_IEEE_Standard_Tag_Port14; // Default IEEE Standard 802.1Q Tag Port 14(address 2Ch–2Dh ,16bit) uint16_t Default_IEEE_Standard_Tag_Port15; // Default IEEE Standard 802.1Q Tag Port 15(address 2Eh–2Fh ,16bit) uint16_t Default_IEEE_Standard_Tag_Port16; // Default IEEE Standard 802.1Q Tag Port 16(address 30h–31h ,16bit) uint32_t Global_Control_Reg3; // Global Control 3 Register (address 03h–06h ,32bit) uint32_t New_riority_Map_Reg; // New Priority Map Register (address 0Ch–0Fh ,32bit)// uint8_t rsvd[1];&#125;IEEEVREGPKG;//Page 40h Jumbo registerstypedef struct Jumbo_Struct_Pkg&#123; uint32_t Jumbo_Frame_Port_Mask_Reg; // Jumbo Frame Port Mask Register (address 01h–04h ,32bit) &#125;JUMBOREGPKG;//Page 41h Broadcast Storm Suppression registerstypedef struct Broadcast_Storm_Suppression_Struct_Pkg&#123; uint16_t Port_Suppressed_Packet_Drop_Count_Reg0; // Port 0 Suppressed Packet Drop Count Register(address 80h–81h ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg1; // Port 1 Suppressed Packet Drop Count Register(address 82h–83h ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg2; // Port 2 Suppressed Packet Drop Count Register(address 84h–85h ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg3; // Port 3 Suppressed Packet Drop Count Register(address 86h–87h ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg4; // Port 4 Suppressed Packet Drop Count Register(address 88h–89h ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg5; // Port 5 Suppressed Packet Drop Count Register(address 8Ah–8Bh ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg6; // Port 6 Suppressed Packet Drop Count Register(address 8Ch–8Dh ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg7; // Port 7 Suppressed Packet Drop Count Register(address 8Eh–8Fh ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg8; // Port 8 Suppressed Packet Drop Count Register(address 90h–91h ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg9; // Port 9 Suppressed Packet Drop Count Register(address 92h–93h ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg10; // Port 10 Suppressed Packet Drop Count Register (address 94h–95h ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg11; // Port 11 Suppressed Packet Drop Count Register (address 96h–97h ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg12; // Port 12 Suppressed Packet Drop Count Register (address 98h–99h ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg13; // Port 13 Suppressed Packet Drop Count Register (address 9Ah–9Bh ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg14; // Port 14 Suppressed Packet Drop Count Register (address 9Ch–9Dh ,16bit) uint16_t Port_Suppressed_Packet_Drop_Count_Reg15; // Port 15 Suppressed Packet Drop Count Register (address 9Eh–9Fh ,16bit) uint32_t Suppression_Control_Reg; // Suppression Control Register(address 0h–03h ,32bit) uint32_t Port_Receive_Rate_Control_Reg0; // Port 0 Receive Rate Control Register (address 10h–13h ,32bit) uint32_t Port_Receive_Rate_Control_Reg1; // Port 1 Receive Rate Control Register (address 14h–17h ,32bit) uint32_t Port_Receive_Rate_Control_Reg2; // Port 2 Receive Rate Control Register (address 18h–1Bh ,32bit) uint32_t Port_Receive_Rate_Control_Reg3; // Port 3 Receive Rate Control Register (address 1Ch–1Fh ,32bit) uint32_t Port_Receive_Rate_Control_Reg4; // Port 4 Receive Rate Control Register (address 20h–23h ,32bit) uint32_t Port_Receive_Rate_Control_Reg5; // Port 5 Receive Rate Control Register (address 24h–27h ,32bit) uint32_t Port_Receive_Rate_Control_Reg6; // Port 6 Receive Rate Control Register (address 28h–2Bh ,32bit) uint32_t Port_Receive_Rate_Control_Reg7; // Port 7 Receive Rate Control Register (address 2Ch–2Fh ,32bit) uint32_t Port_Receive_Rate_Control_Reg8; // Port 8 Receive Rate Control Register (address 30h–33h ,32bit) uint32_t Port_Receive_Rate_Control_Reg9; // Port 9 Receive Rate Control Register (address 34h–37h ,32bit) uint32_t Port_Receive_Rate_Control_Reg10; // Port 10 Receive Rate Control Register(address 38h–3Bh ,32bit) uint32_t Port_Receive_Rate_Control_Reg11; // Port 11 Receive Rate Control Register(address 3Ch–3Fh ,32bit) uint32_t Port_Receive_Rate_Control_Reg12; // Port 12 Receive Rate Control Register(address 40h–43h ,32bit) uint32_t Port_Receive_Rate_Control_Reg13; // Port 13 Receive Rate Control Register(address 44h–47h ,32bit) uint32_t Port_Receive_Rate_Control_Reg14; // Port 14 Receive Rate Control Register(address 48h–4Bh ,32bit) uint32_t Port_Receive_Rate_Control_Reg15; // Port 15 Receive Rate Control Register(address 4Ch–4Fh ,32bit) // uint8_t rsvd[1];&#125;BSSREGPKG;//Page 43h IEEE Standard 802.1s Multiple Spanning Tree registerstypedef struct IEEE_Multiple_Spanning_Tree_Struct_Pkg&#123; uint8_t MSPT_Control_Reg; // MSPT (Multiple Spanning Trees) Control Register(address 0h ,8bit) uint64_t MST_Table_Reg0; // MST 0 Table Register(address 10h–15h ,48bit) uint64_t MST_Table_Reg1; // MST 0 Table Register(address 16h–1Bh ,48bit) uint64_t MST_Table_Reg2; // MST 0 Table Register(address 1Ch–21h ,48bit) uint64_t MST_Table_Reg3; // MST 0 Table Register(address 22h–27h ,48bit) uint64_t MST_Table_Reg4; // MST 0 Table Register(address 28h–2Dh ,48bit) uint64_t MST_Table_Reg5; // MST 0 Table Register(address 2Eh–33h ,48bit) uint64_t MST_Table_Reg6; // MST 0 Table Register(address 34h–39h ,48bit) uint64_t MST_Table_Reg7; // MST 0 Table Register(address 3Ah–3Fh ,48bit) uint64_t MST_Table_Reg8; // MST 0 Table Register(address 40h–45h ,48bit) uint64_t MST_Table_Reg9; // MST 0 Table Register(address 46h–4Bh ,48bit) uint64_t MST_Table_Reg10; // MST 0 Table Register(address 4Ch–51h ,48bit) uint64_t MST_Table_Reg11; // MST 0 Table Register(address 52h–57h ,48bit) uint64_t MST_Table_Reg12; // MST 0 Table Register(address 58h–5Dh ,48bit) uint64_t MST_Table_Reg13; // MST 0 Table Register(address 5Eh–63h ,48bit) uint64_t MST_Table_Reg14; // MST 0 Table Register(address 64h–69h ,48bit) uint64_t MST_Table_Reg15; // MST 0 Table Register(address 6Ah–6Fh ,48bit) uint64_t MST_Table_Reg16; // MST 0 Table Register(address 70h–75h ,48bit) uint64_t MST_Table_Reg17; // MST 0 Table Register(address 76h–7Bh ,48bit) uint64_t MST_Table_Reg18; // MST 0 Table Register(address 7Ch–81h ,48bit) uint64_t MST_Table_Reg19; // MST 0 Table Register(address 82h–87h ,48bit) uint64_t MST_Table_Reg20; // MST 0 Table Register(address 88h–8Dh ,48bit) uint64_t MST_Table_Reg21; // MST 0 Table Register(address 8Eh–93h ,48bit) uint64_t MST_Table_Reg22; // MST 0 Table Register(address 94h–99h ,48bit) uint64_t MST_Table_Reg23; // MST 0 Table Register(address 9Ah–9Fh ,48bit) uint64_t MST_Table_Reg24; // MST 0 Table Register(address A0h–A5h ,48bit) uint64_t MST_Table_Reg25; // MST 0 Table Register(address A6h–ABh ,48bit) uint64_t MST_Table_Reg26; // MST 0 Table Register(address ACh–B1h ,48bit) uint64_t MST_Table_Reg27; // MST 0 Table Register(address B2h–B7h ,48bit) uint64_t MST_Table_Reg28; // MST 0 Table Register(address B8h–BDh ,48bit) uint64_t MST_Table_Reg29; // MST 0 Table Register(address BEh–C3h ,48bit) uint64_t MST_Table_Reg30; // MST 0 Table Register(address C4h–C9h ,48bit) uint64_t MST_Table_Reg31; // MST 0 Table Register(address CAh–CFh ,48bit) uint8_t rsvd[3];&#125;IEEEMREGPKG;//Page 80h–87h, External PHY Registers (Serial Ports) typedef struct External_PHY_Registers_Struct_Pkg&#123; uint16_t MII_Control_Register; // MII Control Register(address 00h–01h ,16bit) uint16_t MII_Status_Register; //MII Status Register(address 02h–03h ,16bit) uint16_t Auto_negotiation_Advertisement_Register; //Auto-negotiation Advertisement Register(address 08h–09h ,16bit) uint16_t Auto_negotiation_Link_Partner_Ability_Register; //Auto-negotiation Link Partner Ability Register(address 0Ah–0Bh ,16bit) uint16_t Auto_negotiation_Expansion_Register; //Auto-negotiation Expansion Register(address 0Ch–0Dh ,16bit) uint16_t Next_Page_Transmit_Register; //Next Page Transmit Register(address 0Eh–0Fh ,16bit) uint16_t Link_Partner_Received_Next_Page_Register; //Link Partner Received Next Page Register(address 10h–11h ,16bit) uint16_t BASE1000_T_Control_Register; //1000BASE-T Control Register(address 12h–13h ,16bit) uint16_t BASE1000_T_Status_Register; //1000BASE-T Status Register(address 14h–15h ,16bit) uint16_t IEEE_Extended_Status_Register; //IEEE Extended Status Register(address 1Eh–1Fh ,16bit) uint32_t PHY_Identifier_Register; //PHY Identifier Register(address 04h–07h ,32bit) // uint8_t rsvd[3];&#125;EXTERPHYREGPKG;extern GLOBALREGPKG globalregPKG;extern int GlobalBit_init(void);extern int bcm5396_init(void);extern int bcm5396_read(int page, int addr, void* pbuf ,int len);extern int bcm5396_write(int page, int addr, void* pbuf ,int len);extern int bcm5396_config(int port, int mode, int swmode, int speed);extern void showBCM5396Regs(void);extern int GlobalBit_init(void);//page 00hextern int ControlBit_init(void);extern int BCM5396_ControlReg1(void); //8bit-Regextern int BCM5396_ControlReg2(void); //16bit-Regextern int BCM5396_ControlReg3(void); //32bit-Reg//page 01hextern int StatusBit_init(void);extern int BCM5396_StatusReg1(void); //8bit-Regextern int BCM5396_StatusReg2(void); //16bit-Regextern int BCM5396_StatusReg3(void); //32bit-Regextern int BCM5396_StatusReg4(void); //64bit-Reg//page 02hextern int ManageBit_init(void);extern int BCM5396_ManageReg1(void); //8bit-Regextern int BCM5396_ManageReg2(void); //16bit-Regextern int BCM5396_ManageReg3(void); //32bit-Reg//page 04hextern int ARLCBit_init(void);extern int BCM5396_ARLControlReg1(void); //8bit-Regextern int BCM5396_ARLControlReg3(void); //32bit-Regextern int BCM5396_ARLControlReg4(void); //64bit-Reg//page 05hextern int ARLABit_init(void);extern int BCM5396_ARLAccessReg1(void); //8bit-Regextern int BCM5396_ARLAccessReg2(void); //16bit-Regextern int BCM5396_ARLAccessReg3(void); //32bit-Regextern int BCM5396_ARLAccessReg4(void); //64bit-Reg//page 10hextern int IsdregBit_init_0(void);extern int BCM5396_ISDReg2_0(int index); //16bit-Reg//page 30hextern int QOSBit_init(void);extern int BCM5396_QOSReg1(void); //8bit-Regextern int BCM5396_QOSReg2(void); //16bit-Regextern int BCM5396_QOSReg3(void); //32bit-Regextern int BCM5396_QOSReg4(void); //64bit-Reg//page 31hextern int VLANBit_init(void);extern int BCM5396_VLANReg3(void); //32bit-Reg//page 32hextern int TrunkBit_init(void);extern int BCM5396_TrunkReg1(void); //8bit-Regextern int BCM5396_TrunkReg3(void); //32bit-Regg//page 34hextern int IEEEVBit_init(void);extern int BCM5396_IEEEVLANReg1(void); //8bit-Regextern int BCM5396_IEEEVLANReg2(void); //16bit-Regextern int BCM5396_IEEEVLANReg3(void); //32bit-Reg//page 40hextern int JumboBit_init(void);extern int BCM5396_JumboReg3(void); //32bit-Reg//page 41hextern int BSSBit_init(void);extern int BCM5396_BSSReg2(void); //16bit-Regextern int BCM5396_BSSReg3(void); //32bit-Reg//page 43hextern int IEEEMBit_init(void);extern int BCM5396_IEEEMReg1(void); //8bit-Regextern int BCM5396_IEEEMReg4(void); //64bit-Reg//page 80hextern int EXTERPHYBit_init_0(void);extern int BCM5396_EXTERPHYReg2_0(int index); //16bit-Regextern int BCM5396_EXTERPHYReg3_0(int index); //32bit-Regextern int bcm5396_reset(void);extern int bcm5396_release(void);extern uint32_t spi_oprate(uint8_t data0, uint8_t data1, uint8_t data2, void* pbuf, int len);#endif //__BCM5396_H__/******************* END OF FILE *********/ user_spi.c 12345678910111213141516171819202122232425262728293031323334353637//user_spi.c#include &quot;user_spi.h&quot;int spi_mass_low ( void )&#123; // return 0;&#125;int spi_mass_high ( void )&#123; // return 0;&#125;int spi_masck_low ( void )&#123; // return 0;&#125;int spi_masck_high ( void )&#123; // return 0;&#125;uint8_t spi_writeread ( uint8_t data,uint8_t mode)&#123; return 0;&#125;/******************* END OF FILE *********/ user_spi.h 1234567891011121314151617181920//user_spi.h#ifndef __USER_SPI_H#define __USER_SPI_H#include &quot;sys.h&quot;#define CPLD2_SPI_BCM_REG (1) //访问BCM5396寄存器extern void spi_init(void);extern int spi_mass_low ( void );extern int spi_mass_high ( void );extern int spi_masck_low ( void );extern int spi_masck_high ( void );extern uint8_t spi_writeread ( uint8_t data,uint8_t mode);#endif /* __USER_SPI_H *//******************* END OF FILE *********/ main.c 1234567891011121314151617181920212223242526272829//main.c#include &quot;delay.h&quot;#include &quot;bcm5396.h&quot;int main(void) &#123; int rc = 0; delay_init(168); //初始化延时函数 bcm5396_reset(); //------------------------------------- delay_us(3000); bcm5396_release(); delay_us(1000); rc = bcm5396_init(); while(1) &#123; showBCM5396Regs(); &#125;&#125;/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈","categories":[{"name":"MCU 应用练习","slug":"MCU-应用练习","permalink":"https://sirius-blog.github.io/categories/MCU-%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"库函数应用练习","slug":"库函数应用练习","permalink":"https://sirius-blog.github.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1应用练习(1) 驱动LTC2990器件","slug":"study-ic-arm/practices-mcu/stm32f1/001 STM32F1应用练习(1) 驱动LTC2990器件","date":"2022-12-06T18:29:18.000Z","updated":"2023-06-10T23:13:12.576Z","comments":true,"path":"posts/3481076887.html","link":"","permalink":"https://sirius-blog.github.io/posts/3481076887.html","excerpt":"","text":"说明：应用代码段已经验证，本文章旨在移植及适配 STM32F1。 器件 主芯片：ST STM32F103 。 驱动器件：LTC2990 。 目的 驱动IIC接口器件LTC2990。 电路 硬件连接关系： 点我查看图纸细节 FPGA管脚分配： 信号 方向 管脚 说明 TMP_I2C_SCL output PB5 IIC接口时钟端 TMP_I2C_SDA inout PB6 IIC接口数据端 思路 使用模拟IIC接口对LTC2990器件进行访问。 驱动 ltc2990.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195// ltc2990.c#include &quot;ltc2990.h&quot;#include &quot;user_iic.h&quot;MONITOR_DATA ltcMonData;CM_ADC_DATA ltc_adc[LTC_LEN];LTC2990CPKG ltcpkg[4] = &#123; &#123;LTC0_BASE_ADDR, CONTROL_REG_MODE_TR1_TR2, 0, 2&#125;, &#123;LTC1_BASE_ADDR, CONTROL_REG_MODE_V1V2V3V4, 0, 4&#125;, &#123;LTC2_BASE_ADDR, CONTROL_REG_MODE_V1DV2_V3V4, 0, 3&#125;, &#123;LTC3_BASE_ADDR, CONTROL_REG_MODE_V1V2V3V4, 0, 4&#125;&#125;;int LtcInit()&#123; memset(&amp;ltcMonData, 0, sizeof(MONITOR_DATA)); memset(&amp;ltc_adc[0], 0, sizeof(ltc_adc)); return 0;&#125;//平滑处理int smoothAdcData(void* padcpcb, int datain) &#123; int i; CM_ADC_DATA* padc = (CM_ADC_DATA*)(padcpcb); if(padc-&gt;cntSp == 0) padc-&gt;sum = 0; //首次清零累加值 i = padc-&gt;cntSp &amp; 0xF; //限定索引在16个单元 if(padc-&gt;cntSp &gt;= 16) padc-&gt;sum -= padc-&gt;tv[i]; //累加数量达到16后，先去除旧数 padc-&gt;tv[i] = datain; //新数存入旧数所在单元 padc-&gt;sum += padc-&gt;tv[i]; //累加新数到累加值 padc-&gt;cntSp++; //计数增加 if(padc-&gt;cntSp &gt;= 16) padc-&gt;volt = padc-&gt;sum &gt;&gt; 4; //解滑动滤波输出值 else padc-&gt;volt = padc-&gt;tv[i]; //数目不足，使用最新数据做滤波输出 return i;&#125;//获取通道数据int getLtcChData(int port, int chno)&#123; int data = 0; if((port &lt; 0) || (port &gt; 4)) return -1; if((chno &lt; 0) || (chno &gt; 4)) return -1; iicLtcWrite(ltcpkg[port].baseaddr, TRIGGE_REG_ADDR, 0x00); //写入任何值都会触发转换 iicLtcWrite(ltcpkg[port].baseaddr, CONTROL_REG_ADDR, ltcpkg[port].mode); //选通工作模式 data = (iicLtcRead(ltcpkg[port].baseaddr, LTC_VMSB(chno)) &amp; 0x7F) &lt;&lt; 8; data += iicLtcRead(ltcpkg[port].baseaddr, LTC_VLSB(chno)) &amp; 0xFF; return data;&#125;//获取差分测点温度值，公式计算int getTempfromTR(int regdata)&#123;//convert to 0.1°：((* 625 / 10000) - 273.15)*10 (0.1°) int data = regdata; if(data &amp; LTC_HIGH_TEMP_DATA_MASK) return -2732; data *= 640; //0.625*1024 data -= 2797056 ; //2731.5*1024 return (data &gt;&gt; 10);&#125;//获取单端测点电压值，公式计算int getVoltfromSigend(int regdata)&#123;//convert to 0.1mV int data; if((regdata &amp; LTC_SIGNAL_DATA_MASK) == LTC_SIGNAL_DATA_MASK) &#123; data = regdata - 0x10000; &#125; else &#123; data = regdata; &#125; data *= 50000;// * 30518 / 100 /100 (0.1mV); return (data &gt;&gt; 14);&#125;//获取差分测点电压值，公式计算int getVoltfromDifend(int regdata)&#123;//convert to 0.1mV int data; if((regdata &amp; LTC_SIGNAL_DATA_MASK) == LTC_SIGNAL_DATA_MASK) &#123; data = regdata - 0x10000; &#125; else &#123; data = regdata; &#125; data *= 3182;// * 1942 / 100 /100 (0.1mV); return (data &gt;&gt; 14);&#125;//获取差分测点电流值，公式计算int getIfromDifend(int regdata)&#123;//convert to 0.1mA int data; if((regdata &amp; LTC_SIGNAL_DATA_MASK) == LTC_SIGNAL_DATA_MASK) &#123; data = regdata - 0x10000; &#125; else &#123; data = regdata; &#125;// data *= 362;// * 19.42uV * 10 / (8.25/(8.25+30.2)*2.5mO) (0.1mA); data *= I_K_FACTOR;// (0.1mA); data += I_B_FACTOR; return (data);&#125;//LTM电源器件电压转温度，公式计算int LtmAdcVtoTemp(uint16_t Voltage)&#123;//(1200-Volt)/2.2 - 273.15 : ((5454.5 -2731.5)*256 -Volt * 1164) &gt;&gt; 8#if 1 int sum = Voltage * 116; sum = 697088 - sum; return (int)(sum &gt;&gt; 8);#else return (int)(Voltage);#endif&#125;//LTC2990器件ADC采集int sampleLtcAdc(int phase)&#123; int i = 0; int voltData; if((phase &gt; LTC_LEN) || (phase &lt; 0)) return -1; if(phase &lt; 2) &#123;//LtcPort0 i = phase; voltData = getLtcChData(LTC_Port(0), i &lt;&lt; 1); //触发并读取数据 voltData = getTempfromTR(voltData); //to 0.1° smoothAdcData(&amp;ltc_adc[phase], voltData); //平滑处理 &#125; else if(phase &lt; 6) &#123;//LtcPort1 i = phase - 2; voltData = getLtcChData(LTC_Port(1), i); //触发并读取数据 voltData = getVoltfromSigend(voltData); //to 0.1mV smoothAdcData(&amp;ltc_adc[phase], voltData); //平滑处理 &#125; else if(phase &lt; 8) &#123;//LtcPort2 &#123; i = phase - 4; voltData = getLtcChData(LTC_Port(2), i); //触发并读取数据 voltData = getVoltfromSigend(voltData); //to 0.1mV &#125; smoothAdcData(&amp;ltc_adc[phase], voltData); //平滑处理 &#125; else if(phase &lt; LTC_LEN) &#123;//LtcPort3 i = phase - 8; voltData = getLtcChData(LTC_Port(3), i); //触发并读取数据 voltData = getVoltfromSigend(voltData); //to 0.1mV smoothAdcData(&amp;ltc_adc[phase], voltData); //平滑处理 &#125; return i;&#125; //LTC2990器件ADC数据汇总int updateLtcAdcData(void)&#123; //LtcPort0 ltcMonData.ltcd.F1temp = ltc_adc[0].volt; //单位0.1° ltcMonData.ltcd.F2temp = ltc_adc[1].volt; //单位0.1° //LtcPort1 ltcMonData.ltcd.FPGA_MGTAVTT_AD = ltc_adc[2].volt /10; //单位1mV ltcMonData.ltcd.FPGA_1V5_AD = ltc_adc[3].volt /10; //单位1mV ltcMonData.ltcd.VCCtemp = LtmAdcVtoTemp(ltc_adc[4].volt); //单位0.1° ltcMonData.ltcd.DSPtemp = LtmAdcVtoTemp(ltc_adc[5].volt); //单位0.1° //LtcPort2 ltcMonData.ltcd.SWITCH_1V2 = ltc_adc[6].volt/10; //单位1mV ltcMonData.ltcd.FPGA2_DVREF_0V75 = ltc_adc[7].volt/10; //单位1mV //LtcPort3 ltcMonData.ltcd.DSP1_CVDD_AD = (ltc_adc[8].volt)/10; //单位1mV ltcMonData.ltcd.MMC_EPHY_2V5 = (ltc_adc[9].volt)/10; //单位1mV ltcMonData.ltcd.VCCINT_FPGA2_1V0 = (ltc_adc[10].volt)/10; //单位1mV ltcMonData.ltcd.DSP_1V5_AD = (ltc_adc[11].volt)/10; //单位1mV return 0;&#125;/******************* END OF FILE *********/ ltc2990.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// ltc2990.h#ifndef __LTC2990_H#define __LTC2990_H#include &quot;sys.h&quot;#include &quot;string.h&quot; typedef struct Chip_ADC_Module_Voltage_Sample_strcuct&#123; uint32_t cntSp; int sum; int volt; int dv; int tv[16];&#125;CM_ADC_DATA;typedef struct ltc_2990_sample_control_data_packdge&#123; uint8_t baseaddr; uint8_t mode; uint8_t func; uint8_t chnum;&#125;LTC2990CPKG;//监控数据结构体//定义寄存器地址//四个LTC2990#define LTC_Port(x) (x)#define LTC_VMSB(x) ((x&lt;&lt;1)+0x06)#define LTC_VLSB(x) ((x&lt;&lt;1)+0x07)#define LTC0_BASE_ADDR (0x98) //ADR1=0;ADR0=0;#define LTC1_BASE_ADDR (0x9a) //ADR1=0;ADR0=1;#define LTC2_BASE_ADDR (0x9c) //ADR1=1;ADR0=0;#define LTC3_BASE_ADDR (0x9e) //ADR1=1;ADR0=1;#define STATUS_REG_ADDR (0x00)#define CONTROL_REG_ADDR (0x01)#define TRIGGE_REG_ADDR (0x02)#define TINTMSB_DATA_REG_ADDR (0x04)#define TINTLSB_DATA_REG_ADDR (0x05)#define V1MSB_DATA_REG_ADDR (0x06)#define V1LSB_DATA_REG_ADDR (0x07)#define V2MSB_DATA_REG_ADDR (0x08)#define V2LSB_DATA_REG_ADDR (0x09)#define V3MSB_DATA_REG_ADDR (0x0a)#define V3LSB_DATA_REG_ADDR (0x0b)#define V4MSB_DATA_REG_ADDR (0x0c)#define V4LSB_DATA_REG_ADDR (0x0d)#define VCCMSB_DATA_REG_ADDR (0x0e)#define VCCLSB_DATA_REG_ADDR (0x0f)typedef struct LTC_MONITOR_DATA_STRUCT&#123; //LTC0 int16_t F1temp; int16_t F2temp; //LTC1 uint16_t FPGA_MGTAVTT_AD; uint16_t FPGA_1V5_AD; int16_t VCCtemp; int16_t DSPtemp; //LTC2 uint16_t SWITCH_1V2; uint16_t FPGA2_DVREF_0V75; //LTC3 uint16_t DSP1_CVDD_AD; uint16_t MMC_EPHY_2V5; uint16_t VCCINT_FPGA2_1V0; uint16_t DSP_1V5_AD;&#125;LTC_DATA_st;//监控数据结构体#define LTC_LEN (sizeof(LTC_DATA_st) &gt;&gt; 1)typedef union ltc_union_data_block&#123; LTC_DATA_st ltcd; uint16_t reg[LTC_LEN];&#125;MONITOR_DATA;//定义控制寄存器工作模式数据#define CONTROL_REG_MODE_V1V2_T (0x98)//V1，V2,TR3模式#define CONTROL_REG_MODE_V1DV2_T (0x99)//V1_V2,TR3模式#define CONTROL_REG_MODE_V1DV2_V3V4 (0x1a)//V1_V2,V3V4模式#define CONTROL_REG_MODE_TR1_V3V4 (0x9b)//TR1,V3V4模式#define CONTROL_REG_MODE_TR1_V3DV4 (0x9c)//TR1,V3_V4模式#define CONTROL_REG_MODE_TR1_TR2 (0x9d)//TR1,TR2模式#define CONTROL_REG_MODE_V1DV2_V3DV4 (0x1e)//V1_V2——V3_V4模式#define CONTROL_REG_MODE_V1V2V3V4 (0x1f)//V1,V2,V3,V4模式#define I_K_FACTOR (247)#define I_B_FACTOR (-406260)#define LTC_VCC_DATA_MASK (0x7fff)#define LTC_SIGNAL_DATA_MASK (0x4000)#define LTC_HIGH_TEMP_DATA_MASK (0x2000)#define LTC_TEMP_DATA_MASK (0x1fff)#define LTC_TEMP_SIGNAL_DATA_MASK (0x1000)#define LTC_DATA_VALID_MASK (0x8000)extern CM_ADC_DATA ltc_adc[LTC_LEN];extern MONITOR_DATA ltcMonData;extern int LtcInit(void);extern int sampleLtcAdc(int phase);extern int updateLtcAdcData(void);#endif /* __LTC2990_H *//******************* END OF FILE *********/ user_iic.c 12345678910111213141516171819//user_iic.c#include &quot;user_iic.h&quot;int iicLtcWrite(uint8_t Dcvaddr, uint8_t Regaddr, uint8_t Regdata)&#123; //IIC_Write1Byte(Dcvaddr| IIC_WRITE, Regaddr, Regdata); return 0;&#125;int iicLtcRead(uint8_t Dcvaddr, uint8_t Regaddr)&#123; uint8_t readdata = 0; //readdata = IIC_Read1Byte(Dcvaddr | IIC_WRITE, Regaddr, Dcvaddr | IIC_READ, 0); return readdata;&#125;/******************* END OF FILE *********/ user_iic.h 12345678910111213141516171819//user_iic.h#ifndef __USER_IIC_H#define __USER_IIC_H#include &quot;sys.h&quot;#define BASE_PORT (0)#define IIC_WRITE (0 &lt;&lt; 0)#define IIC_READ (1 &lt;&lt; 0)extern int iicLtcWrite(uint8_t Dcvaddr, uint8_t Regaddr, uint8_t data);extern int iicLtcRead(uint8_t Dcvaddr, uint8_t Regaddr);#endif /* __USER_IIC_H *//******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728//main.c#include &quot;ltc2990.h&quot; int main(void) &#123; uint32_t clockCnt; int clockPhase = clockCnt &amp; 0x7F; //MAX：0x7F = ‘d127 delay_init(); //延时函数初始化 while(1) &#123; clockCnt++; #ifndef MONITOR_LTC if((clockPhase &gt;= 1) &amp;&amp; (clockPhase &lt; 14)) &#123;//通过变量 clockPhase 计数的节奏执行，具体应用自行变通。 sampleLtcAdc(clockPhase - 1); &#125; if(clockPhase == 14) &#123; updateLtcAdcData(); &#125; #endif &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈","categories":[{"name":"MCU 应用练习","slug":"MCU-应用练习","permalink":"https://sirius-blog.github.io/categories/MCU-%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"库函数应用练习","slug":"库函数应用练习","permalink":"https://sirius-blog.github.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"ARM笔记(3) 记录88E1111的寄存器配置","slug":"study-ic-arm/notes-mcu/003 ARM笔记(3) 记录88E1111的寄存器配置","date":"2022-10-29T00:29:18.000Z","updated":"2023-06-20T15:33:22.206Z","comments":true,"path":"posts/375725893.html","link":"","permalink":"https://sirius-blog.github.io/posts/375725893.html","excerpt":"","text":"本章节旨在记录“88E1111的寄存器配置”的分析。 配置原则 PHY的寄存器中每1bit都表示不同含义，非必要改动的地方采用默认配置，故下列配置“按先读后写，精准调节”的原则进行逐位赋值。 配置流程 R27 清除bit[3:0]; 置bit[3:0]=0xe;即表示GMII到SGMII. 置bit[15]=0x1;即表示禁用Fiber和Copper的选择. R0 置bit[15]=0x1;即表示写复位，写入的寄存器值生效. R0 置bit[12]=0x1;即表示使能自协商. 置bit[18]=0x1;即表示选择全双工模式. R20 置bit[6:4]=0x5;即表示MAC百兆速率. R16 置bit[6:5]=0x3;即表示MDI交叉模式，以及自动分频. R27 置bit[15]=0x1;即表示禁用Fiber和Copper的自动选择. R0 置bit[12]=0x1;即表示使能自协商. 置bit[15]=0x1;即表示写复位，写入的寄存器值生效. 异常现象 PHY的SGMII链路网络异常，无法ping通IP地址。 不同状态下PHY的SGMII寄存器读取对比 序号 寄存器名 异常状态（不通） 正常状态（能通） 1 R0 0x1140 0x1140 2 R1 0x0169 0x0169 3 R15 0xC000 0xc000 4 R16 0x0078 0x0078 5 R17 0x08E0 0x7C10 6 R20 0x0C40 0x0C40 7 R27 0x848E 0x848E","categories":[{"name":"ARM 应用场景故障分析","slug":"ARM-应用场景故障分析","permalink":"https://sirius-blog.github.io/categories/ARM-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"}],"tags":[{"name":"国产","slug":"国产","permalink":"https://sirius-blog.github.io/tags/%E5%9B%BD%E4%BA%A7/"},{"name":"ARM","slug":"ARM","permalink":"https://sirius-blog.github.io/tags/ARM/"},{"name":"应用故障分析","slug":"应用故障分析","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"},{"name":"PHY","slug":"PHY","permalink":"https://sirius-blog.github.io/tags/PHY/"}]},{"title":"FPGA笔记(3) Vivado固化FPGA外挂bpi-Flash步骤","slug":"study-ic-fpga/notes-fpga/003 FPGA笔记(3) Vivado固化FPGA外挂bpi-Flash步骤","date":"2022-10-29T00:29:18.000Z","updated":"2023-06-15T14:34:46.557Z","comments":true,"path":"posts/1704327597.html","link":"","permalink":"https://sirius-blog.github.io/posts/1704327597.html","excerpt":"","text":"本章节旨在记录“Vivado固化FPGA外挂bpi-Flash(型号S29GL256P)”基本步骤。 准备工作 本章节是，使用Vivado(以Vivado 2018.3为例)固化.MCS文件到FPFGA外挂BPI接口存储器件过程，在操作前应准备好要固化的MCS格式文件及与FPGA对应关系，以及明确要固化的目标器件型号，如FPGA型号、连接方式、外挂Flash型号、位宽等等。开始以下内容即表示已完成准备工作。 打开Vivado工具 先将设备加电后，接上仿真器，双击Vivado图标，点击Open Hardware Manager以打开固化工具。 点我查看图标样式 点我查看图标样式 扫链连接器件 点击“Auto Connect”连接板子。 点我查看图标样式 添加配置存储器件 在Hardware面板中右击FPGA器件（xc7vx690t_0），选择“Add Configuration Memery Device”。 点我查看图标样式 在弹出的添加配置存储器的界面中，找到板载的Flash存储器型号，点击OK，完成添加,Flash型号如下图所示。 点我查看图标样式 添加完成后，Vivado会提示添加完成，是否立即配置存储器。点击OK，进入配置存储器的界面，选择生成的Mcs文件，然后点击OK，开始将mcs文件烧写到外部配置flash存储器中。 点我查看图标样式","categories":[{"name":"FPGA 开发环境应用笔记","slug":"FPGA-开发环境应用笔记","permalink":"https://sirius-blog.github.io/categories/FPGA-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"Xilinx开发环境应用笔记","slug":"Xilinx开发环境应用笔记","permalink":"https://sirius-blog.github.io/tags/Xilinx%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"name":"Vivado","slug":"Vivado","permalink":"https://sirius-blog.github.io/tags/Vivado/"}]},{"title":"FPGA笔记(2) ISE14.7固化FPGA外挂bpi-Flash步骤","slug":"study-ic-fpga/notes-fpga/002 FPGA笔记(2) ISE14.7固化FPGA外挂bpi-Flash步骤","date":"2022-10-28T23:29:18.000Z","updated":"2023-06-15T14:08:20.924Z","comments":true,"path":"posts/3111608661.html","link":"","permalink":"https://sirius-blog.github.io/posts/3111608661.html","excerpt":"","text":"本章节旨在记录“ISE14.7固化FPGA外挂bpi-Flash(型号S29GL256P)”基本步骤。 准备工作 本章节是，使用ISE固化.MCS文件到FPFGA外挂BPI接口存储器件过程，在操作前应准备好要固化的MCS格式文件及与FPGA对应关系，以及明确要固化的目标器件型号，如FPGA型号、连接方式、外挂Flash型号、位宽等等。开始以下内容即表示已完成准备工作。 打开固化工具 先将设备加电后，接上仿真器，双击iMPACT，以打开固化工具。 点我查看图标样式 打开扫链界面 在工具界面，双击Boundary Scan识别。 点我查看图标样式 开始扫链 右击图中蓝色字体区域，在出现的选项中选择initial Chain。 点我查看图标样式 选择目标器件并加载对应固化文件 扫链完成后，会出现一些弹窗，单击No，在随后出现的界面中点击Cancel 。 点我查看图标样式 点我查看图标样式 右击芯片，选择Add SPI/BPI Flash，选择mcs文件。 点我查看图标样式 根据mcs文件输出的存放地址，选择mcs文件，选择Flash芯片，型号为（根据开发板型号自己选择），点击OK。 点我查看图标样式 开始固化操作 右击Flash，选择program。 点我查看图标样式 出现属性弹窗界面，单击OK 点我查看图标样式 出现如下界面，耐心等待，完成固化。 点我查看图标样式","categories":[{"name":"FPGA 开发环境应用笔记","slug":"FPGA-开发环境应用笔记","permalink":"https://sirius-blog.github.io/categories/FPGA-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"ISE 14.7","slug":"ISE-14-7","permalink":"https://sirius-blog.github.io/tags/ISE-14-7/"},{"name":"Xilinx开发环境应用笔记","slug":"Xilinx开发环境应用笔记","permalink":"https://sirius-blog.github.io/tags/Xilinx%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}]},{"title":"ARM笔记(1) MCU访问外围设备SM2990数据异常","slug":"study-ic-arm/notes-mcu/001 ARM笔记(1) MCU访问SM2990器件数据异常","date":"2022-10-27T18:29:18.000Z","updated":"2023-06-20T14:13:39.469Z","comments":true,"path":"posts/4263387656.html","link":"","permalink":"https://sirius-blog.github.io/posts/4263387656.html","excerpt":"","text":"本章节旨在记录“MCU访问外围设备SM2990数据异常”现象及排查（分析）故障器件SM2990的思路。 异常现象 相同驱动环境，芯片不同，现象表现有差别； 使用原工程驱动（同一位置对比） SM2990：读取的数据不对； 点我查看细节 LTC2990：读取的数据正常； 点我查看细节 现象分析：相同位置相同驱动程序，同型号不同厂商器件的数据读取有差异，不正常。 思路 异常可能性： 1.可能是该外设器件问题； 2.可能器件技术差异，配置应有区别； 附-器件应用环境原理图： 位号U83器件： 点我查看细节 硬件实物： 点我查看细节 焊接实况及驱动状况简述： 序号 位号 焊接器件 数据读取状况 1 U79 - - 2 U80 LTC2990 数据正常 3 U82 LTC2990 数据正常 4 U83 SM2990 数据读取与实际测量（万用表测量引脚）差别大 注：四片器件的I2C接口、供电等硬件均一致，固件驱动一致。 分析验证 检查数据异常时的外部实际测量状态 外部硬件测量正常； 使用SM2990厂商建议流程驱动（使用单次采集，增加Vcc数值读取） 厂商建议顺序： 1.先读取数据寄存器，然后再读取状态寄存器，确认状态寄存器是否都清零了。 2.配置设置寄存器为5F 3.向02寄存器中写入数据启动转换 4.延时一段时间比如500ms，这个仅用来调试，可以时间长点。 5，读取状态寄存器，确认转换已经完成。 6.再读取数据寄存器 SM2990读取的数据不对（同板卡上LTC2990器件使用相同驱动流程） 点我查看细节 加长建议顺序中的“500ms”延时无改善 点我查看细节 控制寄存器的读入读出对比，确认控制寄存器写入了（打断点查看的结果一致），数据依旧不对 点我查看细节 使用其它项目的相关驱动框架访问（只适配了器件地址等信息，无关键改动） SM2990器件的数据访问结果依旧不对 点我查看细节 有效解决方案 更换新器件，原器件返厂分析原因。 附件 暂无","categories":[{"name":"ARM 应用场景故障分析","slug":"ARM-应用场景故障分析","permalink":"https://sirius-blog.github.io/categories/ARM-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"}],"tags":[{"name":"国产","slug":"国产","permalink":"https://sirius-blog.github.io/tags/%E5%9B%BD%E4%BA%A7/"},{"name":"ARM","slug":"ARM","permalink":"https://sirius-blog.github.io/tags/ARM/"},{"name":"应用故障分析","slug":"应用故障分析","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"}]},{"title":"ARM笔记(2) 关于GD32的应用环境准备工作说明","slug":"study-ic-arm/notes-mcu/002 ARM笔记(2) 关于GD32的应用环境准备工作说明","date":"2022-10-27T18:29:18.000Z","updated":"2023-06-20T15:30:22.720Z","comments":true,"path":"posts/3580214588.html","link":"","permalink":"https://sirius-blog.github.io/posts/3580214588.html","excerpt":"","text":"使用KEIL v5下载程序到GD32器件上时，需要根据器件型号进行相关pack安装包解压以及算法文件加载，本说明中以GD32F303VET6（即GD32F30x_HD闪存存储产品）为例。 资料准备 官网下载GD32F30x的应用软件并安装相关pack； 附件 暂无","categories":[{"name":"ARM 应用场景故障分析","slug":"ARM-应用场景故障分析","permalink":"https://sirius-blog.github.io/categories/ARM-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"}],"tags":[{"name":"国产","slug":"国产","permalink":"https://sirius-blog.github.io/tags/%E5%9B%BD%E4%BA%A7/"},{"name":"ARM","slug":"ARM","permalink":"https://sirius-blog.github.io/tags/ARM/"},{"name":"应用故障分析","slug":"应用故障分析","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"}]},{"title":"FPGA笔记(1) FPGA固化S29GL256P异常","slug":"study-ic-fpga/notes-fpga/001 FPGA笔记(1) FPGA固化S29GL256P存储异常","date":"2022-10-27T18:29:18.000Z","updated":"2023-06-10T03:02:10.007Z","comments":true,"path":"posts/2863292947.html","link":"","permalink":"https://sirius-blog.github.io/posts/2863292947.html","excerpt":"","text":"本章节旨在记录“FPGA固化S29GL256P异常”现象及排查（分析）思路。 异常现象 使用Vivado开发环境固化FPFGA外挂BPI接口存储器件过程，即用mcs文件烧录S29GL256P Flash，Vivado界面无报错； 点我查看细节 固化完成后重启设备，Vivado开发平台显示FPGA程序未自动加载完成； 点我查看细节 现象分析：正常情况下，FPGA程序固化在搭载的Flash芯片后再次加电后，FPGA会自动加载Flash中存储的程序；但目前现象是该程序无法自动加载成功。 思路 异常可能性： 1.可能是Flash芯片虚焊或者受损； 2.可能FPGA某些配置（软件或者硬件电路）不正常； 有效解决方案 暂无","categories":[{"name":"FPGA 应用场景故障分析","slug":"FPGA-应用场景故障分析","permalink":"https://sirius-blog.github.io/categories/FPGA-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"}],"tags":[{"name":"应用故障分析","slug":"应用故障分析","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"}]},{"title":"Hexo 进阶使用教程","slug":"study-github-pages/Hexo 进阶使用教程","date":"2022-07-30T16:00:00.000Z","updated":"2023-01-09T07:04:24.396Z","comments":true,"path":"posts/3724585709.html","link":"","permalink":"https://sirius-blog.github.io/posts/3724585709.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. XXX xxx1 1$ hexo More info: Writing xxx2 1$ hexo More info: Writing xxx3 1$ hexo More info: Writing YYY yyy1 1$ hexo More info: Writing yyy2 1$ hexo More info: Writing yyy3 1$ hexo More info: Writing","categories":[{"name":"Web","slug":"Web","permalink":"https://sirius-blog.github.io/categories/Web/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://sirius-blog.github.io/tags/Hexo/"}]},{"title":"Hexo主题LiveForCode介绍","slug":"study-github-pages/Hexo 主题 LiveForCode 介绍","date":"2020-07-31T16:00:00.000Z","updated":"2023-01-08T14:17:56.684Z","comments":true,"path":"posts/1112885394.html","link":"","permalink":"https://sirius-blog.github.io/posts/1112885394.html","excerpt":"","text":"Hexo 是高效的静态站点生成框架，他基于 Node.js。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。 你可以访问 Hexo 的文档 了解如何安装 Hexo 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。其中，一份位于 Hexo 根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件 ， 后者称为 主题配置文件 。 主题预览 Hexo - Live For Code 安装Live For Code Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至 Hexo 根目录的 themes 目录下，然后修改下配置文件即可。具体到 LiveForCode 来说，安装步骤如下。 下载主题 如果你熟悉 Git，建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新，而不用再次下载压缩包替换。 克隆最新版本 在终端窗口下，定位到 Hexo 站点目录下。使用 Git Checkout 代码： 12cd your-hexo-sitegit clone https://github.com/first19326/hexo-liveforcode 将克隆下来的文件夹中的 LiveForCode 文件夹移动至站点的 themes 目录下，并将 source 文件夹中的 about、category、comment、donate、friend 以及 tag 文件夹移动至 Hexo 站点目录下的 source 文件夹中。这些文件夹分别对应着 关于 、 标签 、 留言板 、 赞赏 、 友情链接 以及 分类 页面，其中的 index.md 中的内容为各个页面显示的内容，大家可以根据自己的情况进行修改。 下载稳定版本 前往 LiveForCode 版本发布页面。 选择你所需要的版本，下载 Download 区域下的 Source Code (zip) 到本地。 解压所下载的压缩包，并将解压后的文件夹中的 LiveForCode 文件夹移动至站点的 themes 目录下，并将 source 文件夹中的 about、category、comment、donate、friend 以及 tag 文件夹移动至 Hexo 站点目录下的 source 文件夹中。这些文件夹分别对应着 关于 、 标签 、 留言板 、 赞赏 、 友情链接 以及 分类 页面，其中的 index.md 中的内容为各个页面显示的内容，大家可以根据自己的情况进行修改。 启用主题 与所有 Hexo 主题启用的模式一样。当 克隆/下载 完成后，打开 站点配置文件 ，找到 theme 字段，并将其值更改为 LiveForCode。 1theme: LiveForCode 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题 首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 站点设定 在 站点配置文件 中，我修改了标签归档页面、分类归档页面以及文章归档页面的路径，如果大家使用默认的路径，则需要修改 主题配置文件 中的菜单设置。 123tag_dir: tagarchive_dir: archivecategory_dir: category 主题设定 由于 主题配置文件 可能有所改动，就不在这里给大家详细说明，我会在 主题配置文件 中添加适当的注释，麻烦大家参考页面以及注释内容进行修改。 404 页面设定 主题中有相应的 404 错误页面，是单独的静态页面，没有添加到模板中。在使用主题的时候，需要大家将其中的 返回首页 的跳转链接 https://notes.worstone.cn 替换为自己网站的地址。 404 错误页面在主题文件夹 LiveForCode 中的 source 文件夹中。 1234&lt;div class=&quot;buttons&quot;&gt; &lt;a href=&quot;javascript:;&quot; onclick=&quot;reload();&quot;&gt;刷新页面&lt;/a&gt; &lt;a href=&quot;https://notes.worstone.cn&quot; target=&quot;_self&quot;&gt;返回首页&lt;/a&gt;&lt;/div&gt; 第三方服务 Abbrlink Hexo 默认的文章链接是以时间和文件名称命名的，如果文件名称是中文，那么文章链接会被转译，而转义后的链接很长，并且也不美观。Hexo-Abbrlink 插件基于文章的标题自动为文章生成固定的链接。 1.安装 Hexo-Abbrlink 插件。前往站点根目录，执行命令安装： 1npm install hexo-abbrlink --save 2.编辑 站点配置文件，修改以下配置： 123permalink: posts/:abbrlink/ # orpermalink: posts/:abbrlink.html 3.编辑 站点配置文件，新增以下配置： 1234# abbrlink configabbrlink: alg: crc32 #support crc16(default) and crc32 rep: dec #support dec(default) and hex Hexo-Abbrlink 插件主要的设置选项： 算法（alg）：目前支持 crc16 和 crc32 算法，默认值为 crc16。 形式（rep）：生成的链接可以是十进制（dec）格式，也可以是十六进制（hex）格式，默认值为十进制（dec）格式。 生成的链接地址（参考）： 12345crc16 &amp; hexhttps://notes.worstone.cn/article/66c8.htmlcrc16 &amp; dechttps://notes.worstone.cn/article/65535.html 12345crc32 &amp; hexhttps://notes.worstone.cn/article/8ddf18fb.htmlcrc32 &amp; dechttps://notes.worstone.cn/article/1690090958.html Algolia Search 1.前往 Algolia 注册页面，注册一个新账户。 可以使用 GitHub 或者 Google 账户直接登录，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户总共有 10,000 条记录，每月有 100,000 的可以操作数。注册完成后，创建一个新的 Index，这个 Index 将在后面使用。 2.Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 Hexo Algolia 扩展，这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装： 1npm install --save hexo-algolia 3.编辑 站点配置文件 ，新增以下配置： 1234algolia: applicationID: &#x27;applicationID&#x27; apiKey: &#x27;apiKey&#x27; indexName: &#x27;...&#x27; 注：这里的 apiKey 为 Search-Only API Key 4.当配置完成，在站点根目录下执行一下命令更新 Index。请注意观察命令的输出。 12export HEXO_ALGOLIA_INDEXING_KEY=Admin API Keyhexo algolia 5.Hexo Algolia 命令设置选项 123456Options: --dry-run Does not push content to Algolia (default: false). --flush Resets the Algolia index before starting the indexation (default: false). --indexing-key An algolia API key with add/delete records permissions. It should be different than the search-only API key configured in _config.yml. --layouts A comma-separated list of page layouts to index (default: &quot;page&quot;). 说明： --flush 如果是 false 则每一次都会直接添加内容到 Algolia 相关的 Index 中，如果不是第一次提交，则将其设置为 true --layouts 如果使用默认设置，提交的时候会将分类归档、标签归档、赞赏、留言板等页面内容提交到 Algolia， 在搜索的时候，将会搜索到分类归档、标签归档、赞赏、留言板等页面内容，建议使用时将其设置为 post。 1hexo algolia --flush true --layouts post Vercel Vercel 是一个开箱即用的网站托管平台，方便开发者快速部署自己的网站。它在全球都拥有 CDN 节点，因此比 Github 官方自带的 Github Pages 更加稳定，访问速度更快。 Vercel 部署方式 进入到 Vercel 官网后，可以选择使用 Github 进行授权登录。Vercel 部署有两种方式（推荐第一种方式）： 1.利用 Vercel 的 Hexo 模板进行部署。 特别说明 使用这种方式需要已经安装 Hexo。不需要 进行 Hexo 初始化，即 hexo init 。 选择 Clone Template，点击下方的 Browse All Templates，然后找到 Hexo 模版。 选择模板后，进入到创建仓库界面，设置好仓库名称，然后点击 Create 即可。至于是否设置成私有仓库，根据个人意愿选择，目前 Github 的私有仓库是 免费 的。 等待 Vercel 部署完成，跳转到部署成功的页面。点击 Go to Dashboard 即可查看刚刚的项目。 部署好的模板项目是 Hexo 默认的主题，需要将 Github 对应的项目下载到本地进行修改。项目想要在本地进行运行，需要安装相关依赖，通过npm install 或 cnpm install 或yarn install皆可进行安装。依赖安装完成后，即可进行主题安装等相关操作。 2.通过 GitHub 托管 hexo deploy 生成的网页文件进行部署。 创建新的项目，选择 Import Git Repository，然后选择 Hexo 网站对应的仓库，点击 Import。 跳转到 Configure Project 页面，项目名称可以自行修改，其他的自定义选项，建议不要修改，除非有什么特殊需求。 点击 Deploy，然后等待部署完成即可。部署完成后，Vercel 会提供几个默认的域名，可以在对应项目中查看。 Vercel 自定义域名 进入到 Vercel 的 Dashboard，然后点击对应项目，然后点击 View Domains，进入到项目的 Domains 界面，在这里可以进行域名管理。如果想要使用 Vercel 提供的二级域名，可以直接添加 xxx.vercel.app；如果想要绑定自己的域名，在添加域名后，会提示 Invalid Config，需要添加 DNS 解析。 Vercel DNS 解析 1.如果是根域名，请在你的 DNS 解析处添加 A 记录，指向 76.76.21.21。 2.如果是子域名，请在你的 DNS 解析处添加 CNAME 记录，指向 cname.vercel-dns.com。 添加 DNS 解析记录之后，在 Vercel Domains 界面对应域名下方显示对号即表明验证成功。 特别说明 Github 仓库的分支尽量选择 master，否则 Github 推送之后，还需到 Vercel 手动部署项目。 设置 RSS 1.安装 Hexo-Feed 插件。前往站点根目录，执行命令安装： 1npm install --save hexo-generator-feed 2.根据个人需求，编辑 站点配置文件 ： 1234feed: type: atom path: atom.xml limit: 10 文章数据统计 文章数据统计基于 Valine.js 插件实现。 实现方式：在文章列表页面加载 Valine.js， 只要 Valine 配置项中的 el 元素不存在即不会加载评论框相关内容。 1.文章评论数统计 Valine 会自动查找页面中 class 值为 valine-comment-count 的元素，获取其 data-xid 为查询条件。并将得到的值填充到其 class 的值为 valine-comment-count 的元素里： 12&lt;!-- data-xid 将作为查询条件 --&gt;&lt;span class=&quot;valine-comment-count&quot; data-xid=&quot;&lt;Your/Path/Name&gt;&quot;&gt;&lt;/span&gt; 2.文章阅读量统计 Valine 从 v1.2.0 开始支持文章阅读量统计。 12345new Valine(&#123; el: &#x27;#vcomments&#x27;, ... visitor: true // 阅读量统计&#125;) 如果开启了阅读量统计，Valine 会自动检测 LeanCloud 应用中是否存在 Counter 类，如果不存在会自动创建，无需手动创建。 Valine 会自动查找页面中 class 值为 leancloud_visitors 的元素，获取其 id 为查询条件。并将得到的值填充到其 class 的值为 leancloud-visitors-count 的子元素里： 1234&lt;!-- id 将作为查询条件 --&gt;&lt;span id=&quot;&lt;Your/Path/Name&gt;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;Your Article Title&quot;&gt; &lt;i class=&quot;leancloud-visitors-count&quot;&gt;&lt;/i&gt;&lt;/span&gt; 特别说明 使用 国际版的 LeanCloud 的时候，需要配置 主题配置文件 中 Valine 的 serverURLs，内容为 LeanCloud 的 Request Domain，国内版则无需配置。 评论列表 评论功能使用的是 Valine.js 插件，配置详情请参见 Valine。 特别说明 主题配置文件 中 Valine 的 appId 与 appKey 请大家自行配置自己的参数。如果评论数据提交到我的 LeanCloud 工作空间，我并不能保证数据的完整性。 赞赏页面 赞赏页面使用了 Sponsor Page，并做了相关修改使其适应博客样式。感兴趣的小伙伴自行去了解吧。 音乐播放器 音乐播放器功能是使用 APlayer.js 以及 Meting.js 实现，配置详情参见 APlayer、Meting。 主题中有两种实现方式，一种是 APlayer.js 结合 Meting.js 的实现方式，另外一种是 APlayer.js 单独的实现方式，两种实现方式各有优缺点： 第一种实现方式配置简单，并且可以从各个音乐平台解析音乐。由于是从各个平台解析，故而不是特别稳定，并且在 IE 浏览器中需要特殊设置。 第二种实现方式配置相对复杂，需要单独提供音乐相关信息，但是十分稳定，且对于 IE 浏览器也可兼容，无需特殊配置。 主题中默认以 第一种实现方式 实现，第二种实现方式为备选方案，在第一种实现方式出现问题的时候，可以切换到第二种实现方式，保证网站的稳定运行。 针对第二种实现方式需要 注意 的地方： APlayer.js 是基于 HTML 5 Audio 实现的一款音乐播放器插件，故而支持的音频格式有限，包括：MP3、Wav 以及 Ogg 格式，并且不同浏览器对这三种音频格式的支持也各有不同，详细信息大家参考 HTML5 Audio(音频)。如果音频格式不支持，可以通过音频转换工具进行格式转换。 APlayer.js 是通过 XMLHttpRequest 获取歌词文件，所以存在 跨域 问题。可以考虑将歌词文件放在主题文件夹 LiveForCode 的 source 文件夹下（ 注意 ：这里的 source 文件夹不是 Hexo 站点目录下的 source 文件夹），解决跨域的问题。由于 jsDelivr 在响应请求的时候，会添加 access-control-allow-origin: * 的响应标头信息，故而不存在跨域问题，也可以使用这种方式。不过需要注意的是，jsDelivr 对资源的大小有所限制，不可以超过 50M 。 APlayer.js 获取到歌词后会将歌词中的空白行去掉，由于是单行显示歌词，所以有译文的双行歌词，只会显示下面一行歌词，可以将译文歌词拼接在歌词原文的后面解决这个问题。 常见问题 关于 jQuery 版本 mCustomScroll 目前暂不支持 jQuery3.5 以及以上版本，否则会导致代码块中的滚动条失效。 Position: fixed 定位问题 由于背景动画的 z-index 为 -1，导致在IE浏览器中，菜单等多处 position: fixed 样式的部件出现闪烁抖动的问题，所以默认在IE浏览器中关闭了背景动画。如果是高版本IE，例如IE11则可在设置 -&gt; Internet选项 -&gt; 高级，将浏览中的’使用平滑滚动’选项勾掉，也可以解决这个问题。 关于 Github Page 的使用 详情请参见 将 Hexo 部署到 GitHub Pages。 Github Page 支持设置自己的域名，建议在 Hexo 主题的 source 文件夹下新增一个 CNAME 的文件，将自己的域名配置进去，否则每次提交的时候会覆盖掉相关域名设置。 在域名的解析设置中，可以使用 CNAME 解析方式，也可以使用 A 记录 的方式。如果是 A 记录 的方式，则需要检索当前 Github Page 对应的服务器 IP 地址。 关于 CDN CDN 可以在阿里云购买相关的 CDN 服务器，效果肯定是更好，这里使用的是 jsDelivr 免费的 CDN 加速服务。但是有一个弊端，如果修改代码的时候没有 Github 的相关版本信息，则很容易读取到 jsDelivr 的缓存数据，而不是修改后的最新代码。至于这个缓存时间，我也拿捏不准。不过免费而且效果不错的东西，大家就不要要求太多了。 关于 Valine 由于很多小伙伴直接使用主题中 Valine 的 appId 以及 appKey，而且 Valine 默认设置的 path 为 window.location.pathname，会导致大家的留言板数据出现异常。所以这里还是建议大家设置自己的 LeanCloud，推荐使用国际版 ，后续如果想要添加邮件提醒，这样会方便很多。 关于 Vercel Github Pages 内容部署的服务器在美国，可能会导致国内部分地区加载速度较慢，大家可以将项目部署到 Vercel ，来提高网站的访问速度，同时也 方便百度对站点内容进行收录 。如果 网站域名已经备案 ，则可以考虑 国内的阿里云或腾讯云的相关产品 ，效果会更好。 Cannot read property ‘LongCang’ of undefined 这个问题比较常见，是主题文件路径不正确导致的。因为很多小伙伴都询问这个问题，所以在这里进行一个说明。 直接从 Github 下载 Zip 格式的文件解压后或 Github Clone 后的文件结构应该如上图所示。这里需要注意，是将解压后文件夹中的 LiveForCode 文件夹复制到 Hexo 的 themes 文件夹下，而不是将解压后的 Hexo-LiveForCode 复制到 themes 文件夹下。 标签、分类、归档等页面 404 或 Cannot GET 由于 Hexo 的标签、分类、归档等页面的目录修改为了 tag、category、archive，故使用默认的 站点配置文件 会出现这个问题。需要将 站点配置文件 中的 Directory 相关配置修改为： 123tag_dir: tagarchive_dir: archivecategory_dir: category 阶段计划 1.使用 Vue.js 重构项目 2.整理模板的样式文件 3.加入 Pjax，优化页面加载速度 4.补充国际化支持语言 5.考虑是否加入黑夜模式 总结 由于我还是一名小白，可能还有很多问题无法解决，这个主题也可能存在很多不尽如人意的地方，在细节方面我也会尽力地去修改，也欢迎大家提出自己的问题，以及主题的相关建议，也欢迎大家提交代码。如果觉得这个主题不错，欢迎大家去使用。当然了，如果能赞赏我一下，我也是不介意的。(●ˇ∀ˇ●) 这个主题可定制的地方目前可能比较少，欢迎大家修改，也希望这个主题能够越来越好看，也希望越来越多的人能够喜欢。","categories":[{"name":"Web","slug":"Web","permalink":"https://sirius-blog.github.io/categories/Web/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://sirius-blog.github.io/tags/Hexo/"}],"author":null},{"title":"Hexo 简单使用教程","slug":"study-github-pages/Hexo 简单使用教程","date":"2020-07-30T16:00:00.000Z","updated":"2023-01-09T06:53:53.851Z","comments":true,"path":"posts/2904855878.html","link":"","permalink":"https://sirius-blog.github.io/posts/2904855878.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"Web","slug":"Web","permalink":"https://sirius-blog.github.io/categories/Web/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://sirius-blog.github.io/tags/Hexo/"}],"author":"Hexo"},{"title":"Hexo 准备环境搭建","slug":"study-github-pages/Hexo 准备环境搭建","date":"2020-07-29T16:00:00.000Z","updated":"2023-01-09T06:53:51.797Z","comments":true,"path":"posts/3327631696.html","link":"","permalink":"https://sirius-blog.github.io/posts/3327631696.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 安装 Git 官网下载Git,根据系统支持选择对应版本，并安装。 安装步骤结束后，打开windows命令行，输入以下命令： 1$ git version 界面出现相应版本信息即表示安装成功。 安装 Nodejs 官网下载Nodejs,根据系统支持选择对应版本，并安装。 安装步骤结束后，打开windows命令行，输入以下命令： 12$ node -v$ npm -v 界面出现相应版本信息即表示安装成功。 安装 Hexo 打开windows命令行，输入以下命令： 12$ npm install -g hexo-cli$ npm install hexo-server --save 根据提示进行配置操作，安装步骤结束后，输入以下指令： 1$ hexo -v 界面出现相应版本信息基本表示配置成功。","categories":[{"name":"Web","slug":"Web","permalink":"https://sirius-blog.github.io/categories/Web/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://sirius-blog.github.io/tags/Hexo/"}]},{"title":"Hexo 搭建站点的基础流程","slug":"study-github-pages/Hexo 搭建站点的基础流程","date":"2020-07-28T16:00:00.000Z","updated":"2023-01-09T07:05:20.486Z","comments":true,"path":"posts/1243066710.html","link":"","permalink":"https://sirius-blog.github.io/posts/1243066710.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 搭建本地环境 安装 Git、Nodejs、Hexo 工具。 详见: Hexo 准备环境搭建。 获取 Hexo 基础站点文件 根据需要选择站点本地存放路径，并在该位置打开&quot;Git bash here&quot;，在该命令窗执行以下指令进行 Hexo 初始化： 1$ hexo init 该指令主要是从官方服务器下载站点基本文件，包含一个初始的hexo主题landscape。 执行上述指令时，会出现下载失败的情况，需要网络状况良好的空间环境，一般出现多行中显示进度100%，即表示文件下载完成。 选择 Hexo 主题 使用 Hexo 官网发布主题，或者自定义主题，此处以Hexo主题LiveForCode为例。 详见: Hexo 主题 LiveForCode 介绍。 新建文章及本地预览效果 详见: Hexo 简单使用教程。 修改及添加功能 详见: Hexo 进阶使用教程。","categories":[{"name":"Web","slug":"Web","permalink":"https://sirius-blog.github.io/categories/Web/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://sirius-blog.github.io/tags/Hexo/"}]}],"categories":[{"name":"IC小知识","slug":"IC小知识","permalink":"https://sirius-blog.github.io/categories/IC%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"PCB 拓展","slug":"PCB-拓展","permalink":"https://sirius-blog.github.io/categories/PCB-%E6%8B%93%E5%B1%95/"},{"name":"MCU 实践","slug":"MCU-实践","permalink":"https://sirius-blog.github.io/categories/MCU-%E5%AE%9E%E8%B7%B5/"},{"name":"SCH 应用拓展","slug":"SCH-应用拓展","permalink":"https://sirius-blog.github.io/categories/SCH-%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"MCU 应用练习","slug":"MCU-应用练习","permalink":"https://sirius-blog.github.io/categories/MCU-%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"},{"name":"ARM 应用场景故障分析","slug":"ARM-应用场景故障分析","permalink":"https://sirius-blog.github.io/categories/ARM-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"},{"name":"FPGA 开发环境应用笔记","slug":"FPGA-开发环境应用笔记","permalink":"https://sirius-blog.github.io/categories/FPGA-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"name":"FPGA 应用场景故障分析","slug":"FPGA-应用场景故障分析","permalink":"https://sirius-blog.github.io/categories/FPGA-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"},{"name":"Web","slug":"Web","permalink":"https://sirius-blog.github.io/categories/Web/"}],"tags":[{"name":"微波认知","slug":"微波认知","permalink":"https://sirius-blog.github.io/tags/%E5%BE%AE%E6%B3%A2%E8%AE%A4%E7%9F%A5/"},{"name":"PCB","slug":"PCB","permalink":"https://sirius-blog.github.io/tags/PCB/"},{"name":"应用拓展","slug":"应用拓展","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95/"},{"name":"器件封装及焊接曲线","slug":"器件封装及焊接曲线","permalink":"https://sirius-blog.github.io/tags/%E5%99%A8%E4%BB%B6%E5%B0%81%E8%A3%85%E5%8F%8A%E7%84%8A%E6%8E%A5%E6%9B%B2%E7%BA%BF/"},{"name":"文档格式","slug":"文档格式","permalink":"https://sirius-blog.github.io/tags/%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F/"},{"name":"GigaDevice (国产)","slug":"GigaDevice-国产","permalink":"https://sirius-blog.github.io/tags/GigaDevice-%E5%9B%BD%E4%BA%A7/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"库函数版实践","slug":"库函数版实践","permalink":"https://sirius-blog.github.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88%E5%AE%9E%E8%B7%B5/"},{"name":"GD32F30x","slug":"GD32F30x","permalink":"https://sirius-blog.github.io/tags/GD32F30x/"},{"name":"Schematic","slug":"Schematic","permalink":"https://sirius-blog.github.io/tags/Schematic/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"库函数应用练习","slug":"库函数应用练习","permalink":"https://sirius-blog.github.io/tags/%E5%BA%93%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"},{"name":"国产","slug":"国产","permalink":"https://sirius-blog.github.io/tags/%E5%9B%BD%E4%BA%A7/"},{"name":"ARM","slug":"ARM","permalink":"https://sirius-blog.github.io/tags/ARM/"},{"name":"应用故障分析","slug":"应用故障分析","permalink":"https://sirius-blog.github.io/tags/%E5%BA%94%E7%94%A8%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"},{"name":"PHY","slug":"PHY","permalink":"https://sirius-blog.github.io/tags/PHY/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"Xilinx开发环境应用笔记","slug":"Xilinx开发环境应用笔记","permalink":"https://sirius-blog.github.io/tags/Xilinx%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"name":"Vivado","slug":"Vivado","permalink":"https://sirius-blog.github.io/tags/Vivado/"},{"name":"ISE 14.7","slug":"ISE-14-7","permalink":"https://sirius-blog.github.io/tags/ISE-14-7/"},{"name":"Hexo","slug":"Hexo","permalink":"https://sirius-blog.github.io/tags/Hexo/"}]}