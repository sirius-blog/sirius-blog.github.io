{"meta":{"title":"Blog","subtitle":"","description":"","author":"Mr.T","url":"https://sirius-blog.github.io","root":"/"},"pages":[{"title":"","date":"2023-06-03T04:09:19.892Z","updated":"2023-05-23T14:32:16.460Z","comments":true,"path":"manifest.json","permalink":"https://sirius-blog.github.io/manifest.json","excerpt":"","text":"{\"name\":\"Ariasakaの小窝\",\"short_name\":\"Ariasakaの小窝\",\"theme_color\":\"var(--lyx-theme)\",\"background_color\":\"var(--lyx-theme)\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"},{\"src\":\"/img/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"/img/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/img/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"/img/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/img/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/img/180.png\",\"sizes\":\"180X180\",\"type\":\"image/png\"},{\"src\":\"/img/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"},{\"src\":\"/img/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/img/256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"/img/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2023-06-03T04:09:19.923Z","updated":"2023-05-23T14:32:16.475Z","comments":true,"path":"package.json","permalink":"https://sirius-blog.github.io/package.json","excerpt":"","text":"{\"name\":\"ariasakablog\",\"version\":\"1.0.17\",\"description\":\"SpeedUp!\",\"main\":\"index.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"author\":\"\",\"license\":\"ISC\"}"},{"title":"分类","date":"2022-07-03T12:48:08.000Z","updated":"2023-05-23T14:32:16.217Z","comments":true,"path":"categories/index.html","permalink":"https://sirius-blog.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-03-30T07:57:51.000Z","updated":"2023-05-23T14:32:16.202Z","comments":true,"path":"about/index.html","permalink":"https://sirius-blog.github.io/about/index.html","excerpt":"","text":""},{"title":"fontawesome对照","date":"2022-11-25T00:16:09.000Z","updated":"2023-05-23T14:32:16.223Z","comments":true,"path":"fontawesome/index.html","permalink":"https://sirius-blog.github.io/fontawesome/index.html","excerpt":"","text":"window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight);"},{"title":"标签","date":"2022-07-03T12:51:29.000Z","updated":"2023-05-23T14:32:16.485Z","comments":true,"path":"tags/index.html","permalink":"https://sirius-blog.github.io/tags/index.html","excerpt":"","text":""},{"title":"时间线","date":"2022-07-02T11:56:00.000Z","updated":"2023-06-03T09:41:05.519Z","comments":true,"path":"timelines/index.html","permalink":"https://sirius-blog.github.io/timelines/index.html","excerpt":"","text":"更新日志一个时间线 2022 07-02 事件 07-03 事件 07-04 事件 07-05 事件 07-06 事件 07-08 事件 07-09 事件 07-14 事件 07-18 事件 07-22 事件 08-12 事件 08-25 事件"},{"title":"导航","date":"2023-03-11T17:22:43.000Z","updated":"2023-06-03T10:54:53.334Z","comments":true,"path":"notes/nav/index.html","permalink":"https://sirius-blog.github.io/notes/nav/index.html","excerpt":"","text":"冰糖红茶 “冰糖红茶”博客魔改组织的大佬们 小冰【冰】 做个有梦想的人！ Akilar【糖】 期待您的光临！ 张洪Heo【红】 分享设计与科技生活 贰猹【茶】 用这生命中的每一秒，给自己一个不后悔的未来"},{"title":"札记","date":"2022-08-04T03:38:05.000Z","updated":"2023-06-03T10:55:35.998Z","comments":true,"path":"notes/zhaji/index.html","permalink":"https://sirius-blog.github.io/notes/zhaji/index.html","excerpt":"","text":"一些博主搭建的其它的站点： PS：划掉的表示已挂 域名 用处 搭建原因 yisous.xyz 博客，也是主站（默认无www） 分享一些东西 oj.yisous.xyz OnlineJudge系统 用于自己练习信奥赛题目其实是搞来象征意义的 status.yisous.xyz 网站状态监控 用于监控网站的状态，基于uptimeRobot mc.yisous.xyz Minecraft服务器 用来联机玩，类似于粉丝服那种，还没弄好 tc.yisous.xyz Typecho测试站 看看typecho怎么样，搞来玩的，已经由Wordpress迁移至当前的Typecho，未来服务器文档之后可能会换用 yisous.tk/lyxop.xyz 短链接生成器 制作短链接，使用本站域名，技术有限，所以很丑 bbs.yisous.xyz LYXの论坛 交流一些事情，也可以闲聊，还没弄说是交流其实还是搞来象征意义搞来玩的 博主的一些域名 域名 用处 yisous.xyz 主要使用的域名，当时看到dynadot14块一年就买了，这个名字就是念起来顺口 lyxop.xyz 注册拿来给副站用的，使用blog.lyxop.xyz进入主站。由于域名续费太贵，所以打算以后换成yisous.tk，其余一样 ariasaka.top 在硅云白嫖的一个域名，后续可能会作为主域名使用 lyxoff2233.eu.org 以前的eu.org域名，还不错，后面要拿来想办法用一用 lyxofficial.eu.org 图一乐域名 yisous.tk 20年为了搭树莓派服搞的域名，可是树莓派没多久就被我超坏了，现在就买不起了，后来这个域名过期，现在又弄回来作为副站使用，使用blog.yisous.tk进入主站，www和根域名主站用于提供短域名服务（已挂）。 注意：本博客强制HTTPS，旧电脑可能会出现问题。 #article-container a:not(.post-meta__tags):not(img):not(a[data-fancybox]):hover{ border-radius: 6px; background-color: #425aef; text-decoration: none!important; color:#fff!important; border:none; box-shadow: #dadada 0 0 8px 2px; } #article-container a:not(.post-meta__tags):not(.headerlink):not(a[data-fancybox]){ /* padding:0 2px; */ /* text-decoration: 1px solid #425aef; */ /* text-decoration: underline; */ border-bottom: 2px solid #425aef; color:var(--font-color); padding:4px }"},{"title":"导航","date":"2022-01-29T07:23:17.000Z","updated":"2023-06-03T10:55:56.329Z","comments":true,"path":"practice/nav/index.html","permalink":"https://sirius-blog.github.io/practice/nav/index.html","excerpt":"","text":"与主机通讯中…… var fdataUser = { apiurl: '' }"},{"title":"随笔","date":"2023-03-11T17:22:43.000Z","updated":"2023-06-03T11:02:26.025Z","comments":true,"path":"practice/suibi/index.html","permalink":"https://sirius-blog.github.io/practice/suibi/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2023-06-03T04:09:20.286Z","updated":"2023-05-23T14:32:16.199Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://sirius-blog.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"STM32F1 库函数例程（16）待机唤醒","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-016","date":"2022-11-08T04:09:18.000Z","updated":"2023-04-05T14:20:22.643Z","comments":true,"path":"posts/1201734687.html","link":"","permalink":"https://sirius-blog.github.io/posts/1201734687.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 beep output PB8 LED0驱动 思路 调用官方库文件驱动GPIO口。 驱动 wkup.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// wkup.c#include &quot;wkup.h&quot;#include &quot;led.h&quot;#include &quot;delay.h&quot; void Sys_Standby(void)&#123; RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); //使能PWR外设时钟 PWR_WakeUpPinCmd(ENABLE); //使能唤醒管脚功能 PWR_EnterSTANDBYMode(); //进入待命（STANDBY）模式 &#125;//系统进入待机模式void Sys_Enter_Standby(void)&#123; RCC_APB2PeriphResetCmd(0X01FC,DISABLE); //复位所有IO口 Sys_Standby();&#125;//检测WKUP脚的信号//返回值1:连续按下3s以上// 0:错误的触发 u8 Check_WKUP(void) &#123; u8 t=0; //记录按下的时间 LED0=0; //亮灯DS0 while(1) &#123; if(WKUP_KD) &#123; t++; //已经按下了 delay_ms(30); if(t&gt;=100) //按下超过3秒钟 &#123; LED0=0; //点亮DS0 return 1; //按下3s以上了 &#125; &#125;else &#123; LED0=1; return 0; //按下不足3秒 &#125; &#125;&#125; //中断,检测到PA0脚的一个上升沿. //中断线0线上的中断检测void EXTI0_IRQHandler(void)&#123; EXTI_ClearITPendingBit(EXTI_Line0); // 清除LINE10上的中断标志位 if(Check_WKUP())//关机? &#123; Sys_Enter_Standby(); &#125;&#125; //PA0 WKUP唤醒初始化void WKUP_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; EXTI_InitTypeDef EXTI_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);//使能GPIOA和复用功能时钟 GPIO_InitStructure.GPIO_Pin =GPIO_Pin_0; //PA.0 GPIO_InitStructure.GPIO_Mode =GPIO_Mode_IPD;//上拉输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化IO //使用外部中断方式 GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); //中断线0连接GPIOA.0 EXTI_InitStructure.EXTI_Line = EXTI_Line0; //设置按键所有的外部线路 EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; //设外外部中断模式:EXTI线路为中断请求 EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; //上升沿触发 EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_InitStructure); // 初始化外部中断 NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; //使能按键所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; //先占优先级2级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; //从优先级2级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 if(Check_WKUP()==0) Sys_Standby(); //不是开机,进入待机模式 &#125;/******************* END OF FILE *********/ rtc.h 12345678910111213// wkup.h#ifndef __WKUP_H#define __WKUP_H #include &quot;sys.h&quot;#define WKUP_KD PAin(0) //PA0 检测是否外部WK_UP按键按下 u8 Check_WKUP(void); //检测WKUP脚的信号void WKUP_Init(void); //PA0 WKUP唤醒初始化void Sys_Enter_Standby(void); //系统进入待机模式#endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031323334//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;lcd.h&quot;#include &quot;usart.h&quot; #include &quot;wkup.h&quot; int main(void) &#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置中断优先级分组为组2：2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 WKUP_Init(); //待机唤醒初始化 LCD_Init(); //LCD初始化 POINT_COLOR=RED; LCD_ShowString(30,50,200,16,16,&quot;Elite STM32&quot;); LCD_ShowString(30,70,200,16,16,&quot;WKUP TEST&quot;); LCD_ShowString(30,90,200,16,16,&quot;ATOM@ALIENTEK&quot;); LCD_ShowString(30,110,200,16,16,&quot;2015/1/14&quot;); while(1) &#123; LED0=!LED0; delay_ms(250); &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 代码片段分析 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（15）RTC芯片","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-015","date":"2022-11-08T03:59:18.000Z","updated":"2023-04-05T14:20:13.456Z","comments":true,"path":"posts/53287182.html","link":"","permalink":"https://sirius-blog.github.io/posts/53287182.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 beep output PB8 LED0驱动 思路 调用官方库文件驱动GPIO口。 驱动 rtc.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250// rtc.c#include &quot;sys.h&quot;#include &quot;delay.h&quot;#include &quot;usart.h&quot;#include &quot;rtc.h&quot; _calendar_obj calendar;//时钟结构体 static void RTC_NVIC_Config(void)&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn; //RTC全局中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //先占优先级1位,从优先级3位 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; //先占优先级0位,从优先级4位 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能该通道中断 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器&#125;//实时时钟配置//初始化RTC时钟,同时检测时钟是否工作正常//BKP-&gt;DR1用于保存是否第一次配置的设置//返回0:正常//其他:错误代码u8 RTC_Init(void)&#123; //检查是不是第一次配置时钟 u8 temp=0; RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); //使能PWR和BKP外设时钟 PWR_BackupAccessCmd(ENABLE); //使能后备寄存器访问 if (BKP_ReadBackupRegister(BKP_DR1) != 0x5050) //从指定的后备寄存器中读出数据:读出了与写入的指定数据不相乎 &#123; BKP_DeInit(); //复位备份区域 RCC_LSEConfig(RCC_LSE_ON); //设置外部低速晶振(LSE),使用外设低速晶振 while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET&amp;&amp;temp&lt;250) //检查指定的RCC标志位设置与否,等待低速晶振就绪 &#123; temp++; delay_ms(10); &#125; if(temp&gt;=250)return 1;//初始化时钟失败,晶振有问题 RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE); //设置RTC时钟(RTCCLK),选择LSE作为RTC时钟 RCC_RTCCLKCmd(ENABLE); //使能RTC时钟 RTC_WaitForLastTask(); //等待最近一次对RTC寄存器的写操作完成 RTC_WaitForSynchro(); //等待RTC寄存器同步 RTC_ITConfig(RTC_IT_SEC, ENABLE); //使能RTC秒中断 RTC_WaitForLastTask(); //等待最近一次对RTC寄存器的写操作完成 RTC_EnterConfigMode();/// 允许配置 RTC_SetPrescaler(32767); //设置RTC预分频的值 RTC_WaitForLastTask(); //等待最近一次对RTC寄存器的写操作完成 RTC_Set(2015,1,14,17,42,55); //设置时间 RTC_ExitConfigMode(); //退出配置模式 BKP_WriteBackupRegister(BKP_DR1, 0X5050); //向指定的后备寄存器中写入用户程序数据 &#125; else//系统继续计时 &#123; RTC_WaitForSynchro(); //等待最近一次对RTC寄存器的写操作完成 RTC_ITConfig(RTC_IT_SEC, ENABLE); //使能RTC秒中断 RTC_WaitForLastTask(); //等待最近一次对RTC寄存器的写操作完成 &#125; RTC_NVIC_Config();//RCT中断分组设置 RTC_Get();//更新时间 return 0; //ok&#125; //RTC时钟中断//每秒触发一次 //extern u16 tcnt; void RTC_IRQHandler(void)&#123; if (RTC_GetITStatus(RTC_IT_SEC) != RESET)//秒钟中断 &#123; RTC_Get();//更新时间 &#125; if(RTC_GetITStatus(RTC_IT_ALR)!= RESET)//闹钟中断 &#123; RTC_ClearITPendingBit(RTC_IT_ALR); //清闹钟中断 RTC_Get(); //更新时间 printf(&quot;Alarm Time:%d-%d-%d %d:%d:%d\\n&quot;,calendar.w_year,calendar.w_month,calendar.w_date,calendar.hour,calendar.min,calendar.sec);//输出闹铃时间 &#125; RTC_ClearITPendingBit(RTC_IT_SEC|RTC_IT_OW); //清闹钟中断 RTC_WaitForLastTask(); &#125;//判断是否是闰年函数//月份 1 2 3 4 5 6 7 8 9 10 11 12//闰年 31 29 31 30 31 30 31 31 30 31 30 31//非闰年 31 28 31 30 31 30 31 31 30 31 30 31//输入:年份//输出:该年份是不是闰年.1,是.0,不是u8 Is_Leap_Year(u16 year)&#123; if(year%4==0) //必须能被4整除 &#123; if(year%100==0) &#123; if(year%400==0)return 1;//如果以00结尾,还要能被400整除 else return 0; &#125;else return 1; &#125;else return 0; &#125; //设置时钟//把输入的时钟转换为秒钟//以1970年1月1日为基准//1970~2099年为合法年份//返回值:0,成功;其他:错误代码.//月份数据表 u8 const table_week[12]=&#123;0,3,3,6,1,4,6,2,5,0,3,5&#125;; //月修正数据表 //平年的月份日期表const u8 mon_table[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;u8 RTC_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)&#123; u16 t; u32 seccount=0; if(syear&lt;1970||syear&gt;2099)return 1; for(t=1970;t&lt;syear;t++) //把所有年份的秒钟相加 &#123; if(Is_Leap_Year(t))seccount+=31622400;//闰年的秒钟数 else seccount+=31536000; //平年的秒钟数 &#125; smon-=1; for(t=0;t&lt;smon;t++) //把前面月份的秒钟数相加 &#123; seccount+=(u32)mon_table[t]*86400;//月份秒钟数相加 if(Is_Leap_Year(syear)&amp;&amp;t==1)seccount+=86400;//闰年2月份增加一天的秒钟数 &#125; seccount+=(u32)(sday-1)*86400;//把前面日期的秒钟数相加 seccount+=(u32)hour*3600;//小时秒钟数 seccount+=(u32)min*60; //分钟秒钟数 seccount+=sec;//最后的秒钟加上去 RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); //使能PWR和BKP外设时钟 PWR_BackupAccessCmd(ENABLE); //使能RTC和后备寄存器访问 RTC_SetCounter(seccount); //设置RTC计数器的值 RTC_WaitForLastTask(); //等待最近一次对RTC寄存器的写操作完成 return 0; &#125;//初始化闹钟 //以1970年1月1日为基准//1970~2099年为合法年份//syear,smon,sday,hour,min,sec：闹钟的年月日时分秒 //返回值:0,成功;其他:错误代码.u8 RTC_Alarm_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)&#123; u16 t; u32 seccount=0; if(syear&lt;1970||syear&gt;2099)return 1; for(t=1970;t&lt;syear;t++) //把所有年份的秒钟相加 &#123; if(Is_Leap_Year(t))seccount+=31622400;//闰年的秒钟数 else seccount+=31536000; //平年的秒钟数 &#125; smon-=1; for(t=0;t&lt;smon;t++) //把前面月份的秒钟数相加 &#123; seccount+=(u32)mon_table[t]*86400;//月份秒钟数相加 if(Is_Leap_Year(syear)&amp;&amp;t==1)seccount+=86400;//闰年2月份增加一天的秒钟数 &#125; seccount+=(u32)(sday-1)*86400;//把前面日期的秒钟数相加 seccount+=(u32)hour*3600;//小时秒钟数 seccount+=(u32)min*60; //分钟秒钟数 seccount+=sec;//最后的秒钟加上去 //设置时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); //使能PWR和BKP外设时钟 PWR_BackupAccessCmd(ENABLE); //使能后备寄存器访问 //上面三步是必须的! RTC_SetAlarm(seccount); RTC_WaitForLastTask(); //等待最近一次对RTC寄存器的写操作完成 return 0; &#125;//得到当前的时间//返回值:0,成功;其他:错误代码.u8 RTC_Get(void)&#123; static u16 daycnt=0; u32 timecount=0; u32 temp=0; u16 temp1=0; timecount=RTC_GetCounter(); temp=timecount/86400; //得到天数(秒钟数对应的) if(daycnt!=temp)//超过一天了 &#123; daycnt=temp; temp1=1970; //从1970年开始 while(temp&gt;=365) &#123; if(Is_Leap_Year(temp1))//是闰年 &#123; if(temp&gt;=366)temp-=366;//闰年的秒钟数 else &#123;temp1++;break;&#125; &#125; else temp-=365; //平年 temp1++; &#125; calendar.w_year=temp1;//得到年份 temp1=0; while(temp&gt;=28)//超过了一个月 &#123; if(Is_Leap_Year(calendar.w_year)&amp;&amp;temp1==1)//当年是不是闰年/2月份 &#123; if(temp&gt;=29)temp-=29;//闰年的秒钟数 else break; &#125; else &#123; if(temp&gt;=mon_table[temp1])temp-=mon_table[temp1];//平年 else break; &#125; temp1++; &#125; calendar.w_month=temp1+1; //得到月份 calendar.w_date=temp+1; //得到日期 &#125; temp=timecount%86400; //得到秒钟数 calendar.hour=temp/3600; //小时 calendar.min=(temp%3600)/60; //分钟 calendar.sec=(temp%3600)%60; //秒钟 calendar.week=RTC_Get_Week(calendar.w_year,calendar.w_month,calendar.w_date);//获取星期 return 0;&#125; //获得现在是星期几//功能描述:输入公历日期得到星期(只允许1901-2099年)//输入参数：公历年月日 //返回值：星期号 u8 RTC_Get_Week(u16 year,u8 month,u8 day)&#123; u16 temp2; u8 yearH,yearL; yearH=year/100; yearL=year%100; // 如果为21世纪,年份数加100 if (yearH&gt;19)yearL+=100; // 所过闰年数只算1900年之后的 temp2=yearL+yearL/4; temp2=temp2%7; temp2=temp2+day+table_week[month-1]; if (yearL%4==0&amp;&amp;month&lt;3)temp2--; return(temp2%7);&#125; /******************* END OF FILE *********/ rtc.h 12345678910111213141516171819202122232425262728293031// rtc.h#ifndef __RTC_H#define __RTC_H //时间结构体typedef struct &#123; vu8 hour; vu8 min; vu8 sec; //公历日月年周 vu16 w_year; vu8 w_month; vu8 w_date; vu8 week; &#125;_calendar_obj; extern _calendar_obj calendar; //日历结构体extern u8 const mon_table[12]; //月份日期数据表void Disp_Time(u8 x,u8 y,u8 size);//在制定位置开始显示时间void Disp_Week(u8 x,u8 y,u8 size,u8 lang);//在指定位置显示星期u8 RTC_Init(void); //初始化RTC,返回0,失败;1,成功;u8 Is_Leap_Year(u16 year);//平年,闰年判断u8 RTC_Alarm_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec);u8 RTC_Get(void); //更新时间 u8 RTC_Get_Week(u16 year,u8 month,u8 day);u8 RTC_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec);//设置时间 #endif/******************* END OF FILE *********/ main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;lcd.h&quot;#include &quot;usart.h&quot; #include &quot;usmart.h&quot; #include &quot;rtc.h&quot; int main(void) &#123; u8 t=0; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置中断优先级分组为组2：2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 LCD_Init(); usmart_dev.init(SystemCoreClock/1000000); //初始化USMART RTC_Init(); //RTC初始化 POINT_COLOR=RED;//设置字体为红色 LCD_ShowString(60,50,200,16,16,&quot;Elite STM32&quot;); LCD_ShowString(60,70,200,16,16,&quot;RTC TEST&quot;); LCD_ShowString(60,90,200,16,16,&quot;ATOM@ALIENTEK&quot;); LCD_ShowString(60,110,200,16,16,&quot;2015/1/14&quot;); //显示时间 POINT_COLOR=BLUE;//设置字体为蓝色 LCD_ShowString(60,130,200,16,16,&quot; - - &quot;); LCD_ShowString(60,162,200,16,16,&quot; : : &quot;); while(1) &#123; if(t!=calendar.sec) &#123; t=calendar.sec; LCD_ShowNum(60,130,calendar.w_year,4,16); LCD_ShowNum(100,130,calendar.w_month,2,16); LCD_ShowNum(124,130,calendar.w_date,2,16); switch(calendar.week) &#123; case 0: LCD_ShowString(60,148,200,16,16,&quot;Sunday &quot;); break; case 1: LCD_ShowString(60,148,200,16,16,&quot;Monday &quot;); break; case 2: LCD_ShowString(60,148,200,16,16,&quot;Tuesday &quot;); break; case 3: LCD_ShowString(60,148,200,16,16,&quot;Wednesday&quot;); break; case 4: LCD_ShowString(60,148,200,16,16,&quot;Thursday &quot;); break; case 5: LCD_ShowString(60,148,200,16,16,&quot;Friday &quot;); break; case 6: LCD_ShowString(60,148,200,16,16,&quot;Saturday &quot;); break; &#125; LCD_ShowNum(60,162,calendar.hour,2,16); LCD_ShowNum(84,162,calendar.min,2,16); LCD_ShowNum(108,162,calendar.sec,2,16); LED0=!LED0; &#125; delay_ms(10); &#125;; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 代码片段分析 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（14）USMART调试","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-014","date":"2022-11-08T03:39:18.000Z","updated":"2023-04-05T14:20:04.871Z","comments":true,"path":"posts/3783971557.html","link":"","permalink":"https://sirius-blog.github.io/posts/3783971557.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 beep output PB8 LED0驱动 思路 调用官方库文件驱动GPIO口。 驱动 usmart.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385// usmart.c#include &quot;usmart.h&quot;#include &quot;usart.h&quot;#include &quot;sys.h&quot;//系统命令u8 *sys_cmd_tab[]=&#123; &quot;?&quot;, &quot;help&quot;, &quot;list&quot;, &quot;id&quot;, &quot;hex&quot;, &quot;dec&quot;, &quot;runtime&quot;, &#125;; //处理系统指令//0,成功处理;其他,错误代码;u8 usmart_sys_cmd_exe(u8 *str)&#123; u8 i; u8 sfname[MAX_FNAME_LEN];//存放本地函数名 u8 pnum; u8 rval; u32 res; res=usmart_get_cmdname(str,sfname,&amp;i,MAX_FNAME_LEN);//得到指令及指令长度 if(res)return USMART_FUNCERR;//错误的指令 str+=i; for(i=0;i&lt;sizeof(sys_cmd_tab)/4;i++)//支持的系统指令 &#123; if(usmart_strcmp(sfname,sys_cmd_tab[i])==0)break; &#125; switch(i) &#123; case 0: case 1://帮助指令 printf(&quot;\\r\\n&quot;);#if USMART_USE_HELP printf(&quot;------------------------USMART V3.1------------------------ \\r\\n&quot;); printf(&quot; USMART是由ALIENTEK开发的一个灵巧的串口调试互交组件,通过 \\r\\n&quot;); printf(&quot;它,你可以通过串口助手调用程序里面的任何函数,并执行.因此,你可\\r\\n&quot;); printf(&quot;以随意更改函数的输入参数(支持数字(10/16进制)、字符串、函数入\\r\\n&quot;); printf(&quot;口地址等作为参数),单个函数最多支持10个输入参数,并支持函数返 \\r\\n&quot;); printf(&quot;回值显示.新增参数显示进制设置功能,新增进制转换功能.\\r\\n&quot;); printf(&quot;技术支持:www.openedv.com\\r\\n&quot;); printf(&quot;USMART有7个系统命令:\\r\\n&quot;); printf(&quot;?: 获取帮助信息\\r\\n&quot;); printf(&quot;help: 获取帮助信息\\r\\n&quot;); printf(&quot;list: 可用的函数列表\\r\\n\\n&quot;); printf(&quot;id: 可用函数的ID列表\\r\\n\\n&quot;); printf(&quot;hex: 参数16进制显示,后跟空格+数字即执行进制转换\\r\\n\\n&quot;); printf(&quot;dec: 参数10进制显示,后跟空格+数字即执行进制转换\\r\\n\\n&quot;); printf(&quot;runtime:1,开启函数运行计时;0,关闭函数运行计时;\\r\\n\\n&quot;); printf(&quot;请按照程序编写格式输入函数名及参数并以回车键结束.\\r\\n&quot;); printf(&quot;--------------------------ALIENTEK------------------------- \\r\\n&quot;);#else printf(&quot;指令失效\\r\\n&quot;);#endif break; case 2://查询指令 printf(&quot;\\r\\n&quot;); printf(&quot;-------------------------函数清单--------------------------- \\r\\n&quot;); for(i=0;i&lt;usmart_dev.fnum;i++)printf(&quot;%s\\r\\n&quot;,usmart_dev.funs[i].name); printf(&quot;\\r\\n&quot;); break; case 3://查询ID printf(&quot;\\r\\n&quot;); printf(&quot;-------------------------函数 ID --------------------------- \\r\\n&quot;); for(i=0;i&lt;usmart_dev.fnum;i++) &#123; usmart_get_fname((u8*)usmart_dev.funs[i].name,sfname,&amp;pnum,&amp;rval);//得到本地函数名 printf(&quot;%s id is:\\r\\n0X%08X\\r\\n&quot;,sfname,usmart_dev.funs[i].func); //显示ID &#125; printf(&quot;\\r\\n&quot;); break; case 4://hex指令 printf(&quot;\\r\\n&quot;); usmart_get_aparm(str,sfname,&amp;i); if(i==0)//参数正常 &#123; i=usmart_str2num(sfname,&amp;res); //记录该参数 if(i==0) //进制转换功能 &#123; printf(&quot;HEX:0X%X\\r\\n&quot;,res); //转为16进制 &#125;else if(i!=4)return USMART_PARMERR;//参数错误. else //参数显示设定功能 &#123; printf(&quot;16进制参数显示!\\r\\n&quot;); usmart_dev.sptype=SP_TYPE_HEX; &#125; &#125;else return USMART_PARMERR; //参数错误. printf(&quot;\\r\\n&quot;); break; case 5://dec指令 printf(&quot;\\r\\n&quot;); usmart_get_aparm(str,sfname,&amp;i); if(i==0)//参数正常 &#123; i=usmart_str2num(sfname,&amp;res); //记录该参数 if(i==0) //进制转换功能 &#123; printf(&quot;DEC:%lu\\r\\n&quot;,res); //转为10进制 &#125;else if(i!=4)return USMART_PARMERR;//参数错误. else //参数显示设定功能 &#123; printf(&quot;10进制参数显示!\\r\\n&quot;); usmart_dev.sptype=SP_TYPE_DEC; &#125; &#125;else return USMART_PARMERR; //参数错误. printf(&quot;\\r\\n&quot;); break; case 6://runtime指令,设置是否显示函数执行时间 printf(&quot;\\r\\n&quot;); usmart_get_aparm(str,sfname,&amp;i); if(i==0)//参数正常 &#123; i=usmart_str2num(sfname,&amp;res); //记录该参数 if(i==0) //读取指定地址数据功能 &#123; if(USMART_ENTIMX_SCAN==0)printf(&quot;\\r\\nError! \\r\\nTo EN RunTime function,Please set USMART_ENTIMX_SCAN = 1 first!\\r\\n&quot;);//报错 else &#123; usmart_dev.runtimeflag=res; if(usmart_dev.runtimeflag)printf(&quot;Run Time Calculation ON\\r\\n&quot;); else printf(&quot;Run Time Calculation OFF\\r\\n&quot;); &#125; &#125;else return USMART_PARMERR; //未带参数,或者参数错误 &#125;else return USMART_PARMERR; //参数错误. printf(&quot;\\r\\n&quot;); break; default://非法指令 return USMART_FUNCERR; &#125; return 0;&#125;//////////////////////////////////////////////////////////////////////////////////////////移植注意:本例是以stm32为例,如果要移植到其他mcu,请做相应修改.//usmart_reset_runtime,清除函数运行时间,连同定时器的计数寄存器以及标志位一起清零.并设置重装载值为最大,以最大限度的延长计时时间.//usmart_get_runtime,获取函数运行时间,通过读取CNT值获取,由于usmart是通过中断调用的函数,所以定时器中断不再有效,此时最大限度//只能统计2次CNT的值,也就是清零后+溢出一次,当溢出超过2次,没法处理,所以最大延时,控制在:2*计数器CNT*0.1ms.对STM32来说,是:13.1s左右//其他的:TIM4_IRQHandler和Timer2_Init,需要根据MCU特点自行修改.确保计数器计数频率为:10Khz即可.另外,定时器不要开启自动重装载功能!!#if USMART_ENTIMX_SCAN==1//复位runtime//需要根据所移植到的MCU的定时器参数进行修改void usmart_reset_runtime(void)&#123; TIM_ClearFlag(TIM4,TIM_FLAG_Update);//清除中断标志位 TIM_SetAutoreload(TIM4,0XFFFF);//将重装载值设置到最大 TIM_SetCounter(TIM4,0); //清空定时器的CNT usmart_dev.runtime=0; &#125;//获得runtime时间//返回值:执行时间,单位:0.1ms,最大延时时间为定时器CNT值的2倍*0.1ms//需要根据所移植到的MCU的定时器参数进行修改u32 usmart_get_runtime(void)&#123; if(TIM_GetFlagStatus(TIM4,TIM_FLAG_Update)==SET)//在运行期间,产生了定时器溢出 &#123; usmart_dev.runtime+=0XFFFF; &#125; usmart_dev.runtime+=TIM_GetCounter(TIM4); return usmart_dev.runtime; //返回计数值&#125;//下面这两个函数,非USMART函数,放到这里,仅仅方便移植. //定时器4中断服务程序 void TIM4_IRQHandler(void)&#123; if(TIM_GetITStatus(TIM4,TIM_IT_Update)==SET)//溢出中断 &#123; usmart_dev.scan(); //执行usmart扫描 TIM_SetCounter(TIM4,0); //清空定时器的CNT TIM_SetAutoreload(TIM4,100);//恢复原来的设置 &#125; TIM_ClearITPendingBit(TIM4,TIM_IT_Update); //清除中断标志位 &#125;//使能定时器4,使能中断.void Timer4_Init(u16 arr,u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE); //TIM4时钟使能 //TIM4初始化设置 TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值 计数到5000为500ms TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值 10Khz的计数频率 TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM向上计数模式 TIM_TimeBaseInit(TIM4, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位 TIM_ITConfig( TIM4, TIM_IT_Update|TIM_IT_Trigger, ENABLE );//TIM4 允许更新，触发中断 //TIM4中断分组配置 NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn; //TIM3中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; //先占优先级03级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //从优先级3级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 TIM_Cmd(TIM4, ENABLE); //使能TIM4 &#125;#endif//////////////////////////////////////////////////////////////////////////////////////////初始化串口控制器//sysclk:系统时钟（Mhz）void usmart_init(u8 sysclk)&#123;#if USMART_ENTIMX_SCAN==1 Timer4_Init(1000,(u32)sysclk*100-1);//分频,时钟为10K ,100ms中断一次,注意,计数频率必须为10Khz,以和runtime单位(0.1ms)同步.#endif usmart_dev.sptype=1; //十六进制显示参数&#125; //从str中获取函数名,id,及参数信息//*str:字符串指针.//返回值:0,识别成功;其他,错误代码.u8 usmart_cmd_rec(u8*str) &#123; u8 sta,i,rval;//状态 u8 rpnum,spnum; u8 rfname[MAX_FNAME_LEN];//暂存空间,用于存放接收到的函数名 u8 sfname[MAX_FNAME_LEN];//存放本地函数名 sta=usmart_get_fname(str,rfname,&amp;rpnum,&amp;rval);//得到接收到的数据的函数名及参数个数 if(sta)return sta;//错误 for(i=0;i&lt;usmart_dev.fnum;i++) &#123; sta=usmart_get_fname((u8*)usmart_dev.funs[i].name,sfname,&amp;spnum,&amp;rval);//得到本地函数名及参数个数 if(sta)return sta;//本地解析有误 if(usmart_strcmp(sfname,rfname)==0)//相等 &#123; if(spnum&gt;rpnum)return USMART_PARMERR;//参数错误(输入参数比源函数参数少) usmart_dev.id=i;//记录函数ID. break;//跳出. &#125; &#125; if(i==usmart_dev.fnum)return USMART_NOFUNCFIND; //未找到匹配的函数 sta=usmart_get_fparam(str,&amp;i); //得到函数参数个数 if(sta)return sta; //返回错误 usmart_dev.pnum=i; //参数个数记录 return USMART_OK;&#125;//usamrt执行函数//该函数用于最终执行从串口收到的有效函数.//最多支持10个参数的函数,更多的参数支持也很容易实现.不过用的很少.一般5个左右的参数的函数已经很少见了.//该函数会在串口打印执行情况.以:&quot;函数名(参数1，参数2...参数N)=返回值&quot;.的形式打印.//当所执行的函数没有返回值的时候,所打印的返回值是一个无意义的数据.void usmart_exe(void)&#123; u8 id,i; u32 res; u32 temp[MAX_PARM];//参数转换,使之支持了字符串 u8 sfname[MAX_FNAME_LEN];//存放本地函数名 u8 pnum,rval; id=usmart_dev.id; if(id&gt;=usmart_dev.fnum)return;//不执行. usmart_get_fname((u8*)usmart_dev.funs[id].name,sfname,&amp;pnum,&amp;rval);//得到本地函数名,及参数个数 printf(&quot;\\r\\n%s(&quot;,sfname);//输出正要执行的函数名 for(i=0;i&lt;pnum;i++)//输出参数 &#123; if(usmart_dev.parmtype&amp;(1&lt;&lt;i))//参数是字符串 &#123; printf(&quot;%c&quot;,&#x27;&quot;&#x27;); printf(&quot;%s&quot;,usmart_dev.parm+usmart_get_parmpos(i)); printf(&quot;%c&quot;,&#x27;&quot;&#x27;); temp[i]=(u32)&amp;(usmart_dev.parm[usmart_get_parmpos(i)]); &#125;else //参数是数字 &#123; temp[i]=*(u32*)(usmart_dev.parm+usmart_get_parmpos(i)); if(usmart_dev.sptype==SP_TYPE_DEC)printf(&quot;%lu&quot;,temp[i]);//10进制参数显示 else printf(&quot;0X%X&quot;,temp[i]);//16进制参数显示 &#125; if(i!=pnum-1)printf(&quot;,&quot;); &#125; printf(&quot;)&quot;); usmart_reset_runtime(); //计时器清零,开始计时 switch(usmart_dev.pnum) &#123; case 0://无参数(void类型) res=(*(u32(*)())usmart_dev.funs[id].func)(); break; case 1://有1个参数 res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0]); break; case 2://有2个参数 res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1]); break; case 3://有3个参数 res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2]); break; case 4://有4个参数 res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3]); break; case 5://有5个参数 res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4]); break; case 6://有6个参数 res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4],\\ temp[5]); break; case 7://有7个参数 res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4],\\ temp[5],temp[6]); break; case 8://有8个参数 res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4],\\ temp[5],temp[6],temp[7]); break; case 9://有9个参数 res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4],\\ temp[5],temp[6],temp[7],temp[8]); break; case 10://有10个参数 res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4],\\ temp[5],temp[6],temp[7],temp[8],temp[9]); break; &#125; usmart_get_runtime();//获取函数执行时间 if(rval==1)//需要返回值. &#123; if(usmart_dev.sptype==SP_TYPE_DEC)printf(&quot;=%lu;\\r\\n&quot;,res);//输出执行结果(10进制参数显示) else printf(&quot;=0X%X;\\r\\n&quot;,res);//输出执行结果(16进制参数显示) &#125;else printf(&quot;;\\r\\n&quot;); //不需要返回值,直接输出结束 if(usmart_dev.runtimeflag) //需要显示函数执行时间 &#123; printf(&quot;Function Run Time:%d.%1dms\\r\\n&quot;,usmart_dev.runtime/10,usmart_dev.runtime%10);//打印函数执行时间 &#125; &#125;//usmart扫描函数//通过调用该函数,实现usmart的各个控制.该函数需要每隔一定时间被调用一次//以及时执行从串口发过来的各个函数.//本函数可以在中断里面调用,从而实现自动管理.//如果非ALIENTEK用户,则USART_RX_STA和USART_RX_BUF[]需要用户自己实现void usmart_scan(void)&#123; u8 sta,len; if(USART_RX_STA&amp;0x8000)//串口接收完成？ &#123; len=USART_RX_STA&amp;0x3fff; //得到此次接收到的数据长度 USART_RX_BUF[len]=&#x27;\\0&#x27;; //在末尾加入结束符. sta=usmart_dev.cmd_rec(USART_RX_BUF);//得到函数各个信息 if(sta==0)usmart_dev.exe(); //执行函数 else &#123; len=usmart_sys_cmd_exe(USART_RX_BUF); if(len!=USMART_FUNCERR)sta=len; if(sta) &#123; switch(sta) &#123; case USMART_FUNCERR: printf(&quot;函数错误!\\r\\n&quot;); break; case USMART_PARMERR: printf(&quot;参数错误!\\r\\n&quot;); break; case USMART_PARMOVER: printf(&quot;参数太多!\\r\\n&quot;); break; case USMART_NOFUNCFIND: printf(&quot;未找到匹配的函数!\\r\\n&quot;); break; &#125; &#125; &#125; USART_RX_STA=0;//状态寄存器清空 &#125;&#125;#if USMART_USE_WRFUNS==1 //如果使能了读写操作//读取指定地址的值 u32 read_addr(u32 addr)&#123; return *(u32*)addr;// &#125;//在指定地址写入指定的值 void write_addr(u32 addr,u32 val)&#123; *(u32*)addr=val; &#125;#endif/******************* END OF FILE *********/ usmart.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// usmart.h#ifndef __USMART_H#define __USMART_H #include &quot;usmart_str.h&quot;//USMART资源占用情况@MDK 3.80A@2.0版本：//FLASH:4K~K字节(通过USMART_USE_HELP和USMART_USE_WRFUNS设置)//SRAM:72字节(最少的情况下)//SRAM计算公式: SRAM=PARM_LEN+72-4 其中PARM_LEN必须大于等于4.//应该保证堆栈不小于100个字节.////////////////////////////////////////////用户配置参数//////////////////////////////////////////////////// #define MAX_FNAME_LEN 30 //函数名最大长度，应该设置为不小于最长函数名的长度。 #define MAX_PARM 10 //最大为10个参数 ,修改此参数,必须修改usmart_exe与之对应.#define PARM_LEN 200 //所有参数之和的长度不超过PARM_LEN个字节,注意串口接收部分要与之对应(不小于PARM_LEN)#define USMART_ENTIMX_SCAN 1 //使用TIM的定时中断来扫描SCAN函数,如果设置为0,需要自己实现隔一段时间扫描一次scan函数. //注意:如果要用runtime统计功能,必须设置USMART_ENTIMX_SCAN为1!!!! #define USMART_USE_HELP 1 //使用帮助，该值设为0，可以节省近700个字节，但是将导致无法显示帮助信息。#define USMART_USE_WRFUNS 1 //使用读写函数,使能这里,可以读取任何地址的值,还可以写寄存器的值.///////////////////////////////////////////////END///////////////////////////////////////////////////////////#define USMART_OK 0 //无错误#define USMART_FUNCERR 1 //函数错误#define USMART_PARMERR 2 //参数错误#define USMART_PARMOVER 3 //参数溢出#define USMART_NOFUNCFIND 4 //未找到匹配函数#define SP_TYPE_DEC 0 //10进制参数显示#define SP_TYPE_HEX 1 //16进制参数显示 //函数名列表 struct _m_usmart_nametab&#123; void* func; //函数指针 const u8* name; //函数名(查找串) &#125;;//usmart控制管理器struct _m_usmart_dev&#123; struct _m_usmart_nametab *funs; //函数名指针 void (*init)(u8); //初始化 u8 (*cmd_rec)(u8*str); //识别函数名及参数 void (*exe)(void); //执行 void (*scan)(void); //扫描 u8 fnum; //函数数量 u8 pnum; //参数数量 u8 id; //函数id u8 sptype; //参数显示类型(非字符串参数):0,10进制;1,16进制; u16 parmtype; //参数的类型 u8 plentbl[MAX_PARM]; //每个参数的长度暂存表 u8 parm[PARM_LEN]; //函数的参数 u8 runtimeflag; //0,不统计函数执行时间;1,统计函数执行时间,注意:此功能必须在USMART_ENTIMX_SCAN使能的时候,才有用 u32 runtime; //运行时间,单位:0.1ms,最大延时时间为定时器CNT值的2倍*0.1ms&#125;;extern struct _m_usmart_nametab usmart_nametab[]; //在usmart_config.c里面定义extern struct _m_usmart_dev usmart_dev; //在usmart_config.c里面定义void usmart_init(u8 sysclk);//初始化u8 usmart_cmd_rec(u8*str); //识别void usmart_exe(void); //执行void usmart_scan(void); //扫描u32 read_addr(u32 addr); //读取指定地址的值void write_addr(u32 addr,u32 val);//在指定地址写入指定的值u32 usmart_get_runtime(void); //获取运行时间void usmart_reset_runtime(void);//复位运行时间#endif/******************* END OF FILE *********/ usmart_str.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358//usmart_str.c#include &quot;usmart_str.h&quot;#include &quot;usmart.h&quot; //对比字符串str1和str2//*str1:字符串1指针//*str2:字符串2指针//返回值:0，相等;1，不相等;u8 usmart_strcmp(u8 *str1,u8 *str2)&#123; while(1) &#123; if(*str1!=*str2)return 1;//不相等 if(*str1==&#x27;\\0&#x27;)break;//对比完成了. str1++; str2++; &#125; return 0;//两个字符串相等&#125;//把str1的内容copy到str2//*str1:字符串1指针//*str2:字符串2指针 void usmart_strcopy(u8*str1,u8 *str2)&#123; while(1) &#123; *str2=*str1; //拷贝 if(*str1==&#x27;\\0&#x27;)break;//拷贝完成了. str1++; str2++; &#125;&#125;//得到字符串的长度(字节)//*str:字符串指针//返回值:字符串的长度 u8 usmart_strlen(u8*str)&#123; u8 len=0; while(1) &#123; if(*str==&#x27;\\0&#x27;)break;//拷贝完成了. len++; str++; &#125; return len;&#125;//m^n函数//返回值:m^n次方u32 usmart_pow(u8 m,u8 n)&#123; u32 result=1; while(n--)result*=m; return result;&#125; //把字符串转为数字//支持16进制转换,但是16进制字母必须是大写的,且格式为以0X开头的.//不支持负数 //*str:数字字符串指针//*res:转换完的结果存放地址.//返回值:0，成功转换完成.其他,错误代码.//1,数据格式错误.2,16进制位数为0.3,起始格式错误.4,十进制位数为0.u8 usmart_str2num(u8*str,u32 *res)&#123; u32 t; u8 bnum=0; //数字的位数 u8 *p; u8 hexdec=10;//默认为十进制数据 p=str; *res=0;//清零. while(1) &#123; if((*p&lt;=&#x27;9&#x27;&amp;&amp;*p&gt;=&#x27;0&#x27;)||(*p&lt;=&#x27;F&#x27;&amp;&amp;*p&gt;=&#x27;A&#x27;)||(*p==&#x27;X&#x27;&amp;&amp;bnum==1))//参数合法 &#123; if(*p&gt;=&#x27;A&#x27;)hexdec=16; //字符串中存在字母,为16进制格式. bnum++; //位数增加. &#125;else if(*p==&#x27;\\0&#x27;)break; //碰到结束符,退出. else return 1; //不全是十进制或者16进制数据. p++; &#125; p=str; //重新定位到字符串开始的地址. if(hexdec==16) //16进制数据 &#123; if(bnum&lt;3)return 2; //位数小于3，直接退出.因为0X就占了2个,如果0X后面不跟数据,则该数据非法. if(*p==&#x27;0&#x27; &amp;&amp; (*(p+1)==&#x27;X&#x27;))//必须以&#x27;0X&#x27;开头. &#123; p+=2; //偏移到数据起始地址. bnum-=2;//减去偏移量 &#125;else return 3;//起始头的格式不对 &#125;else if(bnum==0)return 4;//位数为0，直接退出. while(1) &#123; if(bnum)bnum--; if(*p&lt;=&#x27;9&#x27;&amp;&amp;*p&gt;=&#x27;0&#x27;)t=*p-&#x27;0&#x27;; //得到数字的值 else t=*p-&#x27;A&#x27;+10; //得到A~F对应的值 *res+=t*usmart_pow(hexdec,bnum); p++; if(*p==&#x27;\\0&#x27;)break;//数据都查完了. &#125; return 0;//成功转换&#125;//得到指令名//*str:源字符串//*cmdname:指令名//*nlen:指令名长度 //maxlen:最大长度(做限制,指令不可能太长的) //返回值:0,成功;其他,失败. u8 usmart_get_cmdname(u8*str,u8*cmdname,u8 *nlen,u8 maxlen)&#123; *nlen=0; while(*str!=&#x27; &#x27;&amp;&amp;*str!=&#x27;\\0&#x27;) //找到空格或者结束符则认为结束了 &#123; *cmdname=*str; str++; cmdname++; (*nlen)++;//统计命令长度 if(*nlen&gt;=maxlen)return 1;//错误的指令 &#125; *cmdname=&#x27;\\0&#x27;;//加入结束符 return 0;//正常返回&#125;//获取下一个字符（当中间有很多空格的时候，此函数直接忽略空格，找到空格之后的第一个字符）//str:字符串指针 //返回值:下一个字符u8 usmart_search_nextc(u8* str)&#123; str++; while(*str==&#x27; &#x27;&amp;&amp;str!=&#x27;\\0&#x27;)str++; return *str;&#125; //从str中得到函数名//*str:源字符串指针//*fname:获取到的函数名字指针//*pnum:函数的参数个数//*rval:是否需要显示返回值(0,不需要;1,需要)//返回值:0,成功;其他,错误代码.u8 usmart_get_fname(u8*str,u8*fname,u8 *pnum,u8 *rval)&#123; u8 res; u8 fover=0; //括号深度 u8 *strtemp; u8 offset=0; u8 parmnum=0; u8 temp=1; u8 fpname[6];//void+X+&#x27;/0&#x27; u8 fplcnt=0; //第一个参数的长度计数器 u8 pcnt=0; //参数计数器 u8 nchar; //判断函数是否有返回值 strtemp=str; while(*strtemp!=&#x27;\\0&#x27;)//没有结束 &#123; if(*strtemp!=&#x27; &#x27;&amp;&amp;(pcnt&amp;0X7F)&lt;5)//最多记录5个字符 &#123; if(pcnt==0)pcnt|=0X80;//置位最高位,标记开始接收返回值类型 if(((pcnt&amp;0x7f)==4)&amp;&amp;(*strtemp!=&#x27;*&#x27;))break;//最后一个字符,必须是* fpname[pcnt&amp;0x7f]=*strtemp;//记录函数的返回值类型 pcnt++; &#125;else if(pcnt==0X85)break; strtemp++; &#125; if(pcnt)//接收完了 &#123; fpname[pcnt&amp;0x7f]=&#x27;\\0&#x27;;//加入结束符 if(usmart_strcmp(fpname,&quot;void&quot;)==0)*rval=0;//不需要返回值 else *rval=1; //需要返回值 pcnt=0; &#125; res=0; strtemp=str; while(*strtemp!=&#x27;(&#x27;&amp;&amp;*strtemp!=&#x27;\\0&#x27;) //此代码找到函数名的真正起始位置 &#123; strtemp++; res++; if(*strtemp==&#x27; &#x27;||*strtemp==&#x27;*&#x27;) &#123; nchar=usmart_search_nextc(strtemp); //获取下一个字符 if(nchar!=&#x27;(&#x27;&amp;&amp;nchar!=&#x27;*&#x27;)offset=res; //跳过空格和*号 &#125; &#125; strtemp=str; if(offset)strtemp+=offset+1;//跳到函数名开始的地方 res=0; nchar=0;//是否正在字符串里面的标志,0，不在字符串;1，在字符串; while(1) &#123; if(*strtemp==0) &#123; res=USMART_FUNCERR;//函数错误 break; &#125;else if(*strtemp==&#x27;(&#x27;&amp;&amp;nchar==0)fover++;//括号深度增加一级 else if(*strtemp==&#x27;)&#x27;&amp;&amp;nchar==0) &#123; if(fover)fover--; else res=USMART_FUNCERR;//错误结束,没收到&#x27;(&#x27; if(fover==0)break;//到末尾了,退出 &#125;else if(*strtemp==&#x27;&quot;&#x27;)nchar=!nchar; if(fover==0)//函数名还没接收完 &#123; if(*strtemp!=&#x27; &#x27;)//空格不属于函数名 &#123; *fname=*strtemp;//得到函数名 fname++; &#125; &#125;else //已经接受完了函数名了. &#123; if(*strtemp==&#x27;,&#x27;) &#123; temp=1; //使能增加一个参数 pcnt++; &#125;else if(*strtemp!=&#x27; &#x27;&amp;&amp;*strtemp!=&#x27;(&#x27;) &#123; if(pcnt==0&amp;&amp;fplcnt&lt;5) //当第一个参数来时,为了避免统计void类型的参数,必须做判断. &#123; fpname[fplcnt]=*strtemp;//记录参数特征. fplcnt++; &#125; temp++; //得到有效参数(非空格) &#125; if(fover==1&amp;&amp;temp==2) &#123; temp++; //防止重复增加 parmnum++; //参数增加一个 &#125; &#125; strtemp++; &#125; if(parmnum==1)//只有1个参数. &#123; fpname[fplcnt]=&#x27;\\0&#x27;;//加入结束符 if(usmart_strcmp(fpname,&quot;void&quot;)==0)parmnum=0;//参数为void,表示没有参数. &#125; *pnum=parmnum; //记录参数个数 *fname=&#x27;\\0&#x27;; //加入结束符 return res; //返回执行结果&#125;//从str中得到一个函数的参数//*str:源字符串指针//*fparm:参数字符串指针//*ptype:参数类型 0，数字;1，字符串;0XFF，参数错误//返回值:0,已经无参数了;其他,下一个参数的偏移量.u8 usmart_get_aparm(u8 *str,u8 *fparm,u8 *ptype)&#123; u8 i=0; u8 enout=0; u8 type=0;//默认是数字 u8 string=0; //标记str是否正在读 while(1) &#123; if(*str==&#x27;,&#x27;&amp;&amp; string==0)enout=1; //暂缓立即退出,目的是寻找下一个参数的起始地址 if((*str==&#x27;)&#x27;||*str==&#x27;\\0&#x27;)&amp;&amp;string==0)break;//立即退出标识符 if(type==0)//默认是数字的 &#123; if((*str&gt;=&#x27;0&#x27; &amp;&amp; *str&lt;=&#x27;9&#x27;)||(*str&gt;=&#x27;a&#x27; &amp;&amp; *str&lt;=&#x27;f&#x27;)||(*str&gt;=&#x27;A&#x27; &amp;&amp; *str&lt;=&#x27;F&#x27;)||*str==&#x27;X&#x27;||*str==&#x27;x&#x27;)//数字串检测 &#123; if(enout)break; //找到了下一个参数,直接退出. if(*str&gt;=&#x27;a&#x27;)*fparm=*str-0X20; //小写转换为大写 else *fparm=*str; //小写或者数字保持不变 fparm++; &#125;else if(*str==&#x27;&quot;&#x27;)//找到字符串的开始标志 &#123; if(enout)break;//找到,后才找到&quot;,认为结束了. type=1; string=1;//登记STRING 正在读了 &#125;else if(*str!=&#x27; &#x27;&amp;&amp;*str!=&#x27;,&#x27;)//发现非法字符,参数错误 &#123; type=0XFF; break; &#125; &#125;else//string类 &#123; if(*str==&#x27;&quot;&#x27;)string=0; if(enout)break; //找到了下一个参数,直接退出. if(string) //字符串正在读 &#123; if(*str==&#x27;\\\\&#x27;) //遇到转义符(不复制转义符) &#123; str++; //偏移到转义符后面的字符,不管什么字符,直接COPY i++; &#125; *fparm=*str; //小写或者数字保持不变 fparm++; &#125; &#125; i++;//偏移量增加 str++; &#125; *fparm=&#x27;\\0&#x27;; //加入结束符 *ptype=type; //返回参数类型 return i; //返回参数长度&#125;//得到指定参数的起始地址//num:第num个参数,范围0~9.//返回值:该参数的起始地址u8 usmart_get_parmpos(u8 num)&#123; u8 temp=0; u8 i; for(i=0;i&lt;num;i++)temp+=usmart_dev.plentbl[i]; return temp;&#125;//从str中得到函数参数//str:源字符串;//parn:参数的多少.0表示无参数 void类型//返回值:0,成功;其他,错误代码.u8 usmart_get_fparam(u8*str,u8 *parn)&#123; u8 i,type; u32 res; u8 n=0; u8 len; u8 tstr[PARM_LEN+1];//字节长度的缓存,最多可以存放PARM_LEN个字符的字符串 for(i=0;i&lt;MAX_PARM;i++)usmart_dev.plentbl[i]=0;//清空参数长度表 while(*str!=&#x27;(&#x27;)//偏移到参数开始的地方 &#123; str++; if(*str==&#x27;\\0&#x27;)return USMART_FUNCERR;//遇到结束符了 &#125; str++;//偏移到&quot;(&quot;之后的第一个字节 while(1) &#123; i=usmart_get_aparm(str,tstr,&amp;type); //得到第一个参数 str+=i; //偏移 switch(type) &#123; case 0: //数字 if(tstr[0]!=&#x27;\\0&#x27;) //接收到的参数有效 &#123; i=usmart_str2num(tstr,&amp;res); //记录该参数 if(i)return USMART_PARMERR; //参数错误. *(u32*)(usmart_dev.parm+usmart_get_parmpos(n))=res;//记录转换成功的结果. usmart_dev.parmtype&amp;=~(1&lt;&lt;n); //标记数字 usmart_dev.plentbl[n]=4; //该参数的长度为4 n++; //参数增加 if(n&gt;MAX_PARM)return USMART_PARMOVER;//参数太多 &#125; break; case 1://字符串 len=usmart_strlen(tstr)+1; //包含了结束符&#x27;\\0&#x27; usmart_strcopy(tstr,&amp;usmart_dev.parm[usmart_get_parmpos(n)]);//拷贝tstr数据到usmart_dev.parm[n] usmart_dev.parmtype|=1&lt;&lt;n; //标记字符串 usmart_dev.plentbl[n]=len; //该参数的长度为len n++; if(n&gt;MAX_PARM)return USMART_PARMOVER;//参数太多 break; case 0XFF://错误 return USMART_PARMERR;//参数错误 &#125; if(*str==&#x27;)&#x27;||*str==&#x27;\\0&#x27;)break;//查到结束标志了. &#125; *parn=n; //记录参数的个数 return USMART_OK;//正确得到了参数&#125;/******************* END OF FILE *********/ usmart_str.h 1234567891011121314151617//usmart_str.h#ifndef __USMART_STR_H#define __USMART_STR_H #include &quot;stm32f10x.h&quot;u8 usmart_get_parmpos(u8 num); //得到某个参数在参数列里面的起始位置u8 usmart_strcmp(u8*str1,u8 *str2); //对比两个字符串是否相等u32 usmart_pow(u8 m,u8 n); //M^N次方u8 usmart_str2num(u8*str,u32 *res); //字符串转为数字u8 usmart_get_cmdname(u8*str,u8*cmdname,u8 *nlen,u8 maxlen);//从str中得到指令名,并返回指令长度u8 usmart_get_fname(u8*str,u8*fname,u8 *pnum,u8 *rval); //从str中得到函数名u8 usmart_get_aparm(u8 *str,u8 *fparm,u8 *ptype); //从str中得到一个函数参数u8 usmart_get_fparam(u8*str,u8 *parn); //得到str中所有的函数参数.#endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031323334353637383940414243//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;lcd.h&quot;#include &quot;usart.h&quot; #include &quot;usmart.h&quot; //LED状态设置函数void led_set(u8 sta)&#123; LED1=sta;&#125; //函数参数调用测试函数void test_fun(void(*ledset)(u8),u8 sta)&#123; ledset(sta);&#125; int main(void) &#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 LCD_Init(); usmart_dev.init(SystemCoreClock/1000000); //初始化USMART POINT_COLOR=RED; LCD_ShowString(30,50,200,16,16,&quot;ELITE STM32 ^_^&quot;); LCD_ShowString(30,70,200,16,16,&quot;USMART TEST&quot;); LCD_ShowString(30,90,200,16,16,&quot;ATOM@ALIENTEK&quot;); LCD_ShowString(30,110,200,16,16,&quot;2015/1/14&quot;); while(1) &#123; LED0=!LED0; delay_ms(500); &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 代码片段分析 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（13）TFTLCD显示","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-013","date":"2022-11-08T03:19:18.000Z","updated":"2023-04-05T14:19:54.949Z","comments":true,"path":"posts/802121758.html","link":"","permalink":"https://sirius-blog.github.io/posts/802121758.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 beep output PB8 LED0驱动 思路 调用官方库文件驱动GPIO口。 驱动 lcd.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392239323942395239623972398239924002401240224032404240524062407240824092410241124122413241424152416241724182419242024212422242324242425242624272428242924302431243224332434243524362437243824392440244124422443244424452446244724482449245024512452245324542455245624572458245924602461246224632464246524662467246824692470247124722473247424752476247724782479248024812482248324842485248624872488248924902491249224932494249524962497249824992500250125022503250425052506250725082509251025112512251325142515251625172518251925202521252225232524252525262527252825292530253125322533253425352536253725382539254025412542254325442545254625472548254925502551255225532554255525562557255825592560256125622563256425652566256725682569257025712572257325742575257625772578257925802581258225832584258525862587258825892590259125922593259425952596259725982599260026012602260326042605260626072608260926102611261226132614261526162617261826192620262126222623262426252626262726282629263026312632263326342635263626372638263926402641264226432644264526462647264826492650265126522653265426552656265726582659266026612662266326642665266626672668266926702671267226732674267526762677267826792680268126822683268426852686268726882689269026912692269326942695269626972698269927002701270227032704270527062707270827092710271127122713271427152716271727182719272027212722272327242725272627272728272927302731273227332734273527362737273827392740274127422743274427452746274727482749275027512752275327542755275627572758275927602761276227632764276527662767276827692770277127722773277427752776277727782779278027812782278327842785278627872788278927902791279227932794279527962797279827992800280128022803280428052806280728082809281028112812281328142815281628172818281928202821282228232824282528262827282828292830283128322833// lcd.c#include &quot;lcd.h&quot;#include &quot;stdlib.h&quot;#include &quot;font.h&quot; #include &quot;usart.h&quot; #include &quot;delay.h&quot; //LCD的画笔颜色和背景色 u16 POINT_COLOR=0x0000; //画笔颜色u16 BACK_COLOR=0xFFFF; //背景色 //管理LCD重要参数//默认为竖屏_lcd_dev lcddev; //写寄存器函数//regval:寄存器值void LCD_WR_REG(u16 regval)&#123; LCD-&gt;LCD_REG=regval;//写入要写的寄存器序号 &#125;//写LCD数据//data:要写入的值void LCD_WR_DATA(u16 data)&#123; LCD-&gt;LCD_RAM=data; &#125;//读LCD数据//返回值:读到的值u16 LCD_RD_DATA(void)&#123; vu16 ram; //防止被优化 ram=LCD-&gt;LCD_RAM; return ram; &#125; //写寄存器//LCD_Reg:寄存器地址//LCD_RegValue:要写入的数据void LCD_WriteReg(u16 LCD_Reg,u16 LCD_RegValue)&#123; LCD-&gt;LCD_REG = LCD_Reg; //写入要写的寄存器序号 LCD-&gt;LCD_RAM = LCD_RegValue;//写入数据 &#125; //读寄存器//LCD_Reg:寄存器地址//返回值:读到的数据u16 LCD_ReadReg(u16 LCD_Reg)&#123; LCD_WR_REG(LCD_Reg); //写入要读的寄存器序号 delay_us(5); return LCD_RD_DATA(); //返回读到的值&#125; //开始写GRAMvoid LCD_WriteRAM_Prepare(void)&#123; LCD-&gt;LCD_REG=lcddev.wramcmd; &#125; //LCD写GRAM//RGB_Code:颜色值void LCD_WriteRAM(u16 RGB_Code)&#123; LCD-&gt;LCD_RAM = RGB_Code;//写十六位GRAM&#125;//从ILI93xx读出的数据为GBR格式，而我们写入的时候为RGB格式。//通过该函数转换//c:GBR格式的颜色值//返回值：RGB格式的颜色值u16 LCD_BGR2RGB(u16 c)&#123; u16 r,g,b,rgb; b=(c&gt;&gt;0)&amp;0x1f; g=(c&gt;&gt;5)&amp;0x3f; r=(c&gt;&gt;11)&amp;0x1f; rgb=(b&lt;&lt;11)+(g&lt;&lt;5)+(r&lt;&lt;0); return(rgb);&#125; //当mdk -O1时间优化时需要设置//延时ivoid opt_delay(u8 i)&#123; while(i--);&#125;//读取个某点的颜色值 //x,y:坐标//返回值:此点的颜色u16 LCD_ReadPoint(u16 x,u16 y)&#123; u16 r=0,g=0,b=0; if(x&gt;=lcddev.width||y&gt;=lcddev.height)return 0; //超过了范围,直接返回 LCD_SetCursor(x,y); if(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X1963)LCD_WR_REG(0X2E);//9341/6804/3510/1963 发送读GRAM指令 else if(lcddev.id==0X5510)LCD_WR_REG(0X2E00); //5510 发送读GRAM指令 else LCD_WR_REG(0X22); //其他IC发送读GRAM指令 if(lcddev.id==0X9320)opt_delay(2); //FOR 9320,延时2us r=LCD_RD_DATA(); //dummy Read if(lcddev.id==0X1963)return r; //1963直接读就可以 opt_delay(2); r=LCD_RD_DATA(); //实际坐标颜色 if(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X5510) //9341/NT35310/NT35510要分2次读出 &#123; opt_delay(2); b=LCD_RD_DATA(); g=r&amp;0XFF; //对于9341/5310/5510,第一次读取的是RG的值,R在前,G在后,各占8位 g&lt;&lt;=8; &#125; if(lcddev.id==0X9325||lcddev.id==0X4535||lcddev.id==0X4531||lcddev.id==0XB505||lcddev.id==0XC505)return r; //这几种IC直接返回颜色值 else if(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X5510)return (((r&gt;&gt;11)&lt;&lt;11)|((g&gt;&gt;10)&lt;&lt;5)|(b&gt;&gt;11));//ILI9341/NT35310/NT35510需要公式转换一下 else return LCD_BGR2RGB(r); //其他IC&#125; //LCD开启显示void LCD_DisplayOn(void)&#123; if(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X1963)LCD_WR_REG(0X29); //开启显示 else if(lcddev.id==0X5510)LCD_WR_REG(0X2900); //开启显示 else LCD_WriteReg(0X07,0x0173); //开启显示&#125; //LCD关闭显示void LCD_DisplayOff(void)&#123; if(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X1963)LCD_WR_REG(0X28); //关闭显示 else if(lcddev.id==0X5510)LCD_WR_REG(0X2800); //关闭显示 else LCD_WriteReg(0X07,0x0);//关闭显示 &#125; //设置光标位置//Xpos:横坐标//Ypos:纵坐标void LCD_SetCursor(u16 Xpos, u16 Ypos)&#123; if(lcddev.id==0X9341||lcddev.id==0X5310) &#123; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(Xpos&gt;&gt;8);LCD_WR_DATA(Xpos&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(Ypos&gt;&gt;8);LCD_WR_DATA(Ypos&amp;0XFF); &#125;else if(lcddev.id==0X6804) &#123; if(lcddev.dir==1)Xpos=lcddev.width-1-Xpos;//横屏时处理 LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(Xpos&gt;&gt;8);LCD_WR_DATA(Xpos&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(Ypos&gt;&gt;8);LCD_WR_DATA(Ypos&amp;0XFF); &#125;else if(lcddev.id==0X1963) &#123; if(lcddev.dir==0)//x坐标需要变换 &#123; Xpos=lcddev.width-1-Xpos; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(0);LCD_WR_DATA(0); LCD_WR_DATA(Xpos&gt;&gt;8);LCD_WR_DATA(Xpos&amp;0XFF); &#125;else &#123; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(Xpos&gt;&gt;8);LCD_WR_DATA(Xpos&amp;0XFF); LCD_WR_DATA((lcddev.width-1)&gt;&gt;8);LCD_WR_DATA((lcddev.width-1)&amp;0XFF); &#125; LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(Ypos&gt;&gt;8);LCD_WR_DATA(Ypos&amp;0XFF); LCD_WR_DATA((lcddev.height-1)&gt;&gt;8);LCD_WR_DATA((lcddev.height-1)&amp;0XFF); &#125;else if(lcddev.id==0X5510) &#123; LCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(Xpos&gt;&gt;8); LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(Xpos&amp;0XFF); LCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(Ypos&gt;&gt;8); LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(Ypos&amp;0XFF); &#125;else &#123; if(lcddev.dir==1)Xpos=lcddev.width-1-Xpos;//横屏其实就是调转x,y坐标 LCD_WriteReg(lcddev.setxcmd, Xpos); LCD_WriteReg(lcddev.setycmd, Ypos); &#125; &#125; //设置LCD的自动扫描方向//注意:其他函数可能会受到此函数设置的影响(尤其是9341/6804这两个奇葩),//所以,一般设置为L2R_U2D即可,如果设置为其他扫描方式,可能导致显示不正常.//dir:0~7,代表8个方向(具体定义见lcd.h)//9320/9325/9328/4531/4535/1505/b505/5408/9341/5310/5510/1963等IC已经实际测试 void LCD_Scan_Dir(u8 dir)&#123; u16 regval=0; u16 dirreg=0; u16 temp; if((lcddev.dir==1&amp;&amp;lcddev.id!=0X6804&amp;&amp;lcddev.id!=0X1963)||(lcddev.dir==0&amp;&amp;lcddev.id==0X1963))//横屏时，对6804和1963不改变扫描方向！竖屏时1963改变方向 &#123; switch(dir)//方向转换 &#123; case 0:dir=6;break; case 1:dir=7;break; case 2:dir=4;break; case 3:dir=5;break; case 4:dir=1;break; case 5:dir=0;break; case 6:dir=3;break; case 7:dir=2;break; &#125; &#125; if(lcddev.id==0x9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X5510||lcddev.id==0X1963)//9341/6804/5310/5510/1963,特殊处理 &#123; switch(dir) &#123; case L2R_U2D://从左到右,从上到下 regval|=(0&lt;&lt;7)|(0&lt;&lt;6)|(0&lt;&lt;5); break; case L2R_D2U://从左到右,从下到上 regval|=(1&lt;&lt;7)|(0&lt;&lt;6)|(0&lt;&lt;5); break; case R2L_U2D://从右到左,从上到下 regval|=(0&lt;&lt;7)|(1&lt;&lt;6)|(0&lt;&lt;5); break; case R2L_D2U://从右到左,从下到上 regval|=(1&lt;&lt;7)|(1&lt;&lt;6)|(0&lt;&lt;5); break; case U2D_L2R://从上到下,从左到右 regval|=(0&lt;&lt;7)|(0&lt;&lt;6)|(1&lt;&lt;5); break; case U2D_R2L://从上到下,从右到左 regval|=(0&lt;&lt;7)|(1&lt;&lt;6)|(1&lt;&lt;5); break; case D2U_L2R://从下到上,从左到右 regval|=(1&lt;&lt;7)|(0&lt;&lt;6)|(1&lt;&lt;5); break; case D2U_R2L://从下到上,从右到左 regval|=(1&lt;&lt;7)|(1&lt;&lt;6)|(1&lt;&lt;5); break; &#125; if(lcddev.id==0X5510)dirreg=0X3600; else dirreg=0X36; if((lcddev.id!=0X5310)&amp;&amp;(lcddev.id!=0X5510)&amp;&amp;(lcddev.id!=0X1963))regval|=0X08;//5310/5510/1963不需要BGR if(lcddev.id==0X6804)regval|=0x02;//6804的BIT6和9341的反了 LCD_WriteReg(dirreg,regval); if(lcddev.id!=0X1963)//1963不做坐标处理 &#123; if(regval&amp;0X20) &#123; if(lcddev.width&lt;lcddev.height)//交换X,Y &#123; temp=lcddev.width; lcddev.width=lcddev.height; lcddev.height=temp; &#125; &#125;else &#123; if(lcddev.width&gt;lcddev.height)//交换X,Y &#123; temp=lcddev.width; lcddev.width=lcddev.height; lcddev.height=temp; &#125; &#125; &#125; if(lcddev.id==0X5510) &#123; LCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(0); LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(0); LCD_WR_REG(lcddev.setxcmd+2);LCD_WR_DATA((lcddev.width-1)&gt;&gt;8); LCD_WR_REG(lcddev.setxcmd+3);LCD_WR_DATA((lcddev.width-1)&amp;0XFF); LCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(0); LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(0); LCD_WR_REG(lcddev.setycmd+2);LCD_WR_DATA((lcddev.height-1)&gt;&gt;8); LCD_WR_REG(lcddev.setycmd+3);LCD_WR_DATA((lcddev.height-1)&amp;0XFF); &#125;else &#123; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(0);LCD_WR_DATA(0); LCD_WR_DATA((lcddev.width-1)&gt;&gt;8);LCD_WR_DATA((lcddev.width-1)&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(0);LCD_WR_DATA(0); LCD_WR_DATA((lcddev.height-1)&gt;&gt;8);LCD_WR_DATA((lcddev.height-1)&amp;0XFF); &#125; &#125;else &#123; switch(dir) &#123; case L2R_U2D://从左到右,从上到下 regval|=(1&lt;&lt;5)|(1&lt;&lt;4)|(0&lt;&lt;3); break; case L2R_D2U://从左到右,从下到上 regval|=(0&lt;&lt;5)|(1&lt;&lt;4)|(0&lt;&lt;3); break; case R2L_U2D://从右到左,从上到下 regval|=(1&lt;&lt;5)|(0&lt;&lt;4)|(0&lt;&lt;3); break; case R2L_D2U://从右到左,从下到上 regval|=(0&lt;&lt;5)|(0&lt;&lt;4)|(0&lt;&lt;3); break; case U2D_L2R://从上到下,从左到右 regval|=(1&lt;&lt;5)|(1&lt;&lt;4)|(1&lt;&lt;3); break; case U2D_R2L://从上到下,从右到左 regval|=(1&lt;&lt;5)|(0&lt;&lt;4)|(1&lt;&lt;3); break; case D2U_L2R://从下到上,从左到右 regval|=(0&lt;&lt;5)|(1&lt;&lt;4)|(1&lt;&lt;3); break; case D2U_R2L://从下到上,从右到左 regval|=(0&lt;&lt;5)|(0&lt;&lt;4)|(1&lt;&lt;3); break; &#125; dirreg=0X03; regval|=1&lt;&lt;12; LCD_WriteReg(dirreg,regval); &#125;&#125; //画点//x,y:坐标//POINT_COLOR:此点的颜色void LCD_DrawPoint(u16 x,u16 y)&#123; LCD_SetCursor(x,y); //设置光标位置 LCD_WriteRAM_Prepare(); //开始写入GRAM LCD-&gt;LCD_RAM=POINT_COLOR; &#125;//快速画点//x,y:坐标//color:颜色void LCD_Fast_DrawPoint(u16 x,u16 y,u16 color)&#123; if(lcddev.id==0X9341||lcddev.id==0X5310) &#123; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(x&gt;&gt;8);LCD_WR_DATA(x&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(y&gt;&gt;8);LCD_WR_DATA(y&amp;0XFF); &#125;else if(lcddev.id==0X5510) &#123; LCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(x&gt;&gt;8); LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(x&amp;0XFF); LCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(y&gt;&gt;8); LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(y&amp;0XFF); &#125;else if(lcddev.id==0X1963) &#123; if(lcddev.dir==0)x=lcddev.width-1-x; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(x&gt;&gt;8);LCD_WR_DATA(x&amp;0XFF); LCD_WR_DATA(x&gt;&gt;8);LCD_WR_DATA(x&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(y&gt;&gt;8);LCD_WR_DATA(y&amp;0XFF); LCD_WR_DATA(y&gt;&gt;8);LCD_WR_DATA(y&amp;0XFF); &#125;else if(lcddev.id==0X6804) &#123; if(lcddev.dir==1)x=lcddev.width-1-x;//横屏时处理 LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(x&gt;&gt;8);LCD_WR_DATA(x&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(y&gt;&gt;8);LCD_WR_DATA(y&amp;0XFF); &#125;else &#123; if(lcddev.dir==1)x=lcddev.width-1-x;//横屏其实就是调转x,y坐标 LCD_WriteReg(lcddev.setxcmd,x); LCD_WriteReg(lcddev.setycmd,y); &#125; LCD-&gt;LCD_REG=lcddev.wramcmd; LCD-&gt;LCD_RAM=color; &#125; //SSD1963 背光设置//pwm:背光等级,0~100.越大越亮.void LCD_SSD_BackLightSet(u8 pwm)&#123; LCD_WR_REG(0xBE); //配置PWM输出 LCD_WR_DATA(0x05); //1设置PWM频率 LCD_WR_DATA(pwm*2.55);//2设置PWM占空比 LCD_WR_DATA(0x01); //3设置C LCD_WR_DATA(0xFF); //4设置D LCD_WR_DATA(0x00); //5设置E LCD_WR_DATA(0x00); //6设置F&#125;//设置LCD显示方向//dir:0,竖屏；1,横屏void LCD_Display_Dir(u8 dir)&#123; if(dir==0) //竖屏 &#123; lcddev.dir=0; //竖屏 lcddev.width=240; lcddev.height=320; if(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310) &#123; lcddev.wramcmd=0X2C; lcddev.setxcmd=0X2A; lcddev.setycmd=0X2B; if(lcddev.id==0X6804||lcddev.id==0X5310) &#123; lcddev.width=320; lcddev.height=480; &#125; &#125;else if(lcddev.id==0x5510) &#123; lcddev.wramcmd=0X2C00; lcddev.setxcmd=0X2A00; lcddev.setycmd=0X2B00; lcddev.width=480; lcddev.height=800; &#125;else if(lcddev.id==0X1963) &#123; lcddev.wramcmd=0X2C; //设置写入GRAM的指令 lcddev.setxcmd=0X2B; //设置写X坐标指令 lcddev.setycmd=0X2A; //设置写Y坐标指令 lcddev.width=480; //设置宽度480 lcddev.height=800; //设置高度800 &#125;else &#123; lcddev.wramcmd=0X22; lcddev.setxcmd=0X20; lcddev.setycmd=0X21; &#125; &#125;else //横屏 &#123; lcddev.dir=1; //横屏 lcddev.width=320; lcddev.height=240; if(lcddev.id==0X9341||lcddev.id==0X5310) &#123; lcddev.wramcmd=0X2C; lcddev.setxcmd=0X2A; lcddev.setycmd=0X2B; &#125;else if(lcddev.id==0X6804) &#123; lcddev.wramcmd=0X2C; lcddev.setxcmd=0X2B; lcddev.setycmd=0X2A; &#125;else if(lcddev.id==0x5510) &#123; lcddev.wramcmd=0X2C00; lcddev.setxcmd=0X2A00; lcddev.setycmd=0X2B00; lcddev.width=800; lcddev.height=480; &#125;else if(lcddev.id==0X1963) &#123; lcddev.wramcmd=0X2C; //设置写入GRAM的指令 lcddev.setxcmd=0X2A; //设置写X坐标指令 lcddev.setycmd=0X2B; //设置写Y坐标指令 lcddev.width=800; //设置宽度800 lcddev.height=480; //设置高度480 &#125;else &#123; lcddev.wramcmd=0X22; lcddev.setxcmd=0X21; lcddev.setycmd=0X20; &#125; if(lcddev.id==0X6804||lcddev.id==0X5310) &#123; lcddev.width=480; lcddev.height=320; &#125; &#125; LCD_Scan_Dir(DFT_SCAN_DIR); //默认扫描方向&#125; //设置窗口,并自动设置画点坐标到窗口左上角(sx,sy).//sx,sy:窗口起始坐标(左上角)//width,height:窗口宽度和高度,必须大于0!!//窗体大小:width*height. void LCD_Set_Window(u16 sx,u16 sy,u16 width,u16 height)&#123; u8 hsareg,heareg,vsareg,veareg; u16 hsaval,heaval,vsaval,veaval; u16 twidth,theight; twidth=sx+width-1; theight=sy+height-1; if(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X6804||(lcddev.dir==1&amp;&amp;lcddev.id==0X1963)) &#123; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(sx&gt;&gt;8); LCD_WR_DATA(sx&amp;0XFF); LCD_WR_DATA(twidth&gt;&gt;8); LCD_WR_DATA(twidth&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(sy&gt;&gt;8); LCD_WR_DATA(sy&amp;0XFF); LCD_WR_DATA(theight&gt;&gt;8); LCD_WR_DATA(theight&amp;0XFF); &#125;else if(lcddev.id==0X1963)//1963竖屏特殊处理 &#123; sx=lcddev.width-width-sx; height=sy+height-1; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(sx&gt;&gt;8); LCD_WR_DATA(sx&amp;0XFF); LCD_WR_DATA((sx+width-1)&gt;&gt;8); LCD_WR_DATA((sx+width-1)&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(sy&gt;&gt;8); LCD_WR_DATA(sy&amp;0XFF); LCD_WR_DATA(height&gt;&gt;8); LCD_WR_DATA(height&amp;0XFF); &#125;else if(lcddev.id==0X5510) &#123; LCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(sx&gt;&gt;8); LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(sx&amp;0XFF); LCD_WR_REG(lcddev.setxcmd+2);LCD_WR_DATA(twidth&gt;&gt;8); LCD_WR_REG(lcddev.setxcmd+3);LCD_WR_DATA(twidth&amp;0XFF); LCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(sy&gt;&gt;8); LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(sy&amp;0XFF); LCD_WR_REG(lcddev.setycmd+2);LCD_WR_DATA(theight&gt;&gt;8); LCD_WR_REG(lcddev.setycmd+3);LCD_WR_DATA(theight&amp;0XFF); &#125;else //其他驱动IC &#123; if(lcddev.dir==1)//横屏 &#123; //窗口值 hsaval=sy; heaval=theight; vsaval=lcddev.width-twidth-1; veaval=lcddev.width-sx-1; &#125;else &#123; hsaval=sx; heaval=twidth; vsaval=sy; veaval=theight; &#125; hsareg=0X50;heareg=0X51;//水平方向窗口寄存器 vsareg=0X52;veareg=0X53;//垂直方向窗口寄存器 //设置寄存器值 LCD_WriteReg(hsareg,hsaval); LCD_WriteReg(heareg,heaval); LCD_WriteReg(vsareg,vsaval); LCD_WriteReg(veareg,veaval); LCD_SetCursor(sx,sy); //设置光标位置 &#125;&#125;//初始化lcd//该初始化函数可以初始化各种ILI93XX液晶,但是其他函数是基于ILI9320的!!!//在其他型号的驱动芯片上没有测试! void LCD_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; FSMC_NORSRAMInitTypeDef FSMC_NORSRAMInitStructure; FSMC_NORSRAMTimingInitTypeDef readWriteTiming; FSMC_NORSRAMTimingInitTypeDef writeTiming; RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC,ENABLE); //使能FSMC时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOE|RCC_APB2Periph_GPIOG,ENABLE);//使能PORTB,D,E,G以及AFIO复用功能时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; //PB0 推挽输出 背光 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //PORTD复用推挽输出 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_14|GPIO_Pin_15; // //PORTD复用推挽输出 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); //PORTE复用推挽输出 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15; // //PORTD复用推挽输出 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOE, &amp;GPIO_InitStructure); // //PORTG12复用推挽输出 A0 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_12; // //PORTD复用推挽输出 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOG, &amp;GPIO_InitStructure); readWriteTiming.FSMC_AddressSetupTime = 0x01; //地址建立时间（ADDSET）为2个HCLK 1/36M=27ns readWriteTiming.FSMC_AddressHoldTime = 0x00; //地址保持时间（ADDHLD）模式A未用到 readWriteTiming.FSMC_DataSetupTime = 0x0f; // 数据保存时间为16个HCLK,因为液晶驱动IC的读数据的时候，速度不能太快，尤其对1289这个IC。 readWriteTiming.FSMC_BusTurnAroundDuration = 0x00; readWriteTiming.FSMC_CLKDivision = 0x00; readWriteTiming.FSMC_DataLatency = 0x00; readWriteTiming.FSMC_AccessMode = FSMC_AccessMode_A; //模式A writeTiming.FSMC_AddressSetupTime = 0x00; //地址建立时间（ADDSET）为1个HCLK writeTiming.FSMC_AddressHoldTime = 0x00; //地址保持时间（A writeTiming.FSMC_DataSetupTime = 0x03; ////数据保存时间为4个HCLK writeTiming.FSMC_BusTurnAroundDuration = 0x00; writeTiming.FSMC_CLKDivision = 0x00; writeTiming.FSMC_DataLatency = 0x00; writeTiming.FSMC_AccessMode = FSMC_AccessMode_A; //模式A FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM4;// 这里我们使用NE4 ，也就对应BTCR[6],[7]。 FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable; // 不复用数据地址 FSMC_NORSRAMInitStructure.FSMC_MemoryType =FSMC_MemoryType_SRAM;// FSMC_MemoryType_SRAM; //SRAM FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;//存储器数据宽度为16bit FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode =FSMC_BurstAccessMode_Disable;// FSMC_BurstAccessMode_Disable; FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low; FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait=FSMC_AsynchronousWait_Disable; FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable; FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState; FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable; // 存储器写使能 FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable; FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Enable; // 读写使用不同的时序 FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable; FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &amp;readWriteTiming; //读写时序 FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &amp;writeTiming; //写时序 FSMC_NORSRAMInit(&amp;FSMC_NORSRAMInitStructure); //初始化FSMC配置 FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE); // 使能BANK1 delay_ms(50); // delay 50 ms lcddev.id=LCD_ReadReg(0x0000); //读ID（9320/9325/9328/4531/4535等IC） if(lcddev.id&lt;0XFF||lcddev.id==0XFFFF||lcddev.id==0X9300)//读到ID不正确,新增lcddev.id==0X9300判断，因为9341在未被复位的情况下会被读成9300 &#123; //尝试9341 ID的读取 LCD_WR_REG(0XD3); lcddev.id=LCD_RD_DATA(); //dummy read lcddev.id=LCD_RD_DATA(); //读到0X00 lcddev.id=LCD_RD_DATA(); //读取93 lcddev.id&lt;&lt;=8; lcddev.id|=LCD_RD_DATA(); //读取41 if(lcddev.id!=0X9341) //非9341,尝试是不是6804 &#123; LCD_WR_REG(0XBF); lcddev.id=LCD_RD_DATA(); //dummy read lcddev.id=LCD_RD_DATA(); //读回0X01 lcddev.id=LCD_RD_DATA(); //读回0XD0 lcddev.id=LCD_RD_DATA(); //这里读回0X68 lcddev.id&lt;&lt;=8; lcddev.id|=LCD_RD_DATA(); //这里读回0X04 if(lcddev.id!=0X6804) //也不是6804,尝试看看是不是NT35310 &#123; LCD_WR_REG(0XD4); lcddev.id=LCD_RD_DATA();//dummy read lcddev.id=LCD_RD_DATA();//读回0X01 lcddev.id=LCD_RD_DATA();//读回0X53 lcddev.id&lt;&lt;=8; lcddev.id|=LCD_RD_DATA(); //这里读回0X10 if(lcddev.id!=0X5310) //也不是NT35310,尝试看看是不是NT35510 &#123; LCD_WR_REG(0XDA00); lcddev.id=LCD_RD_DATA(); //读回0X00 LCD_WR_REG(0XDB00); lcddev.id=LCD_RD_DATA(); //读回0X80 lcddev.id&lt;&lt;=8; LCD_WR_REG(0XDC00); lcddev.id|=LCD_RD_DATA(); //读回0X00 if(lcddev.id==0x8000)lcddev.id=0x5510;//NT35510读回的ID是8000H,为方便区分,我们强制设置为5510 if(lcddev.id!=0X5510) //也不是NT5510,尝试看看是不是SSD1963 &#123; LCD_WR_REG(0XA1); lcddev.id=LCD_RD_DATA(); lcddev.id=LCD_RD_DATA(); //读回0X57 lcddev.id&lt;&lt;=8; lcddev.id|=LCD_RD_DATA(); //读回0X61 if(lcddev.id==0X5761)lcddev.id=0X1963;//SSD1963读回的ID是5761H,为方便区分,我们强制设置为1963 &#125; &#125; &#125; &#125; &#125; printf(&quot; LCD ID:%x\\r\\n&quot;,lcddev.id); //打印LCD ID if(lcddev.id==0X9341) //9341初始化 &#123; LCD_WR_REG(0xCF); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC1); LCD_WR_DATA(0X30); LCD_WR_REG(0xED); LCD_WR_DATA(0x64); LCD_WR_DATA(0x03); LCD_WR_DATA(0X12); LCD_WR_DATA(0X81); LCD_WR_REG(0xE8); LCD_WR_DATA(0x85); LCD_WR_DATA(0x10); LCD_WR_DATA(0x7A); LCD_WR_REG(0xCB); LCD_WR_DATA(0x39); LCD_WR_DATA(0x2C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x34); LCD_WR_DATA(0x02); LCD_WR_REG(0xF7); LCD_WR_DATA(0x20); LCD_WR_REG(0xEA); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xC0); //Power control LCD_WR_DATA(0x1B); //VRH[5:0] LCD_WR_REG(0xC1); //Power control LCD_WR_DATA(0x01); //SAP[2:0];BT[3:0] LCD_WR_REG(0xC5); //VCM control LCD_WR_DATA(0x30); //3F LCD_WR_DATA(0x30); //3C LCD_WR_REG(0xC7); //VCM control2 LCD_WR_DATA(0XB7); LCD_WR_REG(0x36); // Memory Access Control LCD_WR_DATA(0x48); LCD_WR_REG(0x3A); LCD_WR_DATA(0x55); LCD_WR_REG(0xB1); LCD_WR_DATA(0x00); LCD_WR_DATA(0x1A); LCD_WR_REG(0xB6); // Display Function Control LCD_WR_DATA(0x0A); LCD_WR_DATA(0xA2); LCD_WR_REG(0xF2); // 3Gamma Function Disable LCD_WR_DATA(0x00); LCD_WR_REG(0x26); //Gamma curve selected LCD_WR_DATA(0x01); LCD_WR_REG(0xE0); //Set Gamma LCD_WR_DATA(0x0F); LCD_WR_DATA(0x2A); LCD_WR_DATA(0x28); LCD_WR_DATA(0x08); LCD_WR_DATA(0x0E); LCD_WR_DATA(0x08); LCD_WR_DATA(0x54); LCD_WR_DATA(0XA9); LCD_WR_DATA(0x43); LCD_WR_DATA(0x0A); LCD_WR_DATA(0x0F); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0XE1); //Set Gamma LCD_WR_DATA(0x00); LCD_WR_DATA(0x15); LCD_WR_DATA(0x17); LCD_WR_DATA(0x07); LCD_WR_DATA(0x11); LCD_WR_DATA(0x06); LCD_WR_DATA(0x2B); LCD_WR_DATA(0x56); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x05); LCD_WR_DATA(0x10); LCD_WR_DATA(0x0F); LCD_WR_DATA(0x3F); LCD_WR_DATA(0x3F); LCD_WR_DATA(0x0F); LCD_WR_REG(0x2B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x01); LCD_WR_DATA(0x3f); LCD_WR_REG(0x2A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0xef); LCD_WR_REG(0x11); //Exit Sleep delay_ms(120); LCD_WR_REG(0x29); //display on &#125;else if(lcddev.id==0x6804) //6804初始化 &#123; LCD_WR_REG(0X11); delay_ms(20); LCD_WR_REG(0XD0);//VCI1 VCL VGH VGL DDVDH VREG1OUT power amplitude setting LCD_WR_DATA(0X07); LCD_WR_DATA(0X42); LCD_WR_DATA(0X1D); LCD_WR_REG(0XD1);//VCOMH VCOM_AC amplitude setting LCD_WR_DATA(0X00); LCD_WR_DATA(0X1a); LCD_WR_DATA(0X09); LCD_WR_REG(0XD2);//Operational Amplifier Circuit Constant Current Adjust , charge pump frequency setting LCD_WR_DATA(0X01); LCD_WR_DATA(0X22); LCD_WR_REG(0XC0);//REV SM GS LCD_WR_DATA(0X10); LCD_WR_DATA(0X3B); LCD_WR_DATA(0X00); LCD_WR_DATA(0X02); LCD_WR_DATA(0X11); LCD_WR_REG(0XC5);// Frame rate setting = 72HZ when setting 0x03 LCD_WR_DATA(0X03); LCD_WR_REG(0XC8);//Gamma setting LCD_WR_DATA(0X00); LCD_WR_DATA(0X25); LCD_WR_DATA(0X21); LCD_WR_DATA(0X05); LCD_WR_DATA(0X00); LCD_WR_DATA(0X0a); LCD_WR_DATA(0X65); LCD_WR_DATA(0X25); LCD_WR_DATA(0X77); LCD_WR_DATA(0X50); LCD_WR_DATA(0X0f); LCD_WR_DATA(0X00); LCD_WR_REG(0XF8); LCD_WR_DATA(0X01); LCD_WR_REG(0XFE); LCD_WR_DATA(0X00); LCD_WR_DATA(0X02); LCD_WR_REG(0X20);//Exit invert mode LCD_WR_REG(0X36); LCD_WR_DATA(0X08);//原来是a LCD_WR_REG(0X3A); LCD_WR_DATA(0X55);//16位模式 LCD_WR_REG(0X2B); LCD_WR_DATA(0X00); LCD_WR_DATA(0X00); LCD_WR_DATA(0X01); LCD_WR_DATA(0X3F); LCD_WR_REG(0X2A); LCD_WR_DATA(0X00); LCD_WR_DATA(0X00); LCD_WR_DATA(0X01); LCD_WR_DATA(0XDF); delay_ms(120); LCD_WR_REG(0X29); &#125;else if(lcddev.id==0x5310) &#123; LCD_WR_REG(0xED); LCD_WR_DATA(0x01); LCD_WR_DATA(0xFE); LCD_WR_REG(0xEE); LCD_WR_DATA(0xDE); LCD_WR_DATA(0x21); LCD_WR_REG(0xF1); LCD_WR_DATA(0x01); LCD_WR_REG(0xDF); LCD_WR_DATA(0x10); //VCOMvoltage// LCD_WR_REG(0xC4); LCD_WR_DATA(0x8F); //5f LCD_WR_REG(0xC6); LCD_WR_DATA(0x00); LCD_WR_DATA(0xE2); LCD_WR_DATA(0xE2); LCD_WR_DATA(0xE2); LCD_WR_REG(0xBF); LCD_WR_DATA(0xAA); LCD_WR_REG(0xB0); LCD_WR_DATA(0x0D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x0D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x11); LCD_WR_DATA(0x00); LCD_WR_DATA(0x19); LCD_WR_DATA(0x00); LCD_WR_DATA(0x21); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x5D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x5D); LCD_WR_DATA(0x00); LCD_WR_REG(0xB1); LCD_WR_DATA(0x80); LCD_WR_DATA(0x00); LCD_WR_DATA(0x8B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x96); LCD_WR_DATA(0x00); LCD_WR_REG(0xB2); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x02); LCD_WR_DATA(0x00); LCD_WR_DATA(0x03); LCD_WR_DATA(0x00); LCD_WR_REG(0xB3); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xB4); LCD_WR_DATA(0x8B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x96); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA1); LCD_WR_DATA(0x00); LCD_WR_REG(0xB5); LCD_WR_DATA(0x02); LCD_WR_DATA(0x00); LCD_WR_DATA(0x03); LCD_WR_DATA(0x00); LCD_WR_DATA(0x04); LCD_WR_DATA(0x00); LCD_WR_REG(0xB6); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xB7); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3F); LCD_WR_DATA(0x00); LCD_WR_DATA(0x5E); LCD_WR_DATA(0x00); LCD_WR_DATA(0x64); LCD_WR_DATA(0x00); LCD_WR_DATA(0x8C); LCD_WR_DATA(0x00); LCD_WR_DATA(0xAC); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDC); LCD_WR_DATA(0x00); LCD_WR_DATA(0x70); LCD_WR_DATA(0x00); LCD_WR_DATA(0x90); LCD_WR_DATA(0x00); LCD_WR_DATA(0xEB); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDC); LCD_WR_DATA(0x00); LCD_WR_REG(0xB8); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xBA); LCD_WR_DATA(0x24); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xC1); LCD_WR_DATA(0x20); LCD_WR_DATA(0x00); LCD_WR_DATA(0x54); LCD_WR_DATA(0x00); LCD_WR_DATA(0xFF); LCD_WR_DATA(0x00); LCD_WR_REG(0xC2); LCD_WR_DATA(0x0A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x04); LCD_WR_DATA(0x00); LCD_WR_REG(0xC3); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x39); LCD_WR_DATA(0x00); LCD_WR_DATA(0x37); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x36); LCD_WR_DATA(0x00); LCD_WR_DATA(0x32); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2F); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x29); LCD_WR_DATA(0x00); LCD_WR_DATA(0x26); LCD_WR_DATA(0x00); LCD_WR_DATA(0x24); LCD_WR_DATA(0x00); LCD_WR_DATA(0x24); LCD_WR_DATA(0x00); LCD_WR_DATA(0x23); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x36); LCD_WR_DATA(0x00); LCD_WR_DATA(0x32); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2F); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x29); LCD_WR_DATA(0x00); LCD_WR_DATA(0x26); LCD_WR_DATA(0x00); LCD_WR_DATA(0x24); LCD_WR_DATA(0x00); LCD_WR_DATA(0x24); LCD_WR_DATA(0x00); LCD_WR_DATA(0x23); LCD_WR_DATA(0x00); LCD_WR_REG(0xC4); LCD_WR_DATA(0x62); LCD_WR_DATA(0x00); LCD_WR_DATA(0x05); LCD_WR_DATA(0x00); LCD_WR_DATA(0x84); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF0); LCD_WR_DATA(0x00); LCD_WR_DATA(0x18); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA4); LCD_WR_DATA(0x00); LCD_WR_DATA(0x18); LCD_WR_DATA(0x00); LCD_WR_DATA(0x50); LCD_WR_DATA(0x00); LCD_WR_DATA(0x0C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x17); LCD_WR_DATA(0x00); LCD_WR_DATA(0x95); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_DATA(0xE6); LCD_WR_DATA(0x00); LCD_WR_REG(0xC5); LCD_WR_DATA(0x32); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x65); LCD_WR_DATA(0x00); LCD_WR_DATA(0x76); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_REG(0xC6); LCD_WR_DATA(0x20); LCD_WR_DATA(0x00); LCD_WR_DATA(0x17); LCD_WR_DATA(0x00); LCD_WR_DATA(0x01); LCD_WR_DATA(0x00); LCD_WR_REG(0xC7); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xC8); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xC9); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xE0); LCD_WR_DATA(0x16); LCD_WR_DATA(0x00); LCD_WR_DATA(0x1C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x21); LCD_WR_DATA(0x00); LCD_WR_DATA(0x36); LCD_WR_DATA(0x00); LCD_WR_DATA(0x46); LCD_WR_DATA(0x00); LCD_WR_DATA(0x52); LCD_WR_DATA(0x00); LCD_WR_DATA(0x64); LCD_WR_DATA(0x00); LCD_WR_DATA(0x7A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x8B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA8); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB9); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC4); LCD_WR_DATA(0x00); LCD_WR_DATA(0xCA); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD9); LCD_WR_DATA(0x00); LCD_WR_DATA(0xE0); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE1); LCD_WR_DATA(0x16); LCD_WR_DATA(0x00); LCD_WR_DATA(0x1C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x22); LCD_WR_DATA(0x00); LCD_WR_DATA(0x36); LCD_WR_DATA(0x00); LCD_WR_DATA(0x45); LCD_WR_DATA(0x00); LCD_WR_DATA(0x52); LCD_WR_DATA(0x00); LCD_WR_DATA(0x64); LCD_WR_DATA(0x00); LCD_WR_DATA(0x7A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x8B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA8); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB9); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC4); LCD_WR_DATA(0x00); LCD_WR_DATA(0xCA); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD8); LCD_WR_DATA(0x00); LCD_WR_DATA(0xE0); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE2); LCD_WR_DATA(0x05); LCD_WR_DATA(0x00); LCD_WR_DATA(0x0B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x1B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x34); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x4F); LCD_WR_DATA(0x00); LCD_WR_DATA(0x61); LCD_WR_DATA(0x00); LCD_WR_DATA(0x79); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_DATA(0x97); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA6); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB7); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC7); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD1); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD6); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDD); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE3); LCD_WR_DATA(0x05); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA); LCD_WR_DATA(0x00); LCD_WR_DATA(0x1C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x33); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x50); LCD_WR_DATA(0x00); LCD_WR_DATA(0x62); LCD_WR_DATA(0x00); LCD_WR_DATA(0x78); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_DATA(0x97); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA6); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB7); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC7); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD1); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD5); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDD); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE4); LCD_WR_DATA(0x01); LCD_WR_DATA(0x00); LCD_WR_DATA(0x01); LCD_WR_DATA(0x00); LCD_WR_DATA(0x02); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x4B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x5D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x74); LCD_WR_DATA(0x00); LCD_WR_DATA(0x84); LCD_WR_DATA(0x00); LCD_WR_DATA(0x93); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB3); LCD_WR_DATA(0x00); LCD_WR_DATA(0xBE); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC4); LCD_WR_DATA(0x00); LCD_WR_DATA(0xCD); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD3); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDD); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE5); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x02); LCD_WR_DATA(0x00); LCD_WR_DATA(0x29); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x4B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x5D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x74); LCD_WR_DATA(0x00); LCD_WR_DATA(0x84); LCD_WR_DATA(0x00); LCD_WR_DATA(0x93); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB3); LCD_WR_DATA(0x00); LCD_WR_DATA(0xBE); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC4); LCD_WR_DATA(0x00); LCD_WR_DATA(0xCD); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD3); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDC); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE6); LCD_WR_DATA(0x11); LCD_WR_DATA(0x00); LCD_WR_DATA(0x34); LCD_WR_DATA(0x00); LCD_WR_DATA(0x56); LCD_WR_DATA(0x00); LCD_WR_DATA(0x76); LCD_WR_DATA(0x00); LCD_WR_DATA(0x77); LCD_WR_DATA(0x00); LCD_WR_DATA(0x66); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0xBB); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0x66); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_DATA(0x45); LCD_WR_DATA(0x00); LCD_WR_DATA(0x43); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_REG(0xE7); LCD_WR_DATA(0x32); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_DATA(0x76); LCD_WR_DATA(0x00); LCD_WR_DATA(0x66); LCD_WR_DATA(0x00); LCD_WR_DATA(0x67); LCD_WR_DATA(0x00); LCD_WR_DATA(0x67); LCD_WR_DATA(0x00); LCD_WR_DATA(0x87); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0xBB); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0x77); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x56); LCD_WR_DATA(0x00); LCD_WR_DATA(0x23); LCD_WR_DATA(0x00); LCD_WR_DATA(0x33); LCD_WR_DATA(0x00); LCD_WR_DATA(0x45); LCD_WR_DATA(0x00); LCD_WR_REG(0xE8); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0x87); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_DATA(0x77); LCD_WR_DATA(0x00); LCD_WR_DATA(0x66); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_DATA(0xAA); LCD_WR_DATA(0x00); LCD_WR_DATA(0xBB); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0x66); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_REG(0xE9); LCD_WR_DATA(0xAA); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0x00); LCD_WR_DATA(0xAA); LCD_WR_REG(0xCF); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xF0); LCD_WR_DATA(0x00); LCD_WR_DATA(0x50); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xF9); LCD_WR_DATA(0x06); LCD_WR_DATA(0x10); LCD_WR_DATA(0x29); LCD_WR_DATA(0x00); LCD_WR_REG(0x3A); LCD_WR_DATA(0x55); //66 LCD_WR_REG(0x11); delay_ms(100); LCD_WR_REG(0x29); LCD_WR_REG(0x35); LCD_WR_DATA(0x00); LCD_WR_REG(0x51); LCD_WR_DATA(0xFF); LCD_WR_REG(0x53); LCD_WR_DATA(0x2C); LCD_WR_REG(0x55); LCD_WR_DATA(0x82); LCD_WR_REG(0x2c); &#125;else if(lcddev.id==0x5510) &#123; LCD_WriteReg(0xF000,0x55); LCD_WriteReg(0xF001,0xAA); LCD_WriteReg(0xF002,0x52); LCD_WriteReg(0xF003,0x08); LCD_WriteReg(0xF004,0x01); //AVDD Set AVDD 5.2V LCD_WriteReg(0xB000,0x0D); LCD_WriteReg(0xB001,0x0D); LCD_WriteReg(0xB002,0x0D); //AVDD ratio LCD_WriteReg(0xB600,0x34); LCD_WriteReg(0xB601,0x34); LCD_WriteReg(0xB602,0x34); //AVEE -5.2V LCD_WriteReg(0xB100,0x0D); LCD_WriteReg(0xB101,0x0D); LCD_WriteReg(0xB102,0x0D); //AVEE ratio LCD_WriteReg(0xB700,0x34); LCD_WriteReg(0xB701,0x34); LCD_WriteReg(0xB702,0x34); //VCL -2.5V LCD_WriteReg(0xB200,0x00); LCD_WriteReg(0xB201,0x00); LCD_WriteReg(0xB202,0x00); //VCL ratio LCD_WriteReg(0xB800,0x24); LCD_WriteReg(0xB801,0x24); LCD_WriteReg(0xB802,0x24); //VGH 15V (Free pump) LCD_WriteReg(0xBF00,0x01); LCD_WriteReg(0xB300,0x0F); LCD_WriteReg(0xB301,0x0F); LCD_WriteReg(0xB302,0x0F); //VGH ratio LCD_WriteReg(0xB900,0x34); LCD_WriteReg(0xB901,0x34); LCD_WriteReg(0xB902,0x34); //VGL_REG -10V LCD_WriteReg(0xB500,0x08); LCD_WriteReg(0xB501,0x08); LCD_WriteReg(0xB502,0x08); LCD_WriteReg(0xC200,0x03); //VGLX ratio LCD_WriteReg(0xBA00,0x24); LCD_WriteReg(0xBA01,0x24); LCD_WriteReg(0xBA02,0x24); //VGMP/VGSP 4.5V/0V LCD_WriteReg(0xBC00,0x00); LCD_WriteReg(0xBC01,0x78); LCD_WriteReg(0xBC02,0x00); //VGMN/VGSN -4.5V/0V LCD_WriteReg(0xBD00,0x00); LCD_WriteReg(0xBD01,0x78); LCD_WriteReg(0xBD02,0x00); //VCOM LCD_WriteReg(0xBE00,0x00); LCD_WriteReg(0xBE01,0x64); //Gamma Setting LCD_WriteReg(0xD100,0x00); LCD_WriteReg(0xD101,0x33); LCD_WriteReg(0xD102,0x00); LCD_WriteReg(0xD103,0x34); LCD_WriteReg(0xD104,0x00); LCD_WriteReg(0xD105,0x3A); LCD_WriteReg(0xD106,0x00); LCD_WriteReg(0xD107,0x4A); LCD_WriteReg(0xD108,0x00); LCD_WriteReg(0xD109,0x5C); LCD_WriteReg(0xD10A,0x00); LCD_WriteReg(0xD10B,0x81); LCD_WriteReg(0xD10C,0x00); LCD_WriteReg(0xD10D,0xA6); LCD_WriteReg(0xD10E,0x00); LCD_WriteReg(0xD10F,0xE5); LCD_WriteReg(0xD110,0x01); LCD_WriteReg(0xD111,0x13); LCD_WriteReg(0xD112,0x01); LCD_WriteReg(0xD113,0x54); LCD_WriteReg(0xD114,0x01); LCD_WriteReg(0xD115,0x82); LCD_WriteReg(0xD116,0x01); LCD_WriteReg(0xD117,0xCA); LCD_WriteReg(0xD118,0x02); LCD_WriteReg(0xD119,0x00); LCD_WriteReg(0xD11A,0x02); LCD_WriteReg(0xD11B,0x01); LCD_WriteReg(0xD11C,0x02); LCD_WriteReg(0xD11D,0x34); LCD_WriteReg(0xD11E,0x02); LCD_WriteReg(0xD11F,0x67); LCD_WriteReg(0xD120,0x02); LCD_WriteReg(0xD121,0x84); LCD_WriteReg(0xD122,0x02); LCD_WriteReg(0xD123,0xA4); LCD_WriteReg(0xD124,0x02); LCD_WriteReg(0xD125,0xB7); LCD_WriteReg(0xD126,0x02); LCD_WriteReg(0xD127,0xCF); LCD_WriteReg(0xD128,0x02); LCD_WriteReg(0xD129,0xDE); LCD_WriteReg(0xD12A,0x02); LCD_WriteReg(0xD12B,0xF2); LCD_WriteReg(0xD12C,0x02); LCD_WriteReg(0xD12D,0xFE); LCD_WriteReg(0xD12E,0x03); LCD_WriteReg(0xD12F,0x10); LCD_WriteReg(0xD130,0x03); LCD_WriteReg(0xD131,0x33); LCD_WriteReg(0xD132,0x03); LCD_WriteReg(0xD133,0x6D); LCD_WriteReg(0xD200,0x00); LCD_WriteReg(0xD201,0x33); LCD_WriteReg(0xD202,0x00); LCD_WriteReg(0xD203,0x34); LCD_WriteReg(0xD204,0x00); LCD_WriteReg(0xD205,0x3A); LCD_WriteReg(0xD206,0x00); LCD_WriteReg(0xD207,0x4A); LCD_WriteReg(0xD208,0x00); LCD_WriteReg(0xD209,0x5C); LCD_WriteReg(0xD20A,0x00); LCD_WriteReg(0xD20B,0x81); LCD_WriteReg(0xD20C,0x00); LCD_WriteReg(0xD20D,0xA6); LCD_WriteReg(0xD20E,0x00); LCD_WriteReg(0xD20F,0xE5); LCD_WriteReg(0xD210,0x01); LCD_WriteReg(0xD211,0x13); LCD_WriteReg(0xD212,0x01); LCD_WriteReg(0xD213,0x54); LCD_WriteReg(0xD214,0x01); LCD_WriteReg(0xD215,0x82); LCD_WriteReg(0xD216,0x01); LCD_WriteReg(0xD217,0xCA); LCD_WriteReg(0xD218,0x02); LCD_WriteReg(0xD219,0x00); LCD_WriteReg(0xD21A,0x02); LCD_WriteReg(0xD21B,0x01); LCD_WriteReg(0xD21C,0x02); LCD_WriteReg(0xD21D,0x34); LCD_WriteReg(0xD21E,0x02); LCD_WriteReg(0xD21F,0x67); LCD_WriteReg(0xD220,0x02); LCD_WriteReg(0xD221,0x84); LCD_WriteReg(0xD222,0x02); LCD_WriteReg(0xD223,0xA4); LCD_WriteReg(0xD224,0x02); LCD_WriteReg(0xD225,0xB7); LCD_WriteReg(0xD226,0x02); LCD_WriteReg(0xD227,0xCF); LCD_WriteReg(0xD228,0x02); LCD_WriteReg(0xD229,0xDE); LCD_WriteReg(0xD22A,0x02); LCD_WriteReg(0xD22B,0xF2); LCD_WriteReg(0xD22C,0x02); LCD_WriteReg(0xD22D,0xFE); LCD_WriteReg(0xD22E,0x03); LCD_WriteReg(0xD22F,0x10); LCD_WriteReg(0xD230,0x03); LCD_WriteReg(0xD231,0x33); LCD_WriteReg(0xD232,0x03); LCD_WriteReg(0xD233,0x6D); LCD_WriteReg(0xD300,0x00); LCD_WriteReg(0xD301,0x33); LCD_WriteReg(0xD302,0x00); LCD_WriteReg(0xD303,0x34); LCD_WriteReg(0xD304,0x00); LCD_WriteReg(0xD305,0x3A); LCD_WriteReg(0xD306,0x00); LCD_WriteReg(0xD307,0x4A); LCD_WriteReg(0xD308,0x00); LCD_WriteReg(0xD309,0x5C); LCD_WriteReg(0xD30A,0x00); LCD_WriteReg(0xD30B,0x81); LCD_WriteReg(0xD30C,0x00); LCD_WriteReg(0xD30D,0xA6); LCD_WriteReg(0xD30E,0x00); LCD_WriteReg(0xD30F,0xE5); LCD_WriteReg(0xD310,0x01); LCD_WriteReg(0xD311,0x13); LCD_WriteReg(0xD312,0x01); LCD_WriteReg(0xD313,0x54); LCD_WriteReg(0xD314,0x01); LCD_WriteReg(0xD315,0x82); LCD_WriteReg(0xD316,0x01); LCD_WriteReg(0xD317,0xCA); LCD_WriteReg(0xD318,0x02); LCD_WriteReg(0xD319,0x00); LCD_WriteReg(0xD31A,0x02); LCD_WriteReg(0xD31B,0x01); LCD_WriteReg(0xD31C,0x02); LCD_WriteReg(0xD31D,0x34); LCD_WriteReg(0xD31E,0x02); LCD_WriteReg(0xD31F,0x67); LCD_WriteReg(0xD320,0x02); LCD_WriteReg(0xD321,0x84); LCD_WriteReg(0xD322,0x02); LCD_WriteReg(0xD323,0xA4); LCD_WriteReg(0xD324,0x02); LCD_WriteReg(0xD325,0xB7); LCD_WriteReg(0xD326,0x02); LCD_WriteReg(0xD327,0xCF); LCD_WriteReg(0xD328,0x02); LCD_WriteReg(0xD329,0xDE); LCD_WriteReg(0xD32A,0x02); LCD_WriteReg(0xD32B,0xF2); LCD_WriteReg(0xD32C,0x02); LCD_WriteReg(0xD32D,0xFE); LCD_WriteReg(0xD32E,0x03); LCD_WriteReg(0xD32F,0x10); LCD_WriteReg(0xD330,0x03); LCD_WriteReg(0xD331,0x33); LCD_WriteReg(0xD332,0x03); LCD_WriteReg(0xD333,0x6D); LCD_WriteReg(0xD400,0x00); LCD_WriteReg(0xD401,0x33); LCD_WriteReg(0xD402,0x00); LCD_WriteReg(0xD403,0x34); LCD_WriteReg(0xD404,0x00); LCD_WriteReg(0xD405,0x3A); LCD_WriteReg(0xD406,0x00); LCD_WriteReg(0xD407,0x4A); LCD_WriteReg(0xD408,0x00); LCD_WriteReg(0xD409,0x5C); LCD_WriteReg(0xD40A,0x00); LCD_WriteReg(0xD40B,0x81); LCD_WriteReg(0xD40C,0x00); LCD_WriteReg(0xD40D,0xA6); LCD_WriteReg(0xD40E,0x00); LCD_WriteReg(0xD40F,0xE5); LCD_WriteReg(0xD410,0x01); LCD_WriteReg(0xD411,0x13); LCD_WriteReg(0xD412,0x01); LCD_WriteReg(0xD413,0x54); LCD_WriteReg(0xD414,0x01); LCD_WriteReg(0xD415,0x82); LCD_WriteReg(0xD416,0x01); LCD_WriteReg(0xD417,0xCA); LCD_WriteReg(0xD418,0x02); LCD_WriteReg(0xD419,0x00); LCD_WriteReg(0xD41A,0x02); LCD_WriteReg(0xD41B,0x01); LCD_WriteReg(0xD41C,0x02); LCD_WriteReg(0xD41D,0x34); LCD_WriteReg(0xD41E,0x02); LCD_WriteReg(0xD41F,0x67); LCD_WriteReg(0xD420,0x02); LCD_WriteReg(0xD421,0x84); LCD_WriteReg(0xD422,0x02); LCD_WriteReg(0xD423,0xA4); LCD_WriteReg(0xD424,0x02); LCD_WriteReg(0xD425,0xB7); LCD_WriteReg(0xD426,0x02); LCD_WriteReg(0xD427,0xCF); LCD_WriteReg(0xD428,0x02); LCD_WriteReg(0xD429,0xDE); LCD_WriteReg(0xD42A,0x02); LCD_WriteReg(0xD42B,0xF2); LCD_WriteReg(0xD42C,0x02); LCD_WriteReg(0xD42D,0xFE); LCD_WriteReg(0xD42E,0x03); LCD_WriteReg(0xD42F,0x10); LCD_WriteReg(0xD430,0x03); LCD_WriteReg(0xD431,0x33); LCD_WriteReg(0xD432,0x03); LCD_WriteReg(0xD433,0x6D); LCD_WriteReg(0xD500,0x00); LCD_WriteReg(0xD501,0x33); LCD_WriteReg(0xD502,0x00); LCD_WriteReg(0xD503,0x34); LCD_WriteReg(0xD504,0x00); LCD_WriteReg(0xD505,0x3A); LCD_WriteReg(0xD506,0x00); LCD_WriteReg(0xD507,0x4A); LCD_WriteReg(0xD508,0x00); LCD_WriteReg(0xD509,0x5C); LCD_WriteReg(0xD50A,0x00); LCD_WriteReg(0xD50B,0x81); LCD_WriteReg(0xD50C,0x00); LCD_WriteReg(0xD50D,0xA6); LCD_WriteReg(0xD50E,0x00); LCD_WriteReg(0xD50F,0xE5); LCD_WriteReg(0xD510,0x01); LCD_WriteReg(0xD511,0x13); LCD_WriteReg(0xD512,0x01); LCD_WriteReg(0xD513,0x54); LCD_WriteReg(0xD514,0x01); LCD_WriteReg(0xD515,0x82); LCD_WriteReg(0xD516,0x01); LCD_WriteReg(0xD517,0xCA); LCD_WriteReg(0xD518,0x02); LCD_WriteReg(0xD519,0x00); LCD_WriteReg(0xD51A,0x02); LCD_WriteReg(0xD51B,0x01); LCD_WriteReg(0xD51C,0x02); LCD_WriteReg(0xD51D,0x34); LCD_WriteReg(0xD51E,0x02); LCD_WriteReg(0xD51F,0x67); LCD_WriteReg(0xD520,0x02); LCD_WriteReg(0xD521,0x84); LCD_WriteReg(0xD522,0x02); LCD_WriteReg(0xD523,0xA4); LCD_WriteReg(0xD524,0x02); LCD_WriteReg(0xD525,0xB7); LCD_WriteReg(0xD526,0x02); LCD_WriteReg(0xD527,0xCF); LCD_WriteReg(0xD528,0x02); LCD_WriteReg(0xD529,0xDE); LCD_WriteReg(0xD52A,0x02); LCD_WriteReg(0xD52B,0xF2); LCD_WriteReg(0xD52C,0x02); LCD_WriteReg(0xD52D,0xFE); LCD_WriteReg(0xD52E,0x03); LCD_WriteReg(0xD52F,0x10); LCD_WriteReg(0xD530,0x03); LCD_WriteReg(0xD531,0x33); LCD_WriteReg(0xD532,0x03); LCD_WriteReg(0xD533,0x6D); LCD_WriteReg(0xD600,0x00); LCD_WriteReg(0xD601,0x33); LCD_WriteReg(0xD602,0x00); LCD_WriteReg(0xD603,0x34); LCD_WriteReg(0xD604,0x00); LCD_WriteReg(0xD605,0x3A); LCD_WriteReg(0xD606,0x00); LCD_WriteReg(0xD607,0x4A); LCD_WriteReg(0xD608,0x00); LCD_WriteReg(0xD609,0x5C); LCD_WriteReg(0xD60A,0x00); LCD_WriteReg(0xD60B,0x81); LCD_WriteReg(0xD60C,0x00); LCD_WriteReg(0xD60D,0xA6); LCD_WriteReg(0xD60E,0x00); LCD_WriteReg(0xD60F,0xE5); LCD_WriteReg(0xD610,0x01); LCD_WriteReg(0xD611,0x13); LCD_WriteReg(0xD612,0x01); LCD_WriteReg(0xD613,0x54); LCD_WriteReg(0xD614,0x01); LCD_WriteReg(0xD615,0x82); LCD_WriteReg(0xD616,0x01); LCD_WriteReg(0xD617,0xCA); LCD_WriteReg(0xD618,0x02); LCD_WriteReg(0xD619,0x00); LCD_WriteReg(0xD61A,0x02); LCD_WriteReg(0xD61B,0x01); LCD_WriteReg(0xD61C,0x02); LCD_WriteReg(0xD61D,0x34); LCD_WriteReg(0xD61E,0x02); LCD_WriteReg(0xD61F,0x67); LCD_WriteReg(0xD620,0x02); LCD_WriteReg(0xD621,0x84); LCD_WriteReg(0xD622,0x02); LCD_WriteReg(0xD623,0xA4); LCD_WriteReg(0xD624,0x02); LCD_WriteReg(0xD625,0xB7); LCD_WriteReg(0xD626,0x02); LCD_WriteReg(0xD627,0xCF); LCD_WriteReg(0xD628,0x02); LCD_WriteReg(0xD629,0xDE); LCD_WriteReg(0xD62A,0x02); LCD_WriteReg(0xD62B,0xF2); LCD_WriteReg(0xD62C,0x02); LCD_WriteReg(0xD62D,0xFE); LCD_WriteReg(0xD62E,0x03); LCD_WriteReg(0xD62F,0x10); LCD_WriteReg(0xD630,0x03); LCD_WriteReg(0xD631,0x33); LCD_WriteReg(0xD632,0x03); LCD_WriteReg(0xD633,0x6D); //LV2 Page 0 enable LCD_WriteReg(0xF000,0x55); LCD_WriteReg(0xF001,0xAA); LCD_WriteReg(0xF002,0x52); LCD_WriteReg(0xF003,0x08); LCD_WriteReg(0xF004,0x00); //Display control LCD_WriteReg(0xB100, 0xCC); LCD_WriteReg(0xB101, 0x00); //Source hold time LCD_WriteReg(0xB600,0x05); //Gate EQ control LCD_WriteReg(0xB700,0x70); LCD_WriteReg(0xB701,0x70); //Source EQ control (Mode 2) LCD_WriteReg(0xB800,0x01); LCD_WriteReg(0xB801,0x03); LCD_WriteReg(0xB802,0x03); LCD_WriteReg(0xB803,0x03); //Inversion mode (2-dot) LCD_WriteReg(0xBC00,0x02); LCD_WriteReg(0xBC01,0x00); LCD_WriteReg(0xBC02,0x00); //Timing control 4H w/ 4-delay LCD_WriteReg(0xC900,0xD0); LCD_WriteReg(0xC901,0x02); LCD_WriteReg(0xC902,0x50); LCD_WriteReg(0xC903,0x50); LCD_WriteReg(0xC904,0x50); LCD_WriteReg(0x3500,0x00); LCD_WriteReg(0x3A00,0x55); //16-bit/pixel LCD_WR_REG(0x1100); delay_us(120); LCD_WR_REG(0x2900); &#125;else if(lcddev.id==0x9325)//9325 &#123; LCD_WriteReg(0x00E5,0x78F0); LCD_WriteReg(0x0001,0x0100); LCD_WriteReg(0x0002,0x0700); LCD_WriteReg(0x0003,0x1030); LCD_WriteReg(0x0004,0x0000); LCD_WriteReg(0x0008,0x0202); LCD_WriteReg(0x0009,0x0000); LCD_WriteReg(0x000A,0x0000); LCD_WriteReg(0x000C,0x0000); LCD_WriteReg(0x000D,0x0000); LCD_WriteReg(0x000F,0x0000); //power on sequence VGHVGL LCD_WriteReg(0x0010,0x0000); LCD_WriteReg(0x0011,0x0007); LCD_WriteReg(0x0012,0x0000); LCD_WriteReg(0x0013,0x0000); LCD_WriteReg(0x0007,0x0000); //vgh LCD_WriteReg(0x0010,0x1690); LCD_WriteReg(0x0011,0x0227); //delayms(100); //vregiout LCD_WriteReg(0x0012,0x009D); //0x001b //delayms(100); //vom amplitude LCD_WriteReg(0x0013,0x1900); //delayms(100); //vom H LCD_WriteReg(0x0029,0x0025); LCD_WriteReg(0x002B,0x000D); //gamma LCD_WriteReg(0x0030,0x0007); LCD_WriteReg(0x0031,0x0303); LCD_WriteReg(0x0032,0x0003);// 0006 LCD_WriteReg(0x0035,0x0206); LCD_WriteReg(0x0036,0x0008); LCD_WriteReg(0x0037,0x0406); LCD_WriteReg(0x0038,0x0304);//0200 LCD_WriteReg(0x0039,0x0007); LCD_WriteReg(0x003C,0x0602);// 0504 LCD_WriteReg(0x003D,0x0008); //ram LCD_WriteReg(0x0050,0x0000); LCD_WriteReg(0x0051,0x00EF); LCD_WriteReg(0x0052,0x0000); LCD_WriteReg(0x0053,0x013F); LCD_WriteReg(0x0060,0xA700); LCD_WriteReg(0x0061,0x0001); LCD_WriteReg(0x006A,0x0000); // LCD_WriteReg(0x0080,0x0000); LCD_WriteReg(0x0081,0x0000); LCD_WriteReg(0x0082,0x0000); LCD_WriteReg(0x0083,0x0000); LCD_WriteReg(0x0084,0x0000); LCD_WriteReg(0x0085,0x0000); // LCD_WriteReg(0x0090,0x0010); LCD_WriteReg(0x0092,0x0600); LCD_WriteReg(0x0007,0x0133); LCD_WriteReg(0x00,0x0022);// &#125;else if(lcddev.id==0x9328)//ILI9328 OK &#123; LCD_WriteReg(0x00EC,0x108F);// internal timeing LCD_WriteReg(0x00EF,0x1234);// ADD //LCD_WriteReg(0x00e7,0x0010); //LCD_WriteReg(0x0000,0x0001);//开启内部时钟 LCD_WriteReg(0x0001,0x0100); LCD_WriteReg(0x0002,0x0700);//电源开启 //LCD_WriteReg(0x0003,(1&lt;&lt;3)|(1&lt;&lt;4) ); //65K RGB //DRIVE TABLE(寄存器 03H) //BIT3=AM BIT4:5=ID0:1 //AM ID0 ID1 FUNCATION // 0 0 0 R-&gt;L D-&gt;U // 1 0 0 D-&gt;U R-&gt;L // 0 1 0 L-&gt;R D-&gt;U // 1 1 0 D-&gt;U L-&gt;R // 0 0 1 R-&gt;L U-&gt;D // 1 0 1 U-&gt;D R-&gt;L // 0 1 1 L-&gt;R U-&gt;D 正常就用这个. // 1 1 1 U-&gt;D L-&gt;R LCD_WriteReg(0x0003,(1&lt;&lt;12)|(3&lt;&lt;4)|(0&lt;&lt;3) );//65K LCD_WriteReg(0x0004,0x0000); LCD_WriteReg(0x0008,0x0202); LCD_WriteReg(0x0009,0x0000); LCD_WriteReg(0x000a,0x0000);//display setting LCD_WriteReg(0x000c,0x0001);//display setting LCD_WriteReg(0x000d,0x0000);//0f3c LCD_WriteReg(0x000f,0x0000); //电源配置 LCD_WriteReg(0x0010,0x0000); LCD_WriteReg(0x0011,0x0007); LCD_WriteReg(0x0012,0x0000); LCD_WriteReg(0x0013,0x0000); LCD_WriteReg(0x0007,0x0001); delay_ms(50); LCD_WriteReg(0x0010,0x1490); LCD_WriteReg(0x0011,0x0227); delay_ms(50); LCD_WriteReg(0x0012,0x008A); delay_ms(50); LCD_WriteReg(0x0013,0x1a00); LCD_WriteReg(0x0029,0x0006); LCD_WriteReg(0x002b,0x000d); delay_ms(50); LCD_WriteReg(0x0020,0x0000); LCD_WriteReg(0x0021,0x0000); delay_ms(50); //伽马校正 LCD_WriteReg(0x0030,0x0000); LCD_WriteReg(0x0031,0x0604); LCD_WriteReg(0x0032,0x0305); LCD_WriteReg(0x0035,0x0000); LCD_WriteReg(0x0036,0x0C09); LCD_WriteReg(0x0037,0x0204); LCD_WriteReg(0x0038,0x0301); LCD_WriteReg(0x0039,0x0707); LCD_WriteReg(0x003c,0x0000); LCD_WriteReg(0x003d,0x0a0a); delay_ms(50); LCD_WriteReg(0x0050,0x0000); //水平GRAM起始位置 LCD_WriteReg(0x0051,0x00ef); //水平GRAM终止位置 LCD_WriteReg(0x0052,0x0000); //垂直GRAM起始位置 LCD_WriteReg(0x0053,0x013f); //垂直GRAM终止位置 LCD_WriteReg(0x0060,0xa700); LCD_WriteReg(0x0061,0x0001); LCD_WriteReg(0x006a,0x0000); LCD_WriteReg(0x0080,0x0000); LCD_WriteReg(0x0081,0x0000); LCD_WriteReg(0x0082,0x0000); LCD_WriteReg(0x0083,0x0000); LCD_WriteReg(0x0084,0x0000); LCD_WriteReg(0x0085,0x0000); LCD_WriteReg(0x0090,0x0010); LCD_WriteReg(0x0092,0x0600); //开启显示设置 LCD_WriteReg(0x0007,0x0133); &#125;else if(lcddev.id==0x9320)//测试OK. &#123; LCD_WriteReg(0x00,0x0000); LCD_WriteReg(0x01,0x0100); //Driver Output Contral. LCD_WriteReg(0x02,0x0700); //LCD Driver Waveform Contral. LCD_WriteReg(0x03,0x1030);//Entry Mode Set. //LCD_WriteReg(0x03,0x1018); //Entry Mode Set. LCD_WriteReg(0x04,0x0000); //Scalling Contral. LCD_WriteReg(0x08,0x0202); //Display Contral 2.(0x0207) LCD_WriteReg(0x09,0x0000); //Display Contral 3.(0x0000) LCD_WriteReg(0x0a,0x0000); //Frame Cycle Contal.(0x0000) LCD_WriteReg(0x0c,(1&lt;&lt;0)); //Extern Display Interface Contral 1.(0x0000) LCD_WriteReg(0x0d,0x0000); //Frame Maker Position. LCD_WriteReg(0x0f,0x0000); //Extern Display Interface Contral 2. delay_ms(50); LCD_WriteReg(0x07,0x0101); //Display Contral. delay_ms(50); LCD_WriteReg(0x10,(1&lt;&lt;12)|(0&lt;&lt;8)|(1&lt;&lt;7)|(1&lt;&lt;6)|(0&lt;&lt;4)); //Power Control 1.(0x16b0) LCD_WriteReg(0x11,0x0007); //Power Control 2.(0x0001) LCD_WriteReg(0x12,(1&lt;&lt;8)|(1&lt;&lt;4)|(0&lt;&lt;0)); //Power Control 3.(0x0138) LCD_WriteReg(0x13,0x0b00); //Power Control 4. LCD_WriteReg(0x29,0x0000); //Power Control 7. LCD_WriteReg(0x2b,(1&lt;&lt;14)|(1&lt;&lt;4)); LCD_WriteReg(0x50,0); //Set X Star //水平GRAM终止位置Set X End. LCD_WriteReg(0x51,239); //Set Y Star LCD_WriteReg(0x52,0); //Set Y End.t. LCD_WriteReg(0x53,319); // LCD_WriteReg(0x60,0x2700); //Driver Output Control. LCD_WriteReg(0x61,0x0001); //Driver Output Control. LCD_WriteReg(0x6a,0x0000); //Vertical Srcoll Control. LCD_WriteReg(0x80,0x0000); //Display Position? Partial Display 1. LCD_WriteReg(0x81,0x0000); //RAM Address Start? Partial Display 1. LCD_WriteReg(0x82,0x0000); //RAM Address End-Partial Display 1. LCD_WriteReg(0x83,0x0000); //Displsy Position? Partial Display 2. LCD_WriteReg(0x84,0x0000); //RAM Address Start? Partial Display 2. LCD_WriteReg(0x85,0x0000); //RAM Address End? Partial Display 2. LCD_WriteReg(0x90,(0&lt;&lt;7)|(16&lt;&lt;0)); //Frame Cycle Contral.(0x0013) LCD_WriteReg(0x92,0x0000); //Panel Interface Contral 2.(0x0000) LCD_WriteReg(0x93,0x0001); //Panel Interface Contral 3. LCD_WriteReg(0x95,0x0110); //Frame Cycle Contral.(0x0110) LCD_WriteReg(0x97,(0&lt;&lt;8)); // LCD_WriteReg(0x98,0x0000); //Frame Cycle Contral. LCD_WriteReg(0x07,0x0173); //(0x0173) &#125;else if(lcddev.id==0X9331)//OK |/|/| &#123; LCD_WriteReg(0x00E7, 0x1014); LCD_WriteReg(0x0001, 0x0100); // set SS and SM bit LCD_WriteReg(0x0002, 0x0200); // set 1 line inversion LCD_WriteReg(0x0003,(1&lt;&lt;12)|(3&lt;&lt;4)|(1&lt;&lt;3));//65K //LCD_WriteReg(0x0003, 0x1030); // set GRAM write direction and BGR=1. LCD_WriteReg(0x0008, 0x0202); // set the back porch and front porch LCD_WriteReg(0x0009, 0x0000); // set non-display area refresh cycle ISC[3:0] LCD_WriteReg(0x000A, 0x0000); // FMARK function LCD_WriteReg(0x000C, 0x0000); // RGB interface setting LCD_WriteReg(0x000D, 0x0000); // Frame marker Position LCD_WriteReg(0x000F, 0x0000); // RGB interface polarity //*************Power On sequence ****************// LCD_WriteReg(0x0010, 0x0000); // SAP, BT[3:0], AP, DSTB, SLP, STB LCD_WriteReg(0x0011, 0x0007); // DC1[2:0], DC0[2:0], VC[2:0] LCD_WriteReg(0x0012, 0x0000); // VREG1OUT voltage LCD_WriteReg(0x0013, 0x0000); // VDV[4:0] for VCOM amplitude delay_ms(200); // Dis-charge capacitor power voltage LCD_WriteReg(0x0010, 0x1690); // SAP, BT[3:0], AP, DSTB, SLP, STB LCD_WriteReg(0x0011, 0x0227); // DC1[2:0], DC0[2:0], VC[2:0] delay_ms(50); // Delay 50ms LCD_WriteReg(0x0012, 0x000C); // Internal reference voltage= Vci; delay_ms(50); // Delay 50ms LCD_WriteReg(0x0013, 0x0800); // Set VDV[4:0] for VCOM amplitude LCD_WriteReg(0x0029, 0x0011); // Set VCM[5:0] for VCOMH LCD_WriteReg(0x002B, 0x000B); // Set Frame Rate delay_ms(50); // Delay 50ms LCD_WriteReg(0x0020, 0x0000); // GRAM horizontal Address LCD_WriteReg(0x0021, 0x013f); // GRAM Vertical Address // ----------- Adjust the Gamma Curve ----------// LCD_WriteReg(0x0030, 0x0000); LCD_WriteReg(0x0031, 0x0106); LCD_WriteReg(0x0032, 0x0000); LCD_WriteReg(0x0035, 0x0204); LCD_WriteReg(0x0036, 0x160A); LCD_WriteReg(0x0037, 0x0707); LCD_WriteReg(0x0038, 0x0106); LCD_WriteReg(0x0039, 0x0707); LCD_WriteReg(0x003C, 0x0402); LCD_WriteReg(0x003D, 0x0C0F); //------------------ Set GRAM area ---------------// LCD_WriteReg(0x0050, 0x0000); // Horizontal GRAM Start Address LCD_WriteReg(0x0051, 0x00EF); // Horizontal GRAM End Address LCD_WriteReg(0x0052, 0x0000); // Vertical GRAM Start Address LCD_WriteReg(0x0053, 0x013F); // Vertical GRAM Start Address LCD_WriteReg(0x0060, 0x2700); // Gate Scan Line LCD_WriteReg(0x0061, 0x0001); // NDL,VLE, REV LCD_WriteReg(0x006A, 0x0000); // set scrolling line //-------------- Partial Display Control ---------// LCD_WriteReg(0x0080, 0x0000); LCD_WriteReg(0x0081, 0x0000); LCD_WriteReg(0x0082, 0x0000); LCD_WriteReg(0x0083, 0x0000); LCD_WriteReg(0x0084, 0x0000); LCD_WriteReg(0x0085, 0x0000); //-------------- Panel Control -------------------// LCD_WriteReg(0x0090, 0x0010); LCD_WriteReg(0x0092, 0x0600); LCD_WriteReg(0x0007, 0x0133); // 262K color and display ON &#125;else if(lcddev.id==0x5408) &#123; LCD_WriteReg(0x01,0x0100); LCD_WriteReg(0x02,0x0700);//LCD Driving Waveform Contral LCD_WriteReg(0x03,0x1030);//Entry Mode设置 //指针从左至右自上而下的自动增模式 //Normal Mode(Window Mode disable) //RGB格式 //16位数据2次传输的8总线设置 LCD_WriteReg(0x04,0x0000); //Scalling Control register LCD_WriteReg(0x08,0x0207); //Display Control 2 LCD_WriteReg(0x09,0x0000); //Display Control 3 LCD_WriteReg(0x0A,0x0000); //Frame Cycle Control LCD_WriteReg(0x0C,0x0000); //External Display Interface Control 1 LCD_WriteReg(0x0D,0x0000); //Frame Maker Position LCD_WriteReg(0x0F,0x0000); //External Display Interface Control 2 delay_ms(20); //TFT 液晶彩色图像显示方法14 LCD_WriteReg(0x10,0x16B0); //0x14B0 //Power Control 1 LCD_WriteReg(0x11,0x0001); //0x0007 //Power Control 2 LCD_WriteReg(0x17,0x0001); //0x0000 //Power Control 3 LCD_WriteReg(0x12,0x0138); //0x013B //Power Control 4 LCD_WriteReg(0x13,0x0800); //0x0800 //Power Control 5 LCD_WriteReg(0x29,0x0009); //NVM read data 2 LCD_WriteReg(0x2a,0x0009); //NVM read data 3 LCD_WriteReg(0xa4,0x0000); LCD_WriteReg(0x50,0x0000); //设置操作窗口的X轴开始列 LCD_WriteReg(0x51,0x00EF); //设置操作窗口的X轴结束列 LCD_WriteReg(0x52,0x0000); //设置操作窗口的Y轴开始行 LCD_WriteReg(0x53,0x013F); //设置操作窗口的Y轴结束行 LCD_WriteReg(0x60,0x2700); //Driver Output Control //设置屏幕的点数以及扫描的起始行 LCD_WriteReg(0x61,0x0001); //Driver Output Control LCD_WriteReg(0x6A,0x0000); //Vertical Scroll Control LCD_WriteReg(0x80,0x0000); //Display Position – Partial Display 1 LCD_WriteReg(0x81,0x0000); //RAM Address Start – Partial Display 1 LCD_WriteReg(0x82,0x0000); //RAM address End - Partial Display 1 LCD_WriteReg(0x83,0x0000); //Display Position – Partial Display 2 LCD_WriteReg(0x84,0x0000); //RAM Address Start – Partial Display 2 LCD_WriteReg(0x85,0x0000); //RAM address End – Partail Display2 LCD_WriteReg(0x90,0x0013); //Frame Cycle Control LCD_WriteReg(0x92,0x0000); //Panel Interface Control 2 LCD_WriteReg(0x93,0x0003); //Panel Interface control 3 LCD_WriteReg(0x95,0x0110); //Frame Cycle Control LCD_WriteReg(0x07,0x0173); delay_ms(50); &#125; else if(lcddev.id==0x1505)//OK &#123; // second release on 3/5 ,luminance is acceptable,water wave appear during camera preview LCD_WriteReg(0x0007,0x0000); delay_ms(50); LCD_WriteReg(0x0012,0x011C);//0x011A why need to set several times? LCD_WriteReg(0x00A4,0x0001);//NVM LCD_WriteReg(0x0008,0x000F); LCD_WriteReg(0x000A,0x0008); LCD_WriteReg(0x000D,0x0008); //伽马校正 LCD_WriteReg(0x0030,0x0707); LCD_WriteReg(0x0031,0x0007); //0x0707 LCD_WriteReg(0x0032,0x0603); LCD_WriteReg(0x0033,0x0700); LCD_WriteReg(0x0034,0x0202); LCD_WriteReg(0x0035,0x0002); //?0x0606 LCD_WriteReg(0x0036,0x1F0F); LCD_WriteReg(0x0037,0x0707); //0x0f0f 0x0105 LCD_WriteReg(0x0038,0x0000); LCD_WriteReg(0x0039,0x0000); LCD_WriteReg(0x003A,0x0707); LCD_WriteReg(0x003B,0x0000); //0x0303 LCD_WriteReg(0x003C,0x0007); //?0x0707 LCD_WriteReg(0x003D,0x0000); //0x1313//0x1f08 delay_ms(50); LCD_WriteReg(0x0007,0x0001); LCD_WriteReg(0x0017,0x0001);//开启电源 delay_ms(50); //电源配置 LCD_WriteReg(0x0010,0x17A0); LCD_WriteReg(0x0011,0x0217);//reference voltage VC[2:0] Vciout = 1.00*Vcivl LCD_WriteReg(0x0012,0x011E);//0x011c //Vreg1out = Vcilvl*1.80 is it the same as Vgama1out ? LCD_WriteReg(0x0013,0x0F00);//VDV[4:0]--&gt;VCOM Amplitude VcomL = VcomH - Vcom Ampl LCD_WriteReg(0x002A,0x0000); LCD_WriteReg(0x0029,0x000A);//0x0001F Vcomh = VCM1[4:0]*Vreg1out gate source voltage?? LCD_WriteReg(0x0012,0x013E);// 0x013C power supply on //Coordinates Control// LCD_WriteReg(0x0050,0x0000);//0x0e00 LCD_WriteReg(0x0051,0x00EF); LCD_WriteReg(0x0052,0x0000); LCD_WriteReg(0x0053,0x013F); //Pannel Image Control// LCD_WriteReg(0x0060,0x2700); LCD_WriteReg(0x0061,0x0001); LCD_WriteReg(0x006A,0x0000); LCD_WriteReg(0x0080,0x0000); //Partial Image Control// LCD_WriteReg(0x0081,0x0000); LCD_WriteReg(0x0082,0x0000); LCD_WriteReg(0x0083,0x0000); LCD_WriteReg(0x0084,0x0000); LCD_WriteReg(0x0085,0x0000); //Panel Interface Control// LCD_WriteReg(0x0090,0x0013);//0x0010 frenqucy LCD_WriteReg(0x0092,0x0300); LCD_WriteReg(0x0093,0x0005); LCD_WriteReg(0x0095,0x0000); LCD_WriteReg(0x0097,0x0000); LCD_WriteReg(0x0098,0x0000); LCD_WriteReg(0x0001,0x0100); LCD_WriteReg(0x0002,0x0700); LCD_WriteReg(0x0003,0x1038);//扫描方向 上-&gt;下 左-&gt;右 LCD_WriteReg(0x0004,0x0000); LCD_WriteReg(0x000C,0x0000); LCD_WriteReg(0x000F,0x0000); LCD_WriteReg(0x0020,0x0000); LCD_WriteReg(0x0021,0x0000); LCD_WriteReg(0x0007,0x0021); delay_ms(20); LCD_WriteReg(0x0007,0x0061); delay_ms(20); LCD_WriteReg(0x0007,0x0173); delay_ms(20); &#125;else if(lcddev.id==0xB505) &#123; LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x00a4,0x0001); delay_ms(20); LCD_WriteReg(0x0060,0x2700); LCD_WriteReg(0x0008,0x0202); LCD_WriteReg(0x0030,0x0214); LCD_WriteReg(0x0031,0x3715); LCD_WriteReg(0x0032,0x0604); LCD_WriteReg(0x0033,0x0e16); LCD_WriteReg(0x0034,0x2211); LCD_WriteReg(0x0035,0x1500); LCD_WriteReg(0x0036,0x8507); LCD_WriteReg(0x0037,0x1407); LCD_WriteReg(0x0038,0x1403); LCD_WriteReg(0x0039,0x0020); LCD_WriteReg(0x0090,0x001a); LCD_WriteReg(0x0010,0x0000); LCD_WriteReg(0x0011,0x0007); LCD_WriteReg(0x0012,0x0000); LCD_WriteReg(0x0013,0x0000); delay_ms(20); LCD_WriteReg(0x0010,0x0730); LCD_WriteReg(0x0011,0x0137); delay_ms(20); LCD_WriteReg(0x0012,0x01b8); delay_ms(20); LCD_WriteReg(0x0013,0x0f00); LCD_WriteReg(0x002a,0x0080); LCD_WriteReg(0x0029,0x0048); delay_ms(20); LCD_WriteReg(0x0001,0x0100); LCD_WriteReg(0x0002,0x0700); LCD_WriteReg(0x0003,0x1038);//扫描方向 上-&gt;下 左-&gt;右 LCD_WriteReg(0x0008,0x0202); LCD_WriteReg(0x000a,0x0000); LCD_WriteReg(0x000c,0x0000); LCD_WriteReg(0x000d,0x0000); LCD_WriteReg(0x000e,0x0030); LCD_WriteReg(0x0050,0x0000); LCD_WriteReg(0x0051,0x00ef); LCD_WriteReg(0x0052,0x0000); LCD_WriteReg(0x0053,0x013f); LCD_WriteReg(0x0060,0x2700); LCD_WriteReg(0x0061,0x0001); LCD_WriteReg(0x006a,0x0000); //LCD_WriteReg(0x0080,0x0000); //LCD_WriteReg(0x0081,0x0000); LCD_WriteReg(0x0090,0X0011); LCD_WriteReg(0x0092,0x0600); LCD_WriteReg(0x0093,0x0402); LCD_WriteReg(0x0094,0x0002); delay_ms(20); LCD_WriteReg(0x0007,0x0001); delay_ms(20); LCD_WriteReg(0x0007,0x0061); LCD_WriteReg(0x0007,0x0173); LCD_WriteReg(0x0020,0x0000); LCD_WriteReg(0x0021,0x0000); LCD_WriteReg(0x00,0x22); &#125;else if(lcddev.id==0xC505) &#123; LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); delay_ms(20); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x00a4,0x0001); delay_ms(20); LCD_WriteReg(0x0060,0x2700); LCD_WriteReg(0x0008,0x0806); LCD_WriteReg(0x0030,0x0703);//gamma setting LCD_WriteReg(0x0031,0x0001); LCD_WriteReg(0x0032,0x0004); LCD_WriteReg(0x0033,0x0102); LCD_WriteReg(0x0034,0x0300); LCD_WriteReg(0x0035,0x0103); LCD_WriteReg(0x0036,0x001F); LCD_WriteReg(0x0037,0x0703); LCD_WriteReg(0x0038,0x0001); LCD_WriteReg(0x0039,0x0004); LCD_WriteReg(0x0090, 0x0015); //80Hz LCD_WriteReg(0x0010, 0X0410); //BT,AP LCD_WriteReg(0x0011,0x0247); //DC1,DC0,VC LCD_WriteReg(0x0012, 0x01BC); LCD_WriteReg(0x0013, 0x0e00); delay_ms(120); LCD_WriteReg(0x0001, 0x0100); LCD_WriteReg(0x0002, 0x0200); LCD_WriteReg(0x0003, 0x1030); LCD_WriteReg(0x000A, 0x0008); LCD_WriteReg(0x000C, 0x0000); LCD_WriteReg(0x000E, 0x0020); LCD_WriteReg(0x000F, 0x0000); LCD_WriteReg(0x0020, 0x0000); //H Start LCD_WriteReg(0x0021, 0x0000); //V Start LCD_WriteReg(0x002A,0x003D); //vcom2 delay_ms(20); LCD_WriteReg(0x0029, 0x002d); LCD_WriteReg(0x0050, 0x0000); LCD_WriteReg(0x0051, 0xD0EF); LCD_WriteReg(0x0052, 0x0000); LCD_WriteReg(0x0053, 0x013F); LCD_WriteReg(0x0061, 0x0000); LCD_WriteReg(0x006A, 0x0000); LCD_WriteReg(0x0092,0x0300); LCD_WriteReg(0x0093, 0x0005); LCD_WriteReg(0x0007, 0x0100); &#125;else if(lcddev.id==0x4531)//OK |/|/| &#123; LCD_WriteReg(0X00,0X0001); delay_ms(10); LCD_WriteReg(0X10,0X1628); LCD_WriteReg(0X12,0X000e);//0x0006 LCD_WriteReg(0X13,0X0A39); delay_ms(10); LCD_WriteReg(0X11,0X0040); LCD_WriteReg(0X15,0X0050); delay_ms(10); LCD_WriteReg(0X12,0X001e);//16 delay_ms(10); LCD_WriteReg(0X10,0X1620); LCD_WriteReg(0X13,0X2A39); delay_ms(10); LCD_WriteReg(0X01,0X0100); LCD_WriteReg(0X02,0X0300); LCD_WriteReg(0X03,0X1038);//改变方向的 LCD_WriteReg(0X08,0X0202); LCD_WriteReg(0X0A,0X0008); LCD_WriteReg(0X30,0X0000); LCD_WriteReg(0X31,0X0402); LCD_WriteReg(0X32,0X0106); LCD_WriteReg(0X33,0X0503); LCD_WriteReg(0X34,0X0104); LCD_WriteReg(0X35,0X0301); LCD_WriteReg(0X36,0X0707); LCD_WriteReg(0X37,0X0305); LCD_WriteReg(0X38,0X0208); LCD_WriteReg(0X39,0X0F0B); LCD_WriteReg(0X41,0X0002); LCD_WriteReg(0X60,0X2700); LCD_WriteReg(0X61,0X0001); LCD_WriteReg(0X90,0X0210); LCD_WriteReg(0X92,0X010A); LCD_WriteReg(0X93,0X0004); LCD_WriteReg(0XA0,0X0100); LCD_WriteReg(0X07,0X0001); LCD_WriteReg(0X07,0X0021); LCD_WriteReg(0X07,0X0023); LCD_WriteReg(0X07,0X0033); LCD_WriteReg(0X07,0X0133); LCD_WriteReg(0XA0,0X0000); &#125;else if(lcddev.id==0x4535) &#123; LCD_WriteReg(0X15,0X0030); LCD_WriteReg(0X9A,0X0010); LCD_WriteReg(0X11,0X0020); LCD_WriteReg(0X10,0X3428); LCD_WriteReg(0X12,0X0002);//16 LCD_WriteReg(0X13,0X1038); delay_ms(40); LCD_WriteReg(0X12,0X0012);//16 delay_ms(40); LCD_WriteReg(0X10,0X3420); LCD_WriteReg(0X13,0X3038); delay_ms(70); LCD_WriteReg(0X30,0X0000); LCD_WriteReg(0X31,0X0402); LCD_WriteReg(0X32,0X0307); LCD_WriteReg(0X33,0X0304); LCD_WriteReg(0X34,0X0004); LCD_WriteReg(0X35,0X0401); LCD_WriteReg(0X36,0X0707); LCD_WriteReg(0X37,0X0305); LCD_WriteReg(0X38,0X0610); LCD_WriteReg(0X39,0X0610); LCD_WriteReg(0X01,0X0100); LCD_WriteReg(0X02,0X0300); LCD_WriteReg(0X03,0X1030);//改变方向的 LCD_WriteReg(0X08,0X0808); LCD_WriteReg(0X0A,0X0008); LCD_WriteReg(0X60,0X2700); LCD_WriteReg(0X61,0X0001); LCD_WriteReg(0X90,0X013E); LCD_WriteReg(0X92,0X0100); LCD_WriteReg(0X93,0X0100); LCD_WriteReg(0XA0,0X3000); LCD_WriteReg(0XA3,0X0010); LCD_WriteReg(0X07,0X0001); LCD_WriteReg(0X07,0X0021); LCD_WriteReg(0X07,0X0023); LCD_WriteReg(0X07,0X0033); LCD_WriteReg(0X07,0X0133); &#125;else if(lcddev.id==0X1963) &#123; LCD_WR_REG(0xE2); //Set PLL with OSC = 10MHz (hardware), Multiplier N = 35, 250MHz &lt; VCO &lt; 800MHz = OSC*(N+1), VCO = 360MHz LCD_WR_DATA(0x23); //参数1 LCD_WR_DATA(0x02); //参数2 Divider M = 2, PLL = 360/(M+1) = 120MHz LCD_WR_DATA(0x04); //参数3 Validate M and N values delay_us(100); LCD_WR_REG(0xE0); // Start PLL command LCD_WR_DATA(0x01); // enable PLL delay_ms(10); LCD_WR_REG(0xE0); // Start PLL command again LCD_WR_DATA(0x03); // now, use PLL output as system clock delay_ms(12); LCD_WR_REG(0x01); //软复位 delay_ms(10); LCD_WR_REG(0xE6); //设置像素频率 LCD_WR_DATA(0x03); LCD_WR_DATA(0xFF); LCD_WR_DATA(0xFF); LCD_WR_REG(0xB0); //设置LCD模式 LCD_WR_DATA(0x20); //24位模式 LCD_WR_DATA(0x00); //TFT 模式 LCD_WR_DATA((SSD_HOR_RESOLUTION-1)&gt;&gt;8);//设置LCD水平像素 LCD_WR_DATA(SSD_HOR_RESOLUTION-1); LCD_WR_DATA((SSD_VER_RESOLUTION-1)&gt;&gt;8);//设置LCD垂直像素 LCD_WR_DATA(SSD_VER_RESOLUTION-1); LCD_WR_DATA(0x00); //RGB序列 LCD_WR_REG(0xB4); //Set horizontal period LCD_WR_DATA((SSD_HT-1)&gt;&gt;8); LCD_WR_DATA(SSD_HT-1); LCD_WR_DATA((SSD_HPS-1)&gt;&gt;8); LCD_WR_DATA(SSD_HPS-1); LCD_WR_DATA(SSD_HOR_PULSE_WIDTH-1); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xB6); //Set vertical period LCD_WR_DATA((SSD_VT-1)&gt;&gt;8); LCD_WR_DATA(SSD_VT-1); LCD_WR_DATA((SSD_VSP-1)&gt;&gt;8); LCD_WR_DATA(SSD_VSP-1); LCD_WR_DATA(SSD_VER_FRONT_PORCH-1); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xF0); //设置SSD1963与CPU接口为16bit LCD_WR_DATA(0x03); //16-bit(565 format) data for 16bpp LCD_WR_REG(0x29); //开启显示 //设置PWM输出 背光通过占空比可调 LCD_WR_REG(0xD0); //设置自动白平衡DBC LCD_WR_DATA(0x00); //disable LCD_WR_REG(0xBE); //配置PWM输出 LCD_WR_DATA(0x05); //1设置PWM频率 LCD_WR_DATA(0xFE); //2设置PWM占空比 LCD_WR_DATA(0x01); //3设置C LCD_WR_DATA(0xFF); //4设置D LCD_WR_DATA(0x00); //5设置E LCD_WR_REG(0xB8); //设置GPIO配置 LCD_WR_DATA(0x0F); //4个IO口设置成输出 LCD_WR_DATA(0x01); //GPIO使用正常的IO功能 LCD_WR_REG(0xBA); LCD_WR_DATA(0X01); //GPIO[1:0]=01,控制LCD方向 LCD_SSD_BackLightSet(100);//背光设置为最亮 &#125; LCD_Display_Dir(0); //默认为竖屏 LCD_LED=1; //点亮背光 LCD_Clear(WHITE);&#125; //清屏函数//color:要清屏的填充色void LCD_Clear(u16 color)&#123; u32 index=0; u32 totalpoint=lcddev.width; totalpoint*=lcddev.height; //得到总点数 if((lcddev.id==0X6804)&amp;&amp;(lcddev.dir==1))//6804横屏的时候特殊处理 &#123; lcddev.dir=0; lcddev.setxcmd=0X2A; lcddev.setycmd=0X2B; LCD_SetCursor(0x00,0x0000); //设置光标位置 lcddev.dir=1; lcddev.setxcmd=0X2B; lcddev.setycmd=0X2A; &#125;else LCD_SetCursor(0x00,0x0000); //设置光标位置 LCD_WriteRAM_Prepare(); //开始写入GRAM for(index=0;index&lt;totalpoint;index++) &#123; LCD-&gt;LCD_RAM=color; &#125;&#125; //在指定区域内填充单个颜色//(sx,sy),(ex,ey):填充矩形对角坐标,区域大小为:(ex-sx+1)*(ey-sy+1) //color:要填充的颜色void LCD_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 color)&#123; u16 i,j; u16 xlen=0; u16 temp; if((lcddev.id==0X6804)&amp;&amp;(lcddev.dir==1)) //6804横屏的时候特殊处理 &#123; temp=sx; sx=sy; sy=lcddev.width-ex-1; ex=ey; ey=lcddev.width-temp-1; lcddev.dir=0; lcddev.setxcmd=0X2A; lcddev.setycmd=0X2B; LCD_Fill(sx,sy,ex,ey,color); lcddev.dir=1; lcddev.setxcmd=0X2B; lcddev.setycmd=0X2A; &#125;else &#123; xlen=ex-sx+1; for(i=sy;i&lt;=ey;i++) &#123; LCD_SetCursor(sx,i); //设置光标位置 LCD_WriteRAM_Prepare(); //开始写入GRAM for(j=0;j&lt;xlen;j++)LCD-&gt;LCD_RAM=color; //显示颜色 &#125; &#125; &#125; //在指定区域内填充指定颜色块 //(sx,sy),(ex,ey):填充矩形对角坐标,区域大小为:(ex-sx+1)*(ey-sy+1) //color:要填充的颜色void LCD_Color_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 *color)&#123; u16 height,width; u16 i,j; width=ex-sx+1; //得到填充的宽度 height=ey-sy+1; //高度 for(i=0;i&lt;height;i++) &#123; LCD_SetCursor(sx,sy+i); //设置光标位置 LCD_WriteRAM_Prepare(); //开始写入GRAM for(j=0;j&lt;width;j++)LCD-&gt;LCD_RAM=color[i*width+j];//写入数据 &#125; &#125; //画线//x1,y1:起点坐标//x2,y2:终点坐标 void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2)&#123; u16 t; int xerr=0,yerr=0,delta_x,delta_y,distance; int incx,incy,uRow,uCol; delta_x=x2-x1; //计算坐标增量 delta_y=y2-y1; uRow=x1; uCol=y1; if(delta_x&gt;0)incx=1; //设置单步方向 else if(delta_x==0)incx=0;//垂直线 else &#123;incx=-1;delta_x=-delta_x;&#125; if(delta_y&gt;0)incy=1; else if(delta_y==0)incy=0;//水平线 else&#123;incy=-1;delta_y=-delta_y;&#125; if( delta_x&gt;delta_y)distance=delta_x; //选取基本增量坐标轴 else distance=delta_y; for(t=0;t&lt;=distance+1;t++ )//画线输出 &#123; LCD_DrawPoint(uRow,uCol);//画点 xerr+=delta_x ; yerr+=delta_y ; if(xerr&gt;distance) &#123; xerr-=distance; uRow+=incx; &#125; if(yerr&gt;distance) &#123; yerr-=distance; uCol+=incy; &#125; &#125; &#125; //画矩形 //(x1,y1),(x2,y2):矩形的对角坐标void LCD_DrawRectangle(u16 x1, u16 y1, u16 x2, u16 y2)&#123; LCD_DrawLine(x1,y1,x2,y1); LCD_DrawLine(x1,y1,x1,y2); LCD_DrawLine(x1,y2,x2,y2); LCD_DrawLine(x2,y1,x2,y2);&#125;//在指定位置画一个指定大小的圆//(x,y):中心点//r :半径void LCD_Draw_Circle(u16 x0,u16 y0,u8 r)&#123; int a,b; int di; a=0;b=r; di=3-(r&lt;&lt;1); //判断下个点位置的标志 while(a&lt;=b) &#123; LCD_DrawPoint(x0+a,y0-b); //5 LCD_DrawPoint(x0+b,y0-a); //0 LCD_DrawPoint(x0+b,y0+a); //4 LCD_DrawPoint(x0+a,y0+b); //6 LCD_DrawPoint(x0-a,y0+b); //1 LCD_DrawPoint(x0-b,y0+a); LCD_DrawPoint(x0-a,y0-b); //2 LCD_DrawPoint(x0-b,y0-a); //7 a++; //使用Bresenham算法画圆 if(di&lt;0)di +=4*a+6; else &#123; di+=10+4*(a-b); b--; &#125; &#125;&#125; //在指定位置显示一个字符//x,y:起始坐标//num:要显示的字符:&quot; &quot;---&gt;&quot;~&quot;//size:字体大小 12/16/24//mode:叠加方式(1)还是非叠加方式(0)void LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode)&#123; u8 temp,t1,t; u16 y0=y; u8 csize=(size/8+((size%8)?1:0))*(size/2); //得到字体一个字符对应点阵集所占的字节数 num=num-&#x27; &#x27;;//得到偏移后的值（ASCII字库是从空格开始取模，所以-&#x27; &#x27;就是对应字符的字库） for(t=0;t&lt;csize;t++) &#123; if(size==12)temp=asc2_1206[num][t]; //调用1206字体 else if(size==16)temp=asc2_1608[num][t]; //调用1608字体 else if(size==24)temp=asc2_2412[num][t]; //调用2412字体 else return; //没有的字库 for(t1=0;t1&lt;8;t1++) &#123; if(temp&amp;0x80)LCD_Fast_DrawPoint(x,y,POINT_COLOR); else if(mode==0)LCD_Fast_DrawPoint(x,y,BACK_COLOR); temp&lt;&lt;=1; y++; if(y&gt;=lcddev.height)return; //超区域了 if((y-y0)==size) &#123; y=y0; x++; if(x&gt;=lcddev.width)return; //超区域了 break; &#125; &#125; &#125; &#125; //m^n函数//返回值:m^n次方.u32 LCD_Pow(u8 m,u8 n)&#123; u32 result=1; while(n--)result*=m; return result;&#125; //显示数字,高位为0,则不显示//x,y :起点坐标 //len :数字的位数//size:字体大小//color:颜色 //num:数值(0~4294967295); void LCD_ShowNum(u16 x,u16 y,u32 num,u8 len,u8 size)&#123; u8 t,temp; u8 enshow=0; for(t=0;t&lt;len;t++) &#123; temp=(num/LCD_Pow(10,len-t-1))%10; if(enshow==0&amp;&amp;t&lt;(len-1)) &#123; if(temp==0) &#123; LCD_ShowChar(x+(size/2)*t,y,&#x27; &#x27;,size,0); continue; &#125;else enshow=1; &#125; LCD_ShowChar(x+(size/2)*t,y,temp+&#x27;0&#x27;,size,0); &#125;&#125; //显示数字,高位为0,还是显示//x,y:起点坐标//num:数值(0~999999999); //len:长度(即要显示的位数)//size:字体大小//mode://[7]:0,不填充;1,填充0.//[6:1]:保留//[0]:0,非叠加显示;1,叠加显示.void LCD_ShowxNum(u16 x,u16 y,u32 num,u8 len,u8 size,u8 mode)&#123; u8 t,temp; u8 enshow=0; for(t=0;t&lt;len;t++) &#123; temp=(num/LCD_Pow(10,len-t-1))%10; if(enshow==0&amp;&amp;t&lt;(len-1)) &#123; if(temp==0) &#123; if(mode&amp;0X80)LCD_ShowChar(x+(size/2)*t,y,&#x27;0&#x27;,size,mode&amp;0X01); else LCD_ShowChar(x+(size/2)*t,y,&#x27; &#x27;,size,mode&amp;0X01); continue; &#125;else enshow=1; &#125; LCD_ShowChar(x+(size/2)*t,y,temp+&#x27;0&#x27;,size,mode&amp;0X01); &#125;&#125; //显示字符串//x,y:起点坐标//width,height:区域大小 //size:字体大小//*p:字符串起始地址 void LCD_ShowString(u16 x,u16 y,u16 width,u16 height,u8 size,u8 *p)&#123; u8 x0=x; width+=x; height+=y; while((*p&lt;=&#x27;~&#x27;)&amp;&amp;(*p&gt;=&#x27; &#x27;))//判断是不是非法字符! &#123; if(x&gt;=width)&#123;x=x0;y+=size;&#125; if(y&gt;=height)break;//退出 LCD_ShowChar(x,y,*p,size,0); x+=size/2; p++; &#125; &#125;/******************* END OF FILE *********/ lcd.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// lcd.h#ifndef __LCD_H#define __LCD_H #include &quot;sys.h&quot; #include &quot;stdlib.h&quot; //LCD重要参数集typedef struct &#123; u16 width; //LCD 宽度 u16 height; //LCD 高度 u16 id; //LCD ID u8 dir; //横屏还是竖屏控制：0，竖屏；1，横屏。 u16 wramcmd; //开始写gram指令 u16 setxcmd; //设置x坐标指令 u16 setycmd; //设置y坐标指令 &#125;_lcd_dev; //LCD参数extern _lcd_dev lcddev; //管理LCD重要参数//LCD的画笔颜色和背景色 extern u16 POINT_COLOR;//默认红色 extern u16 BACK_COLOR; //背景颜色.默认为白色////////////////////////////////////////////////////////////////////////////////// //-----------------LCD端口定义---------------- #define LCD_LED PBout(0) //LCD背光 PB0 //LCD地址结构体typedef struct&#123; vu16 LCD_REG; vu16 LCD_RAM;&#125; LCD_TypeDef;//使用NOR/SRAM的 Bank1.sector4,地址位HADDR[27,26]=11 A10作为数据命令区分线 //注意设置时STM32内部会右移一位对其! #define LCD_BASE ((u32)(0x6C000000 | 0x000007FE))#define LCD ((LCD_TypeDef *) LCD_BASE)////////////////////////////////////////////////////////////////////////////////// //扫描方向定义#define L2R_U2D 0 //从左到右,从上到下#define L2R_D2U 1 //从左到右,从下到上#define R2L_U2D 2 //从右到左,从上到下#define R2L_D2U 3 //从右到左,从下到上#define U2D_L2R 4 //从上到下,从左到右#define U2D_R2L 5 //从上到下,从右到左#define D2U_L2R 6 //从下到上,从左到右#define D2U_R2L 7 //从下到上,从右到左 #define DFT_SCAN_DIR L2R_U2D //默认的扫描方向//画笔颜色#define WHITE 0xFFFF#define BLACK 0x0000 #define BLUE 0x001F #define BRED 0XF81F#define GRED 0XFFE0#define GBLUE 0X07FF#define RED 0xF800#define MAGENTA 0xF81F#define GREEN 0x07E0#define CYAN 0x7FFF#define YELLOW 0xFFE0#define BROWN 0XBC40 //棕色#define BRRED 0XFC07 //棕红色#define GRAY 0X8430 //灰色//GUI颜色#define DARKBLUE 0X01CF //深蓝色#define LIGHTBLUE 0X7D7C //浅蓝色 #define GRAYBLUE 0X5458 //灰蓝色//以上三色为PANEL的颜色 #define LIGHTGREEN 0X841F //浅绿色//#define LIGHTGRAY 0XEF5B //浅灰色(PANNEL)#define LGRAY 0XC618 //浅灰色(PANNEL),窗体背景色#define LGRAYBLUE 0XA651 //浅灰蓝色(中间层颜色)#define LBBLUE 0X2B12 //浅棕蓝色(选择条目的反色) void LCD_Init(void); //初始化void LCD_DisplayOn(void); //开显示void LCD_DisplayOff(void); //关显示void LCD_Clear(u16 Color); //清屏void LCD_SetCursor(u16 Xpos, u16 Ypos); //设置光标void LCD_DrawPoint(u16 x,u16 y); //画点void LCD_Fast_DrawPoint(u16 x,u16 y,u16 color); //快速画点u16 LCD_ReadPoint(u16 x,u16 y); //读点 void LCD_Draw_Circle(u16 x0,u16 y0,u8 r); //画圆void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2); //画线void LCD_DrawRectangle(u16 x1, u16 y1, u16 x2, u16 y2); //画矩形void LCD_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 color); //填充单色void LCD_Color_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 *color); //填充指定颜色void LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode); //显示一个字符void LCD_ShowNum(u16 x,u16 y,u32 num,u8 len,u8 size); //显示一个数字void LCD_ShowxNum(u16 x,u16 y,u32 num,u8 len,u8 size,u8 mode); //显示 数字void LCD_ShowString(u16 x,u16 y,u16 width,u16 height,u8 size,u8 *p); //显示一个字符串,12/16字体void LCD_WriteReg(u16 LCD_Reg, u16 LCD_RegValue);u16 LCD_ReadReg(u16 LCD_Reg);void LCD_WriteRAM_Prepare(void);void LCD_WriteRAM(u16 RGB_Code);void LCD_SSD_BackLightSet(u8 pwm); //SSD1963 背光控制void LCD_Scan_Dir(u8 dir); //设置屏扫描方向void LCD_Display_Dir(u8 dir); //设置屏幕显示方向void LCD_Set_Window(u16 sx,u16 sy,u16 width,u16 height); //设置窗口 //LCD分辨率设置#define SSD_HOR_RESOLUTION 800 //LCD水平分辨率#define SSD_VER_RESOLUTION 480 //LCD垂直分辨率//LCD驱动参数设置#define SSD_HOR_PULSE_WIDTH 1 //水平脉宽#define SSD_HOR_BACK_PORCH 210 //水平前廊#define SSD_HOR_FRONT_PORCH 45 //水平后廊#define SSD_VER_PULSE_WIDTH 1 //垂直脉宽#define SSD_VER_BACK_PORCH 34 //垂直前廊#define SSD_VER_FRONT_PORCH 10 //垂直前廊//如下几个参数，自动计算#define SSD_HT (SSD_HOR_RESOLUTION+SSD_HOR_PULSE_WIDTH+SSD_HOR_BACK_PORCH+SSD_HOR_FRONT_PORCH)#define SSD_HPS (SSD_HOR_PULSE_WIDTH+SSD_HOR_BACK_PORCH)#define SSD_VT (SSD_VER_PULSE_WIDTH+SSD_VER_BACK_PORCH+SSD_VER_FRONT_PORCH+SSD_VER_RESOLUTION)#define SSD_VSP (SSD_VER_PULSE_WIDTH+SSD_VER_BACK_PORCH)#endif /******************* END OF FILE *********/ main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;lcd.h&quot;#include &quot;usart.h&quot; int main(void) &#123; u8 x=0; u8 lcd_id[12]; //存放LCD ID字符串 delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 LCD_Init(); POINT_COLOR=RED; sprintf((char*)lcd_id,&quot;LCD ID:%04X&quot;,lcddev.id);//将LCD ID打印到lcd_id数组。 while(1) &#123; switch(x) &#123; case 0:LCD_Clear(WHITE);break; case 1:LCD_Clear(BLACK);break; case 2:LCD_Clear(BLUE);break; case 3:LCD_Clear(RED);break; case 4:LCD_Clear(MAGENTA);break; case 5:LCD_Clear(GREEN);break; case 6:LCD_Clear(CYAN);break; case 7:LCD_Clear(YELLOW);break; case 8:LCD_Clear(BRRED);break; case 9:LCD_Clear(GRAY);break; case 10:LCD_Clear(LGRAY);break; case 11:LCD_Clear(BROWN);break; &#125; POINT_COLOR=RED; LCD_ShowString(30,40,210,24,24,&quot;Elite STM32F1 ^_^&quot;); LCD_ShowString(30,70,200,16,16,&quot;TFTLCD TEST&quot;); LCD_ShowString(30,90,200,16,16,&quot;ATOM@ALIENTEK&quot;); LCD_ShowString(30,110,200,16,16,lcd_id); //显示LCD ID LCD_ShowString(30,130,200,12,12,&quot;2015/1/14&quot;); x++; if(x==12)x=0; LED0=!LED0; delay_ms(1000); &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 代码片段分析 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（12）OLED显示","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-012","date":"2022-11-08T02:59:18.000Z","updated":"2023-04-05T14:19:45.345Z","comments":true,"path":"posts/3728621497.html","link":"","permalink":"https://sirius-blog.github.io/posts/3728621497.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 beep output PB8 LED0驱动 思路 调用官方库文件驱动GPIO口。 驱动 oled.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270// oled.c#include &quot;oled.h&quot;#include &quot;stdlib.h&quot;#include &quot;oledfont.h&quot; #include &quot;delay.h&quot;//OLED的显存//存放格式如下.//[0]0 1 2 3 ... 127 //[1]0 1 2 3 ... 127 //[2]0 1 2 3 ... 127 //[3]0 1 2 3 ... 127 //[4]0 1 2 3 ... 127 //[5]0 1 2 3 ... 127 //[6]0 1 2 3 ... 127 //[7]0 1 2 3 ... 127 u8 OLED_GRAM[128][8]; //更新显存到LCD void OLED_Refresh_Gram(void)&#123; u8 i,n; for(i=0;i&lt;8;i++) &#123; OLED_WR_Byte (0xb0+i,OLED_CMD); //设置页地址（0~7） OLED_WR_Byte (0x00,OLED_CMD); //设置显示位置—列低地址 OLED_WR_Byte (0x10,OLED_CMD); //设置显示位置—列高地址 for(n=0;n&lt;128;n++)OLED_WR_Byte(OLED_GRAM[n][i],OLED_DATA); &#125; &#125;#if OLED_MODE==1 //8080并口 //向SSD1306写入一个字节。//dat:要写入的数据/命令//cmd:数据/命令标志 0,表示命令;1,表示数据;void OLED_WR_Byte(u8 dat,u8 cmd)&#123; DATAOUT(dat); OLED_RS=cmd; OLED_CS=0; OLED_WR=0; OLED_WR=1; OLED_CS=1; OLED_RS=1; &#125; #else//向SSD1306写入一个字节。//dat:要写入的数据/命令//cmd:数据/命令标志 0,表示命令;1,表示数据;void OLED_WR_Byte(u8 dat,u8 cmd)&#123; u8 i; OLED_RS=cmd; //写命令 OLED_CS=0; for(i=0;i&lt;8;i++) &#123; OLED_SCLK=0; if(dat&amp;0x80)OLED_SDIN=1; else OLED_SDIN=0; OLED_SCLK=1; dat&lt;&lt;=1; &#125; OLED_CS=1; OLED_RS=1; &#125; #endif //开启OLED显示 void OLED_Display_On(void)&#123; OLED_WR_Byte(0X8D,OLED_CMD); //SET DCDC命令 OLED_WR_Byte(0X14,OLED_CMD); //DCDC ON OLED_WR_Byte(0XAF,OLED_CMD); //DISPLAY ON&#125;//关闭OLED显示 void OLED_Display_Off(void)&#123; OLED_WR_Byte(0X8D,OLED_CMD); //SET DCDC命令 OLED_WR_Byte(0X10,OLED_CMD); //DCDC OFF OLED_WR_Byte(0XAE,OLED_CMD); //DISPLAY OFF&#125; //清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!! void OLED_Clear(void) &#123; u8 i,n; for(i=0;i&lt;8;i++)for(n=0;n&lt;128;n++)OLED_GRAM[n][i]=0X00; OLED_Refresh_Gram();//更新显示&#125;//画点 //x:0~127//y:0~63//t:1 填充 0,清空 void OLED_DrawPoint(u8 x,u8 y,u8 t)&#123; u8 pos,bx,temp=0; if(x&gt;127||y&gt;63)return;//超出范围了. pos=7-y/8; bx=y%8; temp=1&lt;&lt;(7-bx); if(t)OLED_GRAM[x][pos]|=temp; else OLED_GRAM[x][pos]&amp;=~temp; &#125;//x1,y1,x2,y2 填充区域的对角坐标//确保x1&lt;=x2;y1&lt;=y2 0&lt;=x1&lt;=127 0&lt;=y1&lt;=63 //dot:0,清空;1,填充 void OLED_Fill(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot) &#123; u8 x,y; for(x=x1;x&lt;=x2;x++) &#123; for(y=y1;y&lt;=y2;y++)OLED_DrawPoint(x,y,dot); &#125; OLED_Refresh_Gram();//更新显示&#125;//在指定位置显示一个字符,包括部分字符//x:0~127//y:0~63//mode:0,反白显示;1,正常显示 //size:选择字体 12/16/24void OLED_ShowChar(u8 x,u8 y,u8 chr,u8 size,u8 mode)&#123; u8 temp,t,t1; u8 y0=y; u8 csize=(size/8+((size%8)?1:0))*(size/2); //得到字体一个字符对应点阵集所占的字节数 chr=chr-&#x27; &#x27;;//得到偏移后的值 for(t=0;t&lt;csize;t++) &#123; if(size==12)temp=asc2_1206[chr][t]; //调用1206字体 else if(size==16)temp=asc2_1608[chr][t]; //调用1608字体 else if(size==24)temp=asc2_2412[chr][t]; //调用2412字体 else return; //没有的字库 for(t1=0;t1&lt;8;t1++) &#123; if(temp&amp;0x80)OLED_DrawPoint(x,y,mode); else OLED_DrawPoint(x,y,!mode); temp&lt;&lt;=1; y++; if((y-y0)==size) &#123; y=y0; x++; break; &#125; &#125; &#125; &#125;//m^n函数u32 mypow(u8 m,u8 n)&#123; u32 result=1; while(n--)result*=m; return result;&#125; //显示2个数字//x,y :起点坐标 //len :数字的位数//size:字体大小//mode:模式 0,填充模式;1,叠加模式//num:数值(0~4294967295); void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size)&#123; u8 t,temp; u8 enshow=0; for(t=0;t&lt;len;t++) &#123; temp=(num/mypow(10,len-t-1))%10; if(enshow==0&amp;&amp;t&lt;(len-1)) &#123; if(temp==0) &#123; OLED_ShowChar(x+(size/2)*t,y,&#x27; &#x27;,size,1); continue; &#125;else enshow=1; &#125; OLED_ShowChar(x+(size/2)*t,y,temp+&#x27;0&#x27;,size,1); &#125;&#125; //显示字符串//x,y:起点坐标 //size:字体大小 //*p:字符串起始地址 void OLED_ShowString(u8 x,u8 y,const u8 *p,u8 size)&#123; while((*p&lt;=&#x27;~&#x27;)&amp;&amp;(*p&gt;=&#x27; &#x27;))//判断是不是非法字符! &#123; if(x&gt;(128-(size/2)))&#123;x=0;y+=size;&#125; if(y&gt;(64-size))&#123;y=x=0;OLED_Clear();&#125; OLED_ShowChar(x,y,*p,size,1); x+=size/2; p++; &#125; &#125; //初始化SSD1306 void OLED_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOG, ENABLE); //使能PC,D,G端口时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_6; //PD3,PD6推挽输出 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//速度50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); //初始化GPIOD3,6 GPIO_SetBits(GPIOD,GPIO_Pin_3|GPIO_Pin_6); //PD3,PD6 输出高 #if OLED_MODE==1 GPIO_InitStructure.GPIO_Pin =0xFF; //PC0~7 OUT推挽输出 GPIO_Init(GPIOC, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOC,0xFF); //PC0~7输出高 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15; //PG13,14,15 OUT推挽输出 GPIO_Init(GPIOG, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOG,GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15); //PG13,14,15 OUT 输出高 #else GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1; //PC0,1 OUT推挽输出 GPIO_Init(GPIOC, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOC,GPIO_Pin_0|GPIO_Pin_1); //PC0,1 OUT 输出高 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15; //PG15 OUT推挽输出 RST GPIO_Init(GPIOG, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOG,GPIO_Pin_15); //PG15 OUT 输出高 #endif OLED_CS=1; OLED_RS=1; OLED_RST=0; delay_ms(100); OLED_RST=1; OLED_WR_Byte(0xAE,OLED_CMD); //关闭显示 OLED_WR_Byte(0xD5,OLED_CMD); //设置时钟分频因子,震荡频率 OLED_WR_Byte(80,OLED_CMD); //[3:0],分频因子;[7:4],震荡频率 OLED_WR_Byte(0xA8,OLED_CMD); //设置驱动路数 OLED_WR_Byte(0X3F,OLED_CMD); //默认0X3F(1/64) OLED_WR_Byte(0xD3,OLED_CMD); //设置显示偏移 OLED_WR_Byte(0X00,OLED_CMD); //默认为0 OLED_WR_Byte(0x40,OLED_CMD); //设置显示开始行 [5:0],行数. OLED_WR_Byte(0x8D,OLED_CMD); //电荷泵设置 OLED_WR_Byte(0x14,OLED_CMD); //bit2，开启/关闭 OLED_WR_Byte(0x20,OLED_CMD); //设置内存地址模式 OLED_WR_Byte(0x02,OLED_CMD); //[1:0],00，列地址模式;01，行地址模式;10,页地址模式;默认10; OLED_WR_Byte(0xA1,OLED_CMD); //段重定义设置,bit0:0,0-&gt;0;1,0-&gt;127; OLED_WR_Byte(0xC0,OLED_CMD); //设置COM扫描方向;bit3:0,普通模式;1,重定义模式 COM[N-1]-&gt;COM0;N:驱动路数 OLED_WR_Byte(0xDA,OLED_CMD); //设置COM硬件引脚配置 OLED_WR_Byte(0x12,OLED_CMD); //[5:4]配置 OLED_WR_Byte(0x81,OLED_CMD); //对比度设置 OLED_WR_Byte(0xEF,OLED_CMD); //1~255;默认0X7F (亮度设置,越大越亮) OLED_WR_Byte(0xD9,OLED_CMD); //设置预充电周期 OLED_WR_Byte(0xf1,OLED_CMD); //[3:0],PHASE 1;[7:4],PHASE 2; OLED_WR_Byte(0xDB,OLED_CMD); //设置VCOMH 电压倍率 OLED_WR_Byte(0x30,OLED_CMD); //[6:4] 000,0.65*vcc;001,0.77*vcc;011,0.83*vcc; OLED_WR_Byte(0xA4,OLED_CMD); //全局显示开启;bit0:1,开启;0,关闭;(白屏/黑屏) OLED_WR_Byte(0xA6,OLED_CMD); //设置显示方式;bit0:1,反相显示;0,正常显示 OLED_WR_Byte(0xAF,OLED_CMD); //开启显示 OLED_Clear();&#125; /******************* END OF FILE *********/ oled.h 12345678910111213141516171819202122232425262728293031323334353637383940414243// oled.h#ifndef __OLED_H#define __OLED_H #include &quot;sys.h&quot;#include &quot;stdlib.h&quot; //OLED模式设置//0: 4线串行模式 （模块的BS1，BS2均接GND）//1: 并行8080模式 （模块的BS1，BS2均接VCC）#define OLED_MODE 1 //---------------------------OLED端口定义-------------------------- #define OLED_CS PDout(6)#define OLED_RST PGout(15) #define OLED_RS PDout(3)#define OLED_WR PGout(14) #define OLED_RD PGout(13) //PC0~7,作为数据线 #define DATAOUT(x) GPIO_Write(GPIOC,x);//输出 //使用4线串行接口时使用 #define OLED_SCLK PCout(0)#define OLED_SDIN PCout(1) #define OLED_CMD 0 //写命令#define OLED_DATA 1 //写数据//OLED控制用函数void OLED_WR_Byte(u8 dat,u8 cmd); void OLED_Display_On(void);void OLED_Display_Off(void);void OLED_Refresh_Gram(void); void OLED_Init(void);void OLED_Clear(void);void OLED_DrawPoint(u8 x,u8 y,u8 t);void OLED_Fill(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot);void OLED_ShowChar(u8 x,u8 y,u8 chr,u8 size,u8 mode);void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size);void OLED_ShowString(u8 x,u8 y,const u8 *p,u8 size); #endif /******************* END OF FILE *********/ main.c 123456789101112131415161718192021222324252627282930313233343536//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;oled.h&quot; int main(void) &#123; u8 t; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 LED_Init(); //LED端口初始化 OLED_Init(); //初始化OLED OLED_ShowString(0,0,&quot;ALIENTEK&quot;,24); OLED_ShowString(0,24, &quot;0.96&#x27; OLED TEST&quot;,16); OLED_ShowString(0,40,&quot;ATOM 2015/1/14&quot;,12); OLED_ShowString(0,52,&quot;ASCII:&quot;,12); OLED_ShowString(64,52,&quot;CODE:&quot;,12); OLED_Refresh_Gram(); //更新显示到OLED t=&#x27; &#x27;; while(1) &#123; OLED_ShowChar(48,48,t,16,1);//显示ASCII字符 OLED_Refresh_Gram(); t++; if(t&gt;&#x27;~&#x27;)t=&#x27; &#x27;; OLED_ShowNum(103,48,t,3,16);//显示ASCII字符的码值 delay_ms(500); LED0=!LED0; &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 代码片段分析 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（11）触摸按键","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-011","date":"2022-11-08T02:39:18.000Z","updated":"2023-04-05T14:19:36.208Z","comments":true,"path":"posts/2323345083.html","link":"","permalink":"https://sirius-blog.github.io/posts/2323345083.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 beep output PB8 LED0驱动 思路 调用官方库文件驱动GPIO口。 驱动 tpad.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// tpad.c#include &quot;tpad.h&quot;#include &quot;delay.h&quot; #include &quot;usart.h&quot;#define TPAD_ARR_MAX_VAL 0XFFFF //最大的ARR值vu16 tpad_default_val=0;//空载的时候(没有手按下),计数器需要的时间//初始化触摸按键//获得空载的时候触摸按键的取值.//返回值:0,初始化成功;1,初始化失败u8 TPAD_Init(u8 psc)&#123; u16 buf[10]; u16 temp; u8 j,i; TIM5_CH2_Cap_Init(TPAD_ARR_MAX_VAL,psc-1);//以1Mhz的频率计数 for(i=0;i&lt;10;i++)//连续读取10次 &#123; buf[i]=TPAD_Get_Val(); delay_ms(10); &#125; for(i=0;i&lt;9;i++)//排序 &#123; for(j=i+1;j&lt;10;j++) &#123; if(buf[i]&gt;buf[j])//升序排列 &#123; temp=buf[i]; buf[i]=buf[j]; buf[j]=temp; &#125; &#125; &#125; temp=0; for(i=2;i&lt;8;i++)temp+=buf[i];//取中间的6个数据进行平均 tpad_default_val=temp/6; printf(&quot;tpad_default_val:%d\\r\\n&quot;,tpad_default_val); if(tpad_default_val&gt;TPAD_ARR_MAX_VAL/2)return 1;//初始化遇到超过TPAD_ARR_MAX_VAL/2的数值,不正常! return 0; &#125;//复位一次void TPAD_Reset(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //使能PA端口时钟 //设置GPIOA.1为推挽使出 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; //PA1 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_ResetBits(GPIOA,GPIO_Pin_1); //PA.1输出0,放电 delay_ms(5); TIM_SetCounter(TIM5,0); //归0 TIM_ClearITPendingBit(TIM5, TIM_IT_CC2|TIM_IT_Update); //清除中断标志 //设置GPIOA.1为浮空输入 GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); &#125;//得到定时器捕获值//如果超时,则直接返回定时器的计数值.u16 TPAD_Get_Val(void)&#123; TPAD_Reset(); while(TIM_GetFlagStatus(TIM5, TIM_IT_CC2) == RESET)//等待捕获上升沿 &#123; if(TIM_GetCounter(TIM5)&gt;TPAD_ARR_MAX_VAL-500)return TIM_GetCounter(TIM5);//超时了,直接返回CNT的值 &#125;; return TIM_GetCapture2(TIM5); &#125; //读取n次,取最大值//n：连续获取的次数//返回值：n次读数里面读到的最大读数值u16 TPAD_Get_MaxVal(u8 n)&#123; u16 temp=0; u16 res=0; while(n--) &#123; temp=TPAD_Get_Val();//得到一次值 if(temp&gt;res)res=temp; &#125;; return res;&#125; //扫描触摸按键//mode:0,不支持连续触发(按下一次必须松开才能按下一次);1,支持连续触发(可以一直按下)//返回值:0,没有按下;1,有按下; #define TPAD_GATE_VAL 100 //触摸的门限值,也就是必须大于tpad_default_val+TPAD_GATE_VAL,才认为是有效触摸.u8 TPAD_Scan(u8 mode)&#123; static u8 keyen=0; //0,可以开始检测;&gt;0,还不能开始检测 u8 res=0; u8 sample=3; //默认采样次数为3次 u16 rval; if(mode) &#123; sample=6; //支持连按的时候，设置采样次数为6次 keyen=0; //支持连按 &#125; rval=TPAD_Get_MaxVal(sample); if(rval&gt;(tpad_default_val+TPAD_GATE_VAL))//大于tpad_default_val+TPAD_GATE_VAL,有效 &#123; if(keyen==0)res=1; //keyen==0,有效 //printf(&quot;r:%d\\r\\n&quot;,rval); keyen=3; //至少要再过3次之后才能按键有效 &#125; if(keyen)keyen--; return res;&#125; //定时器2通道2输入捕获配置void TIM5_CH2_Cap_Init(u16 arr,u16 psc)&#123; GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_ICInitTypeDef TIM5_ICInitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); //使能TIM5时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //使能PA端口时钟 //设置GPIOA.1为浮空输入 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; //PA1 端口配置 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //速度50MHz GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //设置为浮空输入 //初始化TIM5 TIM_TimeBaseStructure.TIM_Period = arr; //设定计数器自动重装值 TIM_TimeBaseStructure.TIM_Prescaler =psc; //预分频器 TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM向上计数模式 TIM_TimeBaseInit(TIM5, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位 //初始化通道2 TIM5_ICInitStructure.TIM_Channel = TIM_Channel_2; //CC1S=01 选择输入端 IC2映射到TI5上 TIM5_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; //上升沿捕获 TIM5_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; TIM5_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; //配置输入分频,不分频 TIM5_ICInitStructure.TIM_ICFilter = 0x03;//IC2F=0011 配置输入滤波器 8个定时器时钟周期滤波 TIM_ICInit(TIM5, &amp;TIM5_ICInitStructure);//初始化I5 IC2 TIM_Cmd(TIM5,ENABLE ); //使能定时器5&#125;/******************* END OF FILE *********/ tpad.h 12345678910111213141516// tpad.h#ifndef __TPAD_H#define __TPAD_H#include &quot;sys.h&quot; extern vu16 tpad_default_val; void TPAD_Reset(void);u16 TPAD_Get_Val(void);u16 TPAD_Get_MaxVal(u8 n);u8 TPAD_Init(u8 psc);u8 TPAD_Scan(u8 mode);void TIM5_CH2_Cap_Init(u16 arr,u16 psc); #endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031323334//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;tpad.h&quot; int main(void) &#123; u8 t=0; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 TPAD_Init(6); //初始化触摸按键 while(1) &#123; if(TPAD_Scan(0)) //成功捕获到了一次上升沿(此函数执行时间至少15ms) &#123; LED1=!LED1; //LED1取反 &#125; t++; if(t==15) &#123; t=0; LED0=!LED0; //LED0取反,提示程序正在运行 &#125; delay_ms(10); &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 代码片段分析 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（10）输入捕获","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-010","date":"2022-11-08T02:19:18.000Z","updated":"2023-04-05T14:19:19.975Z","comments":true,"path":"posts/1244416953.html","link":"","permalink":"https://sirius-blog.github.io/posts/1244416953.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 beep output PB8 LED0驱动 思路 调用官方库文件驱动GPIO口。 驱动 timer.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191// timer.c#include &quot;timer.h&quot;#include &quot;led.h&quot;#include &quot;usart.h&quot;//通用定时器中断初始化//这里时钟选择为APB1的2倍，而APB1为36M//arr：自动重装值。//psc：时钟预分频数//这里使用的是定时器3!void TIM3_Int_Init(u16 arr,u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能 TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值 计数到5000为500ms TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值 10Khz的计数频率 TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM向上计数模式 TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位 TIM_ITConfig( //使能或者失能指定的TIM中断 TIM3, //TIM2 TIM_IT_Update | //TIM 中断源 TIM_IT_Trigger, //TIM 触发中断源 ENABLE //使能 ); NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; //TIM3中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //先占优先级0级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //从优先级3级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 TIM_Cmd(TIM3, ENABLE); //使能TIMx外设 &#125;void TIM3_IRQHandler(void) //TIM3中断&#123; if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否:TIM 中断源 &#123; TIM_ClearITPendingBit(TIM3, TIM_IT_Update ); //清除TIMx的中断待处理位:TIM 中断源 LED1=!LED1; &#125;&#125;//PWM输出初始化//arr：自动重装值//psc：时钟预分频数void TIM3_PWM_Init(u16 arr,u16 psc)&#123; GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE); //使能GPIO外设和AFIO复用功能模块时钟使能 GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); //Timer3部分重映射 TIM3_CH2-&gt;PB5 //用于TIM3的CH2输出的PWM通过该LED显示 //设置该引脚为复用输出功能,输出TIM3 CH2的PWM脉冲波形 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //TIM_CH2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //GPIO_WriteBit(GPIOA, GPIO_Pin_7,Bit_SET); // PA7上拉 TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值 80K TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值 不分频 TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM向上计数模式 TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //选择定时器模式:TIM脉冲宽度调制模式2 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能 TIM_OCInitStructure.TIM_Pulse = 0; //设置待装入捕获比较寄存器的脉冲值 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性:TIM输出比较极性高 TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure); //根据TIM_OCInitStruct中指定的参数初始化外设TIMx TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable); //使能TIMx在CCR2上的预装载寄存器 TIM_ARRPreloadConfig(TIM3, ENABLE); //使能TIMx在ARR上的预装载寄存器 TIM_Cmd(TIM3, ENABLE); //使能TIMx外设 &#125;//定时器5通道1输入捕获配置TIM_ICInitTypeDef TIM5_ICInitStructure;void TIM5_Cap_Init(u16 arr,u16 psc)&#123; GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); //使能TIM5时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //使能GPIOA时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; //PA0 清除之前设置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0 输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_ResetBits(GPIOA,GPIO_Pin_0); //PA0 下拉 //初始化定时器5 TIM5 TIM_TimeBaseStructure.TIM_Period = arr; //设定计数器自动重装值 TIM_TimeBaseStructure.TIM_Prescaler =psc; //预分频器 TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM向上计数模式 TIM_TimeBaseInit(TIM5, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位 //初始化TIM5输入捕获参数 TIM5_ICInitStructure.TIM_Channel = TIM_Channel_1; //CC1S=01 选择输入端 IC1映射到TI1上 TIM5_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; //上升沿捕获 TIM5_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //映射到TI1上 TIM5_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; //配置输入分频,不分频 TIM5_ICInitStructure.TIM_ICFilter = 0x00;//IC1F=0000 配置输入滤波器 不滤波 TIM_ICInit(TIM5, &amp;TIM5_ICInitStructure); //中断分组初始化 NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn; //TIM3中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; //先占优先级2级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; //从优先级0级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 TIM_ITConfig(TIM5,TIM_IT_Update|TIM_IT_CC1,ENABLE);//允许更新中断 ,允许CC1IE捕获中断 TIM_Cmd(TIM5,ENABLE ); //使能定时器5 &#125;u8 TIM5CH1_CAPTURE_STA=0; //输入捕获状态 u16 TIM5CH1_CAPTURE_VAL; //输入捕获值 //定时器5中断服务程序 void TIM5_IRQHandler(void)&#123; if((TIM5CH1_CAPTURE_STA&amp;0X80)==0)//还未成功捕获 &#123; if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET) &#123; if(TIM5CH1_CAPTURE_STA&amp;0X40)//已经捕获到高电平了 &#123; if((TIM5CH1_CAPTURE_STA&amp;0X3F)==0X3F)//高电平太长了 &#123; TIM5CH1_CAPTURE_STA|=0X80;//标记成功捕获了一次 TIM5CH1_CAPTURE_VAL=0XFFFF; &#125;else TIM5CH1_CAPTURE_STA++; &#125; &#125; if (TIM_GetITStatus(TIM5, TIM_IT_CC1) != RESET)//捕获1发生捕获事件 &#123; if(TIM5CH1_CAPTURE_STA&amp;0X40) //捕获到一个下降沿 &#123; TIM5CH1_CAPTURE_STA|=0X80; //标记成功捕获到一次上升沿 TIM5CH1_CAPTURE_VAL=TIM_GetCapture1(TIM5); TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Rising); //CC1P=0 设置为上升沿捕获 &#125;else //还未开始,第一次捕获上升沿 &#123; TIM5CH1_CAPTURE_STA=0; //清空 TIM5CH1_CAPTURE_VAL=0; TIM_SetCounter(TIM5,0); TIM5CH1_CAPTURE_STA|=0X40; //标记捕获到了上升沿 TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Falling); //CC1P=1 设置为下降沿捕获 &#125; &#125; &#125; TIM_ClearITPendingBit(TIM5, TIM_IT_CC1|TIM_IT_Update); //清除中断标志位 &#125;/******************* END OF FILE *********/ timer.h 1234567891011// timer.h#ifndef __TIMER_H#define __TIMER_H#include &quot;sys.h&quot;void TIM3_Int_Init(u16 arr,u16 psc);void TIM3_PWM_Init(u16 arr,u16 psc);void TIM5_Cap_Init(u16 arr,u16 psc);#endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031323334353637383940//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;timer.h&quot;extern u8 TIM5CH1_CAPTURE_STA; //输入捕获状态 extern u16 TIM5CH1_CAPTURE_VAL; //输入捕获值 int main(void) &#123; u32 temp=0; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 TIM3_PWM_Init(899,0); //不分频。PWM频率=72000/(899+1)=80Khz TIM5_Cap_Init(0XFFFF,72-1); //以1Mhz的频率计数 while(1) &#123; delay_ms(10); TIM_SetCompare2(TIM3,TIM_GetCapture2(TIM3)+1); if(TIM_GetCapture2(TIM3)==300)TIM_SetCompare2(TIM3,0); if(TIM5CH1_CAPTURE_STA&amp;0X80)//成功捕获到了一次上升沿 &#123; temp=TIM5CH1_CAPTURE_STA&amp;0X3F; temp*=65536;//溢出时间总和 temp+=TIM5CH1_CAPTURE_VAL;//得到总的高电平时间 printf(&quot;HIGH:%d us\\r\\n&quot;,temp);//打印总的高点平时间 TIM5CH1_CAPTURE_STA=0;//开启下一次捕获 &#125; &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 代码片段分析 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（9）PWM输出","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-009","date":"2022-11-08T01:59:18.000Z","updated":"2023-04-05T14:19:11.394Z","comments":true,"path":"posts/1529114485.html","link":"","permalink":"https://sirius-blog.github.io/posts/1529114485.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 beep output PB8 LED0驱动 思路 调用官方库文件驱动GPIO口。 驱动 timer.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// timer.c#include &quot;timer.h&quot;#include &quot;led.h&quot;#include &quot;usart.h&quot; //通用定时器3中断初始化//这里时钟选择为APB1的2倍，而APB1为36M//arr：自动重装值。//psc：时钟预分频数//这里使用的是定时器3!void TIM3_Int_Init(u16 arr,u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能 TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值 计数到5000为500ms TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值 10Khz的计数频率 TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM向上计数模式 TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位 TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE ); //使能指定的TIM3中断,允许更新中断 NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; //TIM3中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //先占优先级0级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //从优先级3级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 TIM_Cmd(TIM3, ENABLE); //使能TIMx外设 &#125;//定时器3中断服务程序void TIM3_IRQHandler(void) //TIM3中断&#123; if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否:TIM 中断源 &#123; TIM_ClearITPendingBit(TIM3, TIM_IT_Update ); //清除TIMx的中断待处理位:TIM 中断源 LED1=!LED1; &#125;&#125;//TIM3 PWM部分初始化 //PWM输出初始化//arr：自动重装值//psc：时钟预分频数void TIM3_PWM_Init(u16 arr,u16 psc)&#123; GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //使能定时器3时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE); //使能GPIO外设和AFIO复用功能模块时钟 GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); //Timer3部分重映射 TIM3_CH2-&gt;PB5 //设置该引脚为复用输出功能,输出TIM3 CH2的PWM脉冲波形 GPIOB.5 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //TIM_CH2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure);//初始化GPIO //初始化TIM3 TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值 TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值 TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM向上计数模式 TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位 //初始化TIM3 Channel2 PWM模式 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //选择定时器模式:TIM脉冲宽度调制模式2 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性:TIM输出比较极性高 TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure); //根据T指定的参数初始化外设TIM3 OC2 TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable); //使能TIM3在CCR2上的预装载寄存器 TIM_Cmd(TIM3, ENABLE); //使能TIM3 &#125;/******************* END OF FILE *********/ timer.h 12345678910// timer.h#ifndef __TIMER_H#define __TIMER_H#include &quot;sys.h&quot;void TIM3_Int_Init(u16 arr,u16 psc);void TIM3_PWM_Init(u16 arr,u16 psc);#endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;timer.h&quot; int main(void) &#123; u16 led0pwmval=0; u8 dir=1; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 TIM3_PWM_Init(899,0); //不分频。PWM频率=72000000/900=80Khz while(1) &#123; delay_ms(10); if(dir)led0pwmval++; else led0pwmval--; if(led0pwmval&gt;300)dir=0; if(led0pwmval==0)dir=1; TIM_SetCompare2(TIM3,led0pwmval); &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 代码片段分析 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（8）定时器中断","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-008","date":"2022-11-08T01:39:18.000Z","updated":"2023-04-05T14:19:00.567Z","comments":true,"path":"posts/3757997425.html","link":"","permalink":"https://sirius-blog.github.io/posts/3757997425.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 beep output PB8 LED0驱动 思路 调用官方库文件驱动GPIO口。 驱动 timer.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// timer.c#include &quot;timer.h&quot;#include &quot;led.h&quot;//通用定时器3中断初始化//这里时钟选择为APB1的2倍，而APB1为36M//arr：自动重装值。//psc：时钟预分频数//这里使用的是定时器3!void TIM3_Int_Init(u16 arr,u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能 //定时器TIM3初始化 TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值 TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值 TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM向上计数模式 TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //根据指定的参数初始化TIMx的时间基数单位 TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE ); //使能指定的TIM3中断,允许更新中断 //中断优先级NVIC设置 NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; //TIM3中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //先占优先级0级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //从优先级3级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能 NVIC_Init(&amp;NVIC_InitStructure); //初始化NVIC寄存器 TIM_Cmd(TIM3, ENABLE); //使能TIMx &#125;//定时器3中断服务程序void TIM3_IRQHandler(void) //TIM3中断&#123; if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //检查TIM3更新中断发生与否 &#123; TIM_ClearITPendingBit(TIM3, TIM_IT_Update ); //清除TIMx更新中断标志 LED1=!LED1; &#125;&#125;/******************* END OF FILE *********/ timer.h 12345678910// timer.h#ifndef __TIMER_H#define __TIMER_H#include &quot;sys.h&quot;void TIM3_Int_Init(u16 arr,u16 psc); #endif/******************* END OF FILE *********/ main.c 123456789101112131415161718192021222324252627//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;timer.h&quot; int main(void) &#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 TIM3_Int_Init(4999,7199);//10Khz的计数频率，计数到5000为500ms while(1) &#123; LED0=!LED0; delay_ms(200); &#125; &#125; /******************* END OF FILE *********/ 上板 运行结果： 略 代码片段分析 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（7）窗口看门狗","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-007","date":"2022-11-08T01:19:18.000Z","updated":"2023-04-05T14:18:51.344Z","comments":true,"path":"posts/2692450778.html","link":"","permalink":"https://sirius-blog.github.io/posts/2692450778.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 beep output PB8 LED0驱动 思路 调用官方库文件驱动GPIO口。 驱动 wwdg.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// wwdg.c#include &quot;wwdg.h&quot;#include &quot;led.h&quot;//保存WWDG计数器的设置值,默认为最大. u8 WWDG_CNT=0x7f; //初始化窗口看门狗 //tr :T[6:0],计数器值 //wr :W[6:0],窗口值 //fprer:分频系数（WDGTB）,仅最低2位有效 //Fwwdg=PCLK1/(4096*2^fprer). void WWDG_Init(u8 tr,u8 wr,u32 fprer)&#123; RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE); // WWDG时钟使能 WWDG_CNT=tr&amp;WWDG_CNT; //初始化WWDG_CNT. WWDG_SetPrescaler(fprer);////设置IWDG预分频值 WWDG_SetWindowValue(wr);//设置窗口值 WWDG_Enable(WWDG_CNT); //使能看门狗 , 设置 counter . WWDG_ClearFlag();//清除提前唤醒中断标志位 WWDG_NVIC_Init();//初始化窗口看门狗 NVIC WWDG_EnableIT(); //开启窗口看门狗中断&#125; //重设置WWDG计数器的值void WWDG_Set_Counter(u8 cnt)&#123; WWDG_Enable(cnt);//使能看门狗 , 设置 counter . &#125;//窗口看门狗中断服务程序void WWDG_NVIC_Init()&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = WWDG_IRQn; //WWDG中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; //抢占2，子优先级3，组2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //抢占2，子优先级3，组2 NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE; NVIC_Init(&amp;NVIC_InitStructure);//NVIC初始化&#125;void WWDG_IRQHandler(void) &#123; WWDG_SetCounter(WWDG_CNT); //当禁掉此句后,窗口看门狗将产生复位 WWDG_ClearFlag(); //清除提前唤醒中断标志位 LED1=!LED1; //LED状态翻转 &#125;/******************* END OF FILE *********/ wwdg.h 1234567891011// wwdg.h#ifndef __WDG_H#define __WDG_H#include &quot;sys.h&quot;void WWDG_Init(u8 tr,u8 wr,u32 fprer);//初始化WWDGvoid WWDG_Set_Counter(u8 cnt); //设置WWDG的计数器void WWDG_NVIC_Init(void);#endif/******************* END OF FILE *********/ main.c 1234567891011121314151617181920212223242526//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;wwdg.h&quot; int main(void) &#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置中断优先级分组为组2：2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); KEY_Init(); //按键初始化 LED0=0; delay_ms(300); WWDG_Init(0X7F,0X5F,WWDG_Prescaler_8);//计数器值为7f,窗口寄存器为5f,分频数为8 while(1) &#123; LED0=1; &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 代码片段分析 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（6）独立看门狗","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-006","date":"2022-11-08T00:49:18.000Z","updated":"2023-04-09T14:24:26.743Z","comments":true,"path":"posts/1102504782.html","link":"","permalink":"https://sirius-blog.github.io/posts/1102504782.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 使用按键 WK_UP 操作以及LED闪烁现象认识独立看门狗及其基本应用。 电路 硬件连接关系： STM32主要应用管脚分配： 信号 方向 管脚 说明 led0 output PB5 LED0驱动 WK_UP input PA4 WK_UP状态检测 思路 调用官方库文件使用独立看门狗资源，通过按键的操作以及LED闪烁结果判断喂狗是否完成。 根据电路连接关系以及已知逻辑关系可得如下预期结果： 按键 状态 现象 说明 WK_UP 长时间未检测到被按下 LED0不停闪烁 此时MCU重复进入main函数，即被不停地复位 WK_UP 极频繁检测到被按下 LED0常亮 此时程序在while中停留，即因为及时喂狗而不会被复位 驱动 iwdg.c 12345678910111213141516171819202122232425262728// iwdg.c#include &quot;iwdg.h&quot;//初始化独立看门狗//prer:分频数:0~7(只有低3位有效!)//分频因子=4*2^prer.但最大值只能是256!//rlr:重装载寄存器值:低11位有效.//时间计算(大概):Tout=((4*2^prer)*rlr)/40 (ms).void IWDG_Init(u8 prer,u16 rlr) &#123; IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable); //使能对寄存器IWDG_PR和IWDG_RLR的写操作 IWDG_SetPrescaler(prer); //设置IWDG预分频值:设置IWDG预分频值为64 IWDG_SetReload(rlr); //设置IWDG重装载值 IWDG_ReloadCounter(); //按照IWDG重装载寄存器的值重装载IWDG计数器 IWDG_Enable(); //使能IWDG&#125;//喂独立看门狗void IWDG_Feed(void)&#123; IWDG_ReloadCounter();//reload &#125;/******************* END OF FILE *********/ iwdg.h 1234567891011// iwdg.h#ifndef __IWDG_H#define __IWDG_H#include &quot;sys.h&quot;void IWDG_Init(u8 prer,u16 rlr);void IWDG_Feed(void);#endif/******************* END OF FILE *********/ main.c 1234567891011121314151617181920212223242526272829//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;iwdg.h&quot; int main(void) &#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //初始化与LED连接的硬件接口 KEY_Init(); //按键初始化 delay_ms(500); //让人看得到灭 IWDG_Init(4,625); //与分频数为64,重载值为625,溢出时间为1s LED0=0; //点亮LED0 while(1) &#123; if(KEY_Scan(0)==WKUP_PRES) &#123; IWDG_Feed();//如果WK_UP按下,则喂狗 &#125; delay_ms(10); &#125;; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈 章节目的 本章主要是熟悉独立看门狗IWDG资源。 程序段分析 对独立看门狗使用的一般步骤: 浅知外部中断资源 STM32 独立看门狗资源小知识。","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（5）外部中断","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-005","date":"2022-11-08T00:29:18.000Z","updated":"2023-04-09T14:08:52.187Z","comments":true,"path":"posts/730138348.html","link":"","permalink":"https://sirius-blog.github.io/posts/730138348.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现跑马灯样式实验。 电路 硬件连接关系： STM32主要应用管脚分配： 信号 方向 管脚 说明 KEY0 input PE3 KEY0状态检测 KEY1 input PE4 KEY1状态检测 WK_UP input PA4 WK_UP状态检测 思路 调用官方库文件，通过中断的功能检测端口状态并控制外部LED指示灯、蜂鸣器等电路器件。 根据电路连接关系可知如下预期结果： 按键 状态 现象 KEY0 检测到被按下 BEEP发声 KEY1 检测到被按下 LED1暗亮状态翻转 WK_UP 检测到被按下 LED0、LED1暗亮状态同时翻转 驱动 exti.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// exti.c#include &quot;exti.h&quot;#include &quot;led.h&quot;#include &quot;key.h&quot;#include &quot;delay.h&quot;#include &quot;usart.h&quot;#include &quot;beep.h&quot;//外部中断0服务程序void EXTIX_Init(void)&#123; EXTI_InitTypeDef EXTI_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; KEY_Init(); // 按键端口初始化 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //使能复用功能时钟 //GPIOE.3 中断线以及中断初始化配置 下降沿触发 //KEY1 GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource3); EXTI_InitStructure.EXTI_Line=EXTI_Line3; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 //GPIOE.4 中断线以及中断初始化配置 下降沿触发 //KEY0 GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource4); EXTI_InitStructure.EXTI_Line=EXTI_Line4; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 //GPIOA.0 中断线以及中断初始化配置 上升沿触发 PA0 //WK_UP GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0); EXTI_InitStructure.EXTI_Line=EXTI_Line0; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; //使能按键WK_UP所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2， NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn; //使能按键KEY1所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01; //子优先级1 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn; //使能按键KEY0所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00; //子优先级0 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 &#125;//外部中断0服务程序 void EXTI0_IRQHandler(void)&#123; delay_ms(10);//消抖 if(WK_UP==1) //WK_UP按键 &#123; BEEP=!BEEP; &#125; EXTI_ClearITPendingBit(EXTI_Line0); //清除LINE0上的中断标志位 &#125; //外部中断3服务程序void EXTI3_IRQHandler(void)&#123; delay_ms(10);//消抖 if(KEY1==0) //按键KEY1 &#123; LED1=!LED1; &#125; EXTI_ClearITPendingBit(EXTI_Line3); //清除LINE3上的中断标志位 &#125;void EXTI4_IRQHandler(void)&#123; delay_ms(10);//消抖 if(KEY0==0) //按键KEY0 &#123; LED0=!LED0; LED1=!LED1; &#125; EXTI_ClearITPendingBit(EXTI_Line4); //清除LINE4上的中断标志位 &#125;/******************* END OF FILE *********/ exti.h 123456789// exti.h#ifndef __EXTI_H#define __EXIT_H #include &quot;sys.h&quot;void EXTIX_Init(void);//外部中断初始化 #endif/******************* END OF FILE *********/ main.c 123456789101112131415161718192021222324252627//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;exti.h&quot;#include &quot;beep.h&quot; int main(void) &#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //初始化与LED连接的硬件接口 BEEP_Init(); //初始化蜂鸣器IO EXTIX_Init(); //初始化外部中断输入 LED0=0; //先点亮红灯 while(1) &#123; printf(&quot;OK\\r\\n&quot;); delay_ms(1000); &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈 章节目的 本章主要是熟悉基础 GPIO 端口外部中断资源。 程序段分析 对IO口外部中断使用的一般步骤: 初始化 IO 口为输入。 开启 AFIO 时钟 设置 IO 口与中断线的映射关系。 初始化线上中断，设置触发条件等。 配置中断分组（NVIC），并使能中断。 编写中断服务函数。 主函数中对中断资源进行初始化调用，驱动指示灯、蜂鸣器等等。 浅知外部中断资源 STM32 外部中断小知识。","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（4）串口通信","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-004","date":"2022-11-07T23:59:18.000Z","updated":"2023-04-09T14:08:40.041Z","comments":true,"path":"posts/1103739706.html","link":"","permalink":"https://sirius-blog.github.io/posts/1103739706.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 应用内部串口资源，实现串口通信功能。 电路 硬件连接关系： STM32主要应用管脚分配： 信号 方向 管脚 说明 USART1_TX output PA9 MCU端串口USART1信号输出 USART1_RX input PA10 MCU端串口USART1信号输入 思路 调用官方库文件驱动USART1内部资源，通过USB转串口电路进行与PC端通信。此处使用RS232协议。 驱动 usart.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138// usart.c#include &quot;sys.h&quot;#include &quot;usart.h&quot; //如果使用ucos,则包括下面的头文件即可#if SYSTEM_SUPPORT_OS#include &quot;includes.h&quot; //ucos 使用 #endif/加入以下代码,支持printf函数,而不需要选择use MicroLIB #if 1#pragma import(__use_no_semihosting) //标准库需要的支持函数 struct __FILE &#123; int handle; &#125;; FILE __stdout; //定义_sys_exit()以避免使用半主机模式 void _sys_exit(int x) &#123; x = x; &#125; //重定义fputc函数 int fputc(int ch, FILE *f)&#123; while((USART1-&gt;SR&amp;0X40)==0);//循环发送,直到发送完毕 USART1-&gt;DR = (u8) ch; return ch;&#125;#endif /*使用microLib的方法*/ /* int fputc(int ch, FILE *f)&#123; USART_SendData(USART1, (uint8_t) ch); while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET) &#123;&#125; return ch;&#125;int GetKey (void) &#123; while (!(USART1-&gt;SR &amp; USART_FLAG_RXNE)); return ((int)(USART1-&gt;DR &amp; 0x1FF));&#125;*/ #if EN_USART1_RX //如果使能了接收//串口1中断服务程序//注意,读取USARTx-&gt;SR能避免莫名其妙的错误 u8 USART_RX_BUF[USART_REC_LEN]; //接收缓冲,最大USART_REC_LEN个字节.//接收状态//bit15， 接收完成标志//bit14， 接收到0x0d//bit13~0， 接收到的有效字节数目u16 USART_RX_STA=0; //接收状态标记 void uart_init(u32 bound)&#123; //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE); //使能USART1，GPIOA时钟 //USART1_TX GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.9 //USART1_RX GPIOA.10初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.10 //Usart1 NVIC 配置 NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器 //USART 初始化设置 USART_InitStructure.USART_BaudRate = bound;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口1 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_Cmd(USART1, ENABLE); //使能串口1 &#125;void USART1_IRQHandler(void) //串口1中断服务程序 &#123; u8 Res;#if SYSTEM_SUPPORT_OS //如果SYSTEM_SUPPORT_OS为真，则需要支持OS. OSIntEnter(); #endif if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) &#123; Res =USART_ReceiveData(USART1); //读取接收到的数据 if((USART_RX_STA&amp;0x8000)==0)//接收未完成 &#123; if(USART_RX_STA&amp;0x4000)//接收到了0x0d &#123; if(Res!=0x0a)USART_RX_STA=0;//接收错误,重新开始 else USART_RX_STA|=0x8000; //接收完成了 &#125; else //还没收到0X0D &#123; if(Res==0x0d)USART_RX_STA|=0x4000; else &#123; USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=Res ; USART_RX_STA++; if(USART_RX_STA&gt;(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收 &#125; &#125; &#125; &#125; #if SYSTEM_SUPPORT_OS //如果SYSTEM_SUPPORT_OS为真，则需要支持OS. OSIntExit(); #endif&#125; #endif /******************* END OF FILE *********/ usart.h 12345678910111213141516// usart.h#ifndef __USART_H#define __USART_H#include &quot;stdio.h&quot; #include &quot;sys.h&quot; #define USART_REC_LEN 200 //定义最大接收字节数 200#define EN_USART1_RX 1 //使能（1）/禁止（0）串口1接收 extern u8 USART_RX_BUF[USART_REC_LEN]; //接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 extern u16 USART_RX_STA; //接收状态标记 //如果想串口中断接收，请不要注释以下宏定义void uart_init(u32 bound);#endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot; int main(void) &#123; u16 t; u16 len; u16 times=0; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 uart_init(115200); //串口初始化为115200 LED_Init(); //LED端口初始化 KEY_Init(); //初始化与按键连接的硬件接口 while(1) &#123; if(USART_RX_STA&amp;0x8000) &#123; len=USART_RX_STA&amp;0x3fff;//得到此次接收到的数据长度 printf(&quot;\\r\\n您发送的消息为:\\r\\n\\r\\n&quot;); for(t=0;t&lt;len;t++) &#123; USART_SendData(USART1, USART_RX_BUF[t]);//向串口1发送数据 while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);//等待发送结束 &#125; printf(&quot;\\r\\n\\r\\n&quot;);//插入换行 USART_RX_STA=0; &#125;else &#123; times++; if(times%5000==0) &#123; printf(&quot;\\r\\n精英STM32开发板 串口实验\\r\\n&quot;); printf(&quot;正点原子@ALIENTEK\\r\\n\\r\\n&quot;); &#125; if(times%200==0)printf(&quot;请输入数据,以回车键结束\\n&quot;); if(times%30==0)LED0=!LED0;//闪烁LED,提示系统正在运行. delay_ms(10); &#125; &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈 章节目的 本章主要是熟悉 GPIO 复用端口资源USART1的通信。 程序段分析 对端口的驱动，这里主要进行如下设置（见 usart.c ）: 启动相应端口时钟 Clock 以及复用资源USART1 时钟 Clock; 串口 USART1 复位; 初始化端配置，包括“具体引脚 PIN_x ”、“端口模式 Mode ”、“速度配置 Speed ”; 将上述配置使用官方库函数进行对对应端口引脚初始化(函数 GPIO_Init() ); 初始化 USART1 资源参数配置，包括“波特率 BaudRate”、“字节长度 WordLength ”、“停止位 StopBits ”、“奇偶校验位 Parity ”、“硬件数据流控制 HFC ”、“收发模式 Mode ”; 将上述配置使用官方库函数进行对对应资源初始化(函数 USART_Init() ); 初始化优先级 NVIC 参数配置，包括“中断请求通道 IRQChannel”、“抢占优先级 ”、“子优先级”、“中断请求通道使能 ”; 将上述配置使用官方库函数进行对对应 NVIC 初始化(函数 NVIC_Init() ); 开启中断; 使能串口 USART1; 主函数中对自定义函数进行调用并执行，驱动指示灯、蜂鸣器等等。","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（3）按键输入","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-003","date":"2022-11-07T23:39:18.000Z","updated":"2023-04-09T14:08:23.852Z","comments":true,"path":"posts/1977272759.html","link":"","permalink":"https://sirius-blog.github.io/posts/1977272759.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现外部端口状态（按键状态）检测。 电路 硬件连接关系： STM32主要应用管脚分配： 信号 方向 管脚 说明 KEY0 input PE3 KEY0状态检测 KEY1 input PE4 KEY1状态检测 WK_UP input PA4 WK_UP状态检测 思路 调用官方库文件检测GPIO口的状态，并控制外部LED指示灯、蜂鸣器等电路器件。 根据电路连接关系可知如下预期结果： 端口 电平状态 现象 说明 PE3 检测到低电平 KEY0被按下 此时该端口外部被接GND PE4 检测到低电平 KEY1被按下 同上 PA4 检测到高电平 WK_UP被按下 此时该端口外部被接VCC3.3 PE3 检测到高电平 KEY0被放开 此时该端口外部悬空 PE4 检测到高电平 KEY1被放开 同上 PA4 检测到低电平 WK_UP被放开 同上 通过以上预期状态，可以设计控制外部LED指示灯、蜂鸣器等电路器件的逻辑，如“一控一”、“一控多”、“多控一”、“长按短按控制”等等。此处试验设计逻辑关系预期如下： 按键 状态 现象 KEY0 检测到被按下 BEEP发声 KEY1 检测到被按下 LED1暗亮状态翻转 WK_UP 检测到被按下 LED0、LED1暗亮状态同时翻转 驱动 key.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// key.c#include &quot;stm32f10x.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot; #include &quot;delay.h&quot;//按键初始化函数void KEY_Init(void) //IO初始化&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOE,ENABLE); //使能PORTA,PORTE时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4|GPIO_Pin_3; //KEY0-KEY1 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //设置成上拉输入（因为外部置低为有效操作，此处应上拉） GPIO_Init(GPIOE, &amp;GPIO_InitStructure); //初始化GPIOE4,3 //初始化 WK_UP--&gt;GPIOA.0 下拉输入（因为外部置高为有效操作，此处应下拉） GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0设置成输入，默认下拉 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.0&#125;//按键处理函数//返回按键值//mode:0,不支持连续按;1,支持连续按;//0，没有任何按键按下//1，KEY0按下//2，KEY1按下//3，KEY3按下 WK_UP//注意此函数有响应优先级,KEY0&gt;KEY1&gt;KEY_UP!!u8 KEY_Scan(u8 mode)&#123; static u8 key_up=1;//按键按松开标志 if(mode)key_up=1; //支持连按 if(key_up&amp;&amp;(KEY0==0||KEY1==0||WK_UP==1)) &#123; delay_ms(10);//去抖动 key_up=0; if(KEY0==0)return KEY0_PRES; else if(KEY1==0)return KEY1_PRES; else if(WK_UP==1)return WKUP_PRES; &#125;else if(KEY0==1&amp;&amp;KEY1==1&amp;&amp;WK_UP==0)key_up=1; return 0;// 无按键按下&#125;/******************* END OF FILE *********/ key.h 1234567891011121314151617181920// key.h#ifndef __KEY_H#define __KEY_H #include &quot;sys.h&quot;#define KEY0 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4)//读取按键0(KEY0) #define KEY1 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_3)//读取按键1(KEY1) #define WK_UP GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)//读取按键3(WK_UP) #define KEY0_PRES 1 //KEY0按下#define KEY1_PRES 2 //KEY1按下#define WKUP_PRES 3 //KEY_UP按下(即WK_UP/KEY_UP)void KEY_Init(void);//IO初始化u8 KEY_Scan(u8); //按键扫描函数 #endif/******************* END OF FILE *********/ main.c 1234567891011121314151617181920212223242526272829303132333435363738//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;beep.h&quot; int main(void) &#123; vu8 key=0; delay_init(); //延时函数初始化 LED_Init(); //初始化与LED连接的硬件接口 BEEP_Init(); //初始化蜂鸣器端口 KEY_Init(); //初始化与按键连接的硬件接口 LED0=0; //先点亮红灯 while(1) &#123; key=KEY_Scan(0); //得到键值 if(key) &#123; switch(key) &#123; case WKUP_PRES: //控制蜂鸣器 BEEP=!BEEP; break; case KEY1_PRES: //控制LED1翻转 LED1=!LED1; break; case KEY0_PRES: //同时控制LED0,LED1翻转 LED0=!LED0; LED1=!LED1; break; &#125; &#125;else delay_ms(10); &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈 章节目的 本章主要是熟悉基础 GPIO 端口状态的检测，即端口的输入。 程序段分析 对端口的驱动，这里主要进行如下设置（见 key.c ）: 启动相应端口时钟 Clock; 初始化端配置，包括“具体引脚 PIN_x ”、“端口模式 Mode ”、“速度配置 Speed ”; 将上述配置使用官方库函数进行对对应端口引脚进行初始化(函数 GPIO_Init() ); 因为是输入检测，不需要配置初始状态值，自定义可执行函数是实现按键检测结果与外部电路驱动的捆绑关系; 主函数中对自定义函数进行调用并执行，驱动指示灯、蜂鸣器等等。","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 库函数例程（2）蜂鸣器","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-002","date":"2022-11-07T23:29:18.000Z","updated":"2023-05-14T15:43:25.936Z","comments":true,"path":"posts/3238499939.html","link":"","permalink":"https://sirius-blog.github.io/posts/3238499939.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作，实现有源蜂鸣器鸣叫。 电路 硬件连接关系： STM32主要应用管脚分配： 信号 方向 管脚 说明 beep output PB8 BEEP 驱动 思路 调用官方库文件驱动GPIO口，此处端口通过间接方式实现控制，即通过小电流改变某一器件的工作状态，继而实现受控器件对目标的控制。 此处的受控器件为NPN型三极管（S8050），根据电路连接关系可知如下预期结果： 端口 电平状态 现象 说明 PB8 输出高电平 BEEP发声 三极管满足饱和条件，电路导通 PB8 输出低电平 BEEP静默 三极管满足截止条件，电路不通 驱动 beep.c 12345678910111213141516171819202122// beep.c#include &quot;beep.h&quot;//初始化PB8为输出口.并使能这个IO口的时钟 //蜂鸣器初始化void BEEP_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //使能GPIOB端口时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; //BEEP--&gt;PB.8 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //速度为50MHz GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //根据参数初始化GPIOB.8 GPIO_ResetBits(GPIOB,GPIO_Pin_8); //输出置低，即关闭蜂鸣器&#125;/******************* END OF FILE *********/ beep.h 12345678910111213// beep.h#ifndef __BEEP_H#define __BEEP_H #include &quot;sys.h&quot;//蜂鸣器端口定义#define BEEP PBout(8) // BEEP,蜂鸣器接口 void BEEP_Init(void); //初始化 #endif/******************* END OF FILE *********/ main.c 1234567891011121314151617181920//main.c#include &quot;sys.h&quot; #include &quot;delay.h&quot; #include &quot;beep.h&quot; int main(void) &#123; delay_init(); //延时函数初始化 BEEP_Init(); //初始化蜂鸣器端口 while(1) &#123; BEEP=0; delay_ms(300);//延时300ms BEEP=1; delay_ms(300);//延时300ms &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈 章节目的 本章主要是熟悉基础 GPIO 端口的驱动，依旧是端口输出。 程序段分析 对端口的驱动，这里也是一般IO的输出，相对于上一章节 ，在逻辑控制上基本无差异。 关于三极管的小知识 详情可见S8050三极管器件 知识点所述。","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"EP4CE10 Verilog例程（11）接口UART RS485驱动","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-011","date":"2022-11-07T22:59:18.000Z","updated":"2023-04-05T04:12:35.860Z","comments":true,"path":"posts/3798164979.html","link":"","permalink":"https://sirius-blog.github.io/posts/3798164979.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。 器件 主芯片：Altera EP4CE10F17C8 。 目标器件：SP3485 （电平类型转换芯片，TTL电平与RS485电平的转换） 目的 主要实现串口通信RS485电平的传输效果。 电路 {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input PIN_E1 此处时钟50MHz sys_rst_n input PIN_M1 此处复位低有效 uart_rxd input PIN_A12 串口收 uart_txd output PIN_B12 串口发 tx_rde output PIN_A11 串口发使能端，高电平发送，低电平接收 思路 {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 12345678910111213141516171819202122232425262728293031323334353637383940414243//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd , output txd_rde ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (txd_rde), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule 管脚约束： 1234567#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1uart_txd, PIN_M7uart_rxd, PIN_N5 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1ns / 1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // 驱动时钟 50MHz ，20ns parameter UART_BPS = 115200; // 波特率 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // 单bit传输耗时 BPS_CNT 个驱动时钟周期 initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule 运行结果： 收发数据（数据为’h5A） 上板 运行结果： 略","categories":[{"name":"Altera-FPGA 例程","slug":"Altera-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 型","slug":"Altera-FPGA-例程/EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilog例程（10）接口UART RS232驱动","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-010","date":"2022-11-07T22:39:18.000Z","updated":"2023-04-05T04:12:34.266Z","comments":true,"path":"posts/4004091958.html","link":"","permalink":"https://sirius-blog.github.io/posts/4004091958.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。 器件 主芯片：Altera EP4CE10F17C8 。 目标器件：CH340 （串口转USB,电平类型转换芯片，TTL电平与USB差分电平的转换） 目标器件：SP3232 （电平类型转换芯片，TTL电平与RS232电平的转换） 目的 主要实现串口通信协议的传输效果。 电路 {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input PIN_E1 此处时钟50MHz sys_rst_n input PIN_M1 此处复位低有效 uart_rxd input PIN_N5 串口收 uart_txd output PIN_M7 串口发 思路 {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule 管脚约束： 1234567#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1uart_txd, PIN_M7uart_rxd, PIN_N5 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1ns / 1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // 驱动时钟 50MHz ，20ns parameter UART_BPS = 115200; // 波特率 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // 单bit传输耗时 BPS_CNT 个驱动时钟周期 initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule 运行结果： 收发数据（数据为’h5A） 细节（BPS_CNT = CLK_FREQ/UART_BPS = 50000000/115200 = 434） 上板 运行结果： 略","categories":[{"name":"Altera-FPGA 例程","slug":"Altera-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 型","slug":"Altera-FPGA-例程/EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilog例程（9）Altera  FIFO核应用","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-009","date":"2022-11-07T22:19:18.000Z","updated":"2023-04-05T04:12:32.655Z","comments":true,"path":"posts/1307021646.html","link":"","permalink":"https://sirius-blog.github.io/posts/1307021646.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。 器件 主芯片：Altera EP4CE10F17C8 。 目的 主要通过FIFO核熟悉FIFO的读写及IP核使用。 电路 略 FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input E1 此处时钟50MHz sys_rst_n input M1 此处复位低有效 思路 配置位宽 {width=“400px”} IP配置 {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//demo.vmodule demo( input sys_clk , input sys_rst_n );wire wrreq ; wire [7:0] data ; wire wrempty ; wire wrfull ; wire [7:0] wrusedw ; wire rdreq ; wire [7:0] q ; wire rdempty ; wire rdfull ; wire [7:0] rdusedw ; fifo u_fifo( .wrclk ( sys_clk ), .wrreq ( wrreq ), .data ( data ), .wrempty ( wrempty ), .wrfull ( wrfull ), .wrusedw ( wrusedw ), .rdclk ( sys_clk ), .rdreq ( rdreq ), .q ( q ), .rdempty ( rdempty ), .rdfull ( rdfull ), .rdusedw ( rdusedw ) );fifo_write u_fifo_wr( .clk (sys_clk ), .rst_n (sys_rst_n), .wrreq (wrreq ), .data (data ), .wrempty (wrempty ), .wrfull (wrfull ) );fifo_read u_fifo_rd( .clk (sys_clk ), .rst_n (sys_rst_n), .rdreq (rdreq ), .data (q ), .rdempty (rdempty ), .rdfull (rdfull ) );endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//fifo_write.vmodule fifo_write( input clk , input rst_n , input wrempty, input wrfull , output reg [7:0] data , output reg wrreq );reg [1:0] state; always @(posedge clk or negedge rst_n) begin if(!rst_n) begin wrreq &lt;= 1&#x27;b0; data &lt;= 8&#x27;d0; state &lt;= 2&#x27;d0; end else begin case(state) 2&#x27;d0: begin if(wrempty) begin wrreq &lt;= 1&#x27;b1; state &lt;= 2&#x27;d1; end else state &lt;= state; end 2&#x27;d1: begin if(wrfull) begin wrreq &lt;= 1&#x27;b0; data &lt;= 8&#x27;d0; state &lt;= 2&#x27;d0; end else begin wrreq &lt;= 1&#x27;b1; data &lt;= data + 1&#x27;d1; end end default: state &lt;= 2&#x27;d0; endcase endendendmodule 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//fifo_read.vmodule fifo_read( input clk , input rst_n , input [7:0] data , input rdfull , input rdempty, output reg rdreq );reg [7:0] data_fifo; reg [1:0] state ; always @(posedge clk or negedge rst_n) begin if(!rst_n) begin rdreq &lt;= 1&#x27;b0; data_fifo &lt;= 8&#x27;d0; end else begin case(state) 2&#x27;d0: begin if(rdfull) begin rdreq &lt;= 1&#x27;b1; state &lt;= 2&#x27;d1; end else state &lt;= state; end 2&#x27;d1: begin if(rdempty) begin rdreq &lt;= 1&#x27;b0; data_fifo &lt;= 8&#x27;d0; state &lt;= 2&#x27;d0; end else begin rdreq &lt;= 1&#x27;b1; data_fifo &lt;= data; end end default: state &lt;= 2&#x27;d0; endcase endendendmodule 管脚约束： 12345#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1 验证 功能仿真TestBench： 1234567891011121314151617181920212223//tb_demo.v`timescale 1ns / 1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; always #10 sys_clk = ~sys_clk; initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; end demo inst_fifo_rw ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk)); endmodule 运行结果： “启动-复位释放-写状态机IDEL-写状态机WRITE”过程,可以看到由空到非空状态 data、wrempty、wrfull、q、rdempty、rdfull与rdusedw、wrusedw的关系 “写状态机WRITE”阶段的FIFO核的状态变化，可以看到由非满到满状态 data、wrfull、rdfull、q与rdusedw、wrusedw的关系 “写状态机-读状态机”过程的FIFO核的状态变化，可以看到由满到非满状态 data、wrfull、rdfull、q与rdusedw、wrusedw的关系 “读状态机READ”阶段的FIFO核的状态变化，可以看到由非空到空状态 din、almost_empty、empty与rd_count、wr_count的关系 上板 运行结果： 略","categories":[{"name":"Altera-FPGA 例程","slug":"Altera-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 型","slug":"Altera-FPGA-例程/EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilog例程（8）Altera  RAM核应用","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-008","date":"2022-11-07T21:49:18.000Z","updated":"2023-04-05T04:12:30.113Z","comments":true,"path":"posts/1379072265.html","link":"","permalink":"https://sirius-blog.github.io/posts/1379072265.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。 器件 主芯片：Altera EP4CE10F17C8 。 目的 主要通过RAM核熟悉RAM的读写及IP核使用。 电路 硬件连接关系： 略 FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input E1 此处时钟50MHz sys_rst_n input M1 此处复位低有效 思路 使用IP核构建位宽为8，深度为32的单端口RAM，并进行读写测试。 IP配置 {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 1234567891011121314151617181920212223242526272829303132//demo.vmodule demo( input sys_clk, input sys_rst_n); wire ram_en; wire ram_wea; wire [4:0] ram_addr ; wire [7:0] ram_wr_data ; wire [7:0] ram_rd_data ;ram_rw inst_rw_ram ( .clk(sys_clk), .rst_n(sys_rst_n), .ram_en(ram_en), .ram_wea(ram_wea), .ram_addr(ram_addr), .ram_wr_data(ram_wr_data), .ram_rd_data(ram_rd_data) );ram_1port inst_IP_ram ( .address ( ram_addr ), .clock ( sys_clk ), .data ( ram_wr_data ), .rden ( ram_en ), .wren ( ram_wea ), .q ( ram_rd_data ) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445//ram_rw.vmodule ram_rw( input clk , input rst_n , output ram_en , output ram_wea , output reg [4:0] ram_addr , output reg [7:0] ram_wr_data, input [7:0] ram_rd_data);reg [5:0] rw_cnt ;assign ram_en = rst_n;assign ram_wea = (rw_cnt &lt;= 6&#x27;d31 &amp;&amp; ram_en == 1&#x27;b1) ? 1&#x27;b1 : 1&#x27;b0;always @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) rw_cnt &lt;= 1&#x27;b0; else if(rw_cnt == 6&#x27;d63) rw_cnt &lt;= 1&#x27;b0; else rw_cnt &lt;= rw_cnt + 1&#x27;b1;endalways @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) ram_wr_data &lt;= 1&#x27;b0; else if(rw_cnt &lt;= 6&#x27;d31) ram_wr_data &lt;= ram_wr_data + 1&#x27;b1; else ram_wr_data &lt;= 1&#x27;b0 ;endalways @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) ram_addr &lt;= 1&#x27;b0; else if(ram_addr == 5&#x27;d31) ram_addr &lt;= 1&#x27;b0; else ram_addr &lt;= ram_addr + 1&#x27;b1;endendmodule 管脚约束： 12345#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1 验证 功能仿真TestBench： 1234567891011121314151617181920212223//tb_demo.v`timescale 1ns / 1psmodule tb_demo(); reg sys_clk; reg sys_rst_n; always #10 sys_clk = ~sys_clk; initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; end demo inst_ram_rw ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk)); endmodule 运行结果： 写RAM过程 读RAM过程 [测试]只启用RAM写使能 [测试]只启用RAM读使能 上板 运行结果： 略","categories":[{"name":"Altera-FPGA 例程","slug":"Altera-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 型","slug":"Altera-FPGA-例程/EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilog例程（6）动态数码管显示","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-006","date":"2022-11-07T20:59:18.000Z","updated":"2023-04-05T04:11:43.006Z","comments":true,"path":"posts/1907837786.html","link":"","permalink":"https://sirius-blog.github.io/posts/1907837786.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。","categories":[{"name":"Altera-FPGA 例程","slug":"Altera-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 型","slug":"Altera-FPGA-例程/EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilog例程（5）静态数码管显示","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-005","date":"2022-11-07T20:49:18.000Z","updated":"2023-04-08T10:00:59.150Z","comments":true,"path":"posts/2432118836.html","link":"","permalink":"https://sirius-blog.github.io/posts/2432118836.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。 器件 主芯片：Altera EP4CE10F17C8 。 控制对象：8段数码管。 目的 主要实现8段数码管显示的效果。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input E1 此处时钟50MHz sys_rst_n input M1 此处复位低有效 seg_led[0] output M11 数码管段选a seg_led[1] output N12 数码管段选b seg_led[2] output C9 数码管段选c seg_led[3] output N13 数码管段选d seg_led[4] output M10 数码管段选e seg_led[5] output N11 数码管段选f seg_led[6] output P11 数码管段选g seg_led[7] output D9 数码管段选h seg_sel[0] output N16 数码管位选0 seg_sel[1] output N15 数码管位选1 seg_sel[2] output P16 数码管位选2 seg_sel[3] output P15 数码管位选3 seg_sel[4] output R16 数码管位选4 seg_sel[5] output T15 数码管位选5 思路 驱动 采用模块化设计： 1234567891011121314151617181920212223242526272829303132//demo.vmodule demo( input sys_clk, input sys_rst_n, output [5:0] seg_sel, output [7:0] seg_led);parameter TIME_SHOW = 25&#x27;d25000000; //驻留时间wire increase_flag;seg_display_static inst_seg_display_static( .clk (sys_clk), .rstn (sys_rst_n), .seg_sel(seg_sel), .seg_led(seg_led), .increase_flag(increase_flag));time_count #(.MAX_NUM(TIME_SHOW ))inst_time_count( .clk (sys_clk), .rstn (sys_rst_n), .flag(increase_flag));endmodule 数码管静态驱动及显示样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//seg_display_static.vmodule seg_display_static( input clk, input rstn, input increase_flag, output reg [5:0] seg_sel, output reg [7:0] seg_led);reg [3:0] num;//位选驱动，硬件连接中低电平驱动PNP三极管导通always @ (posedge clk or negedge rstn) begin if (!rstn) seg_sel &lt;= 6&#x27;b111111; else seg_sel &lt;= 6&#x27;b000000;endalways @ (posedge clk or negedge rstn) begin if (!rstn) num &lt;= 4&#x27;h0; else if(increase_flag) begin if(num &lt; 4&#x27;hf) num &lt;= num + 1&#x27;b1; else num &lt;= 4&#x27;h0; end else num &lt;= num;endalways @ (posedge clk or negedge rstn) begin if (!rstn) //全点亮 seg_led &lt;= 8&#x27;b0000_0000; else begin case(num) //共阳极型驱动，低电平点亮 4&#x27;h0 : seg_led &lt;= 8&#x27;b1100_0000;//&#x27;hC0 4&#x27;h1 : seg_led &lt;= 8&#x27;b1111_1001;//&#x27;hF9 4&#x27;h2 : seg_led &lt;= 8&#x27;b1010_0100;//&#x27;hA4 4&#x27;h3 : seg_led &lt;= 8&#x27;b1011_0000;//&#x27;hB0 4&#x27;h4 : seg_led &lt;= 8&#x27;b1001_1001;//&#x27;h99 4&#x27;h5 : seg_led &lt;= 8&#x27;b1001_0010;//&#x27;h92 4&#x27;h6 : seg_led &lt;= 8&#x27;b1000_0010;//&#x27;h82 4&#x27;h7 : seg_led &lt;= 8&#x27;b1111_1000;//&#x27;hF8 4&#x27;h8 : seg_led &lt;= 8&#x27;b1000_0000;//&#x27;h80 4&#x27;h9 : seg_led &lt;= 8&#x27;b1001_0000;//&#x27;h90 4&#x27;ha : seg_led &lt;= 8&#x27;b1000_1000;//&#x27;h88 4&#x27;hb : seg_led &lt;= 8&#x27;b1000_0011;//&#x27;h83 4&#x27;hc : seg_led &lt;= 8&#x27;b1100_0110;//&#x27;hC6 4&#x27;hd : seg_led &lt;= 8&#x27;b1010_0001;//&#x27;hA1 4&#x27;he : seg_led &lt;= 8&#x27;b1000_0110;//&#x27;h86 4&#x27;hf : seg_led &lt;= 8&#x27;b1000_1110;//&#x27;h8E default : seg_led &lt;= 8&#x27;b1100_0000;//&#x27;hC0 endcase endendendmodule 单个样式显示驻留时长 1234567891011121314151617181920212223242526272829//time_count.vmodule time_count( input clk, input rstn, output reg flag);parameter MAX_NUM = 25000000;reg [24:0] cnt;always@(posedge clk or negedge rstn)begin if (!rstn) begin flag &lt;= 1&#x27;b0; cnt &lt;= 24&#x27;d0; end else if(cnt &lt; MAX_NUM - 1&#x27;b1) begin flag &lt;= 1&#x27;b0; cnt &lt;= cnt + 1&#x27;b1; end else begin flag &lt;= 1&#x27;b1; cnt &lt;= 24&#x27;d0; endendendmodule 管脚约束： 123456789101112131415161718192021# demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1seg_sel[0], PIN_N16seg_sel[1], PIN_N15seg_sel[2], PIN_P16seg_sel[3], PIN_P15seg_sel[4], PIN_R16seg_sel[5], PIN_T15seg_led[0], PIN_M11seg_led[1], PIN_N12seg_led[2], PIN_C9seg_led[3], PIN_N13seg_led[4], PIN_M10seg_led[5], PIN_N11seg_led[6], PIN_P11seg_led[7], PIN_D9 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire [7:0] seg_led; wire [5:0] seg_sel;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #20 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo #( .TIME_SHOW (25&#x27;d250) //驻留时间)inst_seg_display_static( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .seg_led (seg_led), .seg_sel(seg_sel));endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"Altera-FPGA 例程","slug":"Altera-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 型","slug":"Altera-FPGA-例程/EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilog例程（7）Altera PLL核应用","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-007","date":"2022-11-07T20:49:18.000Z","updated":"2023-04-05T04:12:28.309Z","comments":true,"path":"posts/3825430347.html","link":"","permalink":"https://sirius-blog.github.io/posts/3825430347.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。 器件 主芯片：Altera EP4CE10F17C8 。 目的 主要通过PLL这一时钟IP核实现对官方IP应用的认知。 电路 硬件连接关系： {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input E1 此处时钟50MHz sys_rst_n input M1 此处复位低有效 clk_100M output D1 100MHz时钟 clk_100M_pd output F3 100MHz时钟,反相 clk_50M output F1 50MHz时钟 clk_25M output F2 25MHz时钟 思路 通过参数配置PLL核，实现分频和倍频以及相位偏移。 IP配置 参数：单端输入50MHz,从4输出端口分别输出100MHz倍频钟、反相100MHz、50MHz、25MHz分频。 IP集路径 {width=“400px”} 搜索并选用IP核 {width=“400px”} 命名及选用类型 {width=“400px”} 设置输入时钟及模式 {width=“400px”} 启用复位端口及锁定状态标志 {width=“400px”} 无关参量，默认 {width=“400px”} 是否增加输入时钟，默认单端输入 {width=“400px”} 无关参量，默认 {width=“400px”} 第一路输出时钟参数设置 {width=“400px”} 第二路输出时钟参数设置 {width=“400px”} 第三路输出时钟参数设置 {width=“400px”} 第四路输出时钟参数设置 {width=“400px”} 第五路输出时钟参数设置，不需要就不启用 {width=“400px”} 添加mif仿真库,默认 {width=“400px”} 产生的文件，根据需要选择 {width=“400px”} 将设置的IP核生成后加入到当前工程中 {width=“400px”} IP加入到工程中，查看路径 {width=“400px”} 已添加IP核特性概况以及重配置路径（双击进入参数配置界面） {width=“400px”} 驱动 采用模块化设计： 1234567891011121314151617181920212223242526//demo.vmodule demo( input sys_clk, input sys_rst_n, output clk_100M, output clk_100M_pd, output clk_50M, output clk_25M); wire locked; clk_wiz_0 inst_IP_clock ( // Clock out ports .clk_out1(clk_100M), // output clk_out1 .clk_out2(clk_100M_pd), // output clk_out2 .clk_out3(clk_50M), // output clk_out3 .clk_out4(clk_25M), // output clk_out4 // Status and control signals .reset(!sys_rst_n), // input reset .locked(locked), // output locked // Clock in ports .clk_in1(sys_clk)); // input clk_in1endmodule 管脚约束： 12345678910#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1clk_100M, PIN_D1clk_100M_pd, PIN_F3clk_50M, PIN_F1clk_25M, PIN_F2 验证 功能仿真TestBench： 123456789101112131415161718192021222324252627282930313233//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire clk_100M; wire clk_100M_pd; wire clk_50M; wire clk_25M; always #10 sys_clk = ~sys_clk; initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; end demo inst_clock_gen ( // Clock out ports .clk_100M(clk_100M), // output clk_out1 .clk_100M_pd(clk_100M_pd), // output clk_out2 .clk_50M(clk_50M), // output clk_out3 .clk_25M(clk_25M), // output clk_out4 // Status and control signals .sys_rst_n(sys_rst_n), // input reset // Clock in ports .sys_clk(sys_clk)); // input clk_in1endmodule 运行结果： 从仿真结果上看，Locked拉高后输出时钟才稳定，使用时钟IP时，应注意这一特征，待locked拉起时使用输出的时钟。 上板 运行结果： 略","categories":[{"name":"Altera-FPGA 例程","slug":"Altera-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 型","slug":"Altera-FPGA-例程/EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilog例程（4）触摸键控灯","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-004","date":"2022-11-07T20:29:18.000Z","updated":"2023-06-03T05:58:15.055Z","comments":true,"path":"posts/3070638990.html","link":"","permalink":"https://sirius-blog.github.io/posts/3070638990.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。 器件 主芯片：Altera EP4CE10F17C8 。 目的 主要实现触摸式电容按键控制灯的开关效果。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input E1 此处时钟50MHz sys_rst_n input M1 此处复位低有效 led output D11 LED0，高电平点亮 touch_key input F8 触摸键信号 思路 驱动 采用模块化设计： 123456789101112131415161718//demo.vmodule demo(input sys_clk,input sys_rst_n,output led,input touch_key);touch_led inst_touch_led(.clk (sys_clk),.rstn (sys_rst_n),.touch_key (touch_key),.led(led));endmodule 1234567891011121314151617181920212223242526272829303132333435//touch_led.vmodule touch_led(input clk,input rstn,input touch_key,output reg led);reg [1:0] touch_key_r;wire touch_en;//check posedgeassign touch_en = (~touch_key_r[1]) &amp; touch_key_r[0];always@(posedge clk or negedge rstn)beginif(!rstn)touch_key_r &lt;= 2&#x27;d0;elsetouch_key_r &lt;= &#123;touch_key_r[0],touch_key&#125;;end//output valuealways@(posedge clk or negedge rstn)beginif(!rstn)led &lt;= 1&#x27;b0;else if(touch_en)led &lt;= ~led;elseled &lt;= led;endendmodule 管脚约束： 1234567# demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1touch_key, PIN_F8led, PIN_D11 验证 功能仿真TestBench： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo();reg sys_clk;reg sys_rst_n;wire led;reg key;initialbeginsys_clk = 1&#x27;b0;sys_rst_n = 1&#x27;b0;key = 1&#x27;b0;#20sys_rst_n = 1&#x27;b1;#30 //50ms downkey = 1&#x27;b1;#200 //250ms upkey = 1&#x27;b0;#30 //280ms downkey = 1&#x27;b1;#200 //480ms upkey = 1&#x27;b0;#30 //510ms downkey = 1&#x27;b1;#200 //710ms upkey = 1&#x27;b0;#30 //740ms downkey = 1&#x27;b1;#200 //940ms upkey = 1&#x27;b0;endalways#10 sys_clk = ~sys_clk;demo inst_touch_led(.sys_clk (sys_clk),.sys_rst_n (sys_rst_n),.touch_key (key),.led(led));endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"EP4CE10 型","slug":"EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilog例程（3）按键控蜂鸣器","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-003","date":"2022-11-07T19:59:18.000Z","updated":"2023-06-03T05:58:03.497Z","comments":true,"path":"posts/3652302925.html","link":"","permalink":"https://sirius-blog.github.io/posts/3652302925.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。 器件 主芯片：Altera EP4CE10F17C8 。 目的 主要实现点触式按键控制有源蜂鸣器发声效果。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input E1 此处时钟50MHz sys_rst_n input M1 此处复位低有效 beep output D12 BEEP，高电平驱动 key[0] input E16 KEY0，低电平按下 思路 驱动 采用模块化设计： 12345678910111213141516171819202122232425262728293031//demo.vmodule demo( input sys_clk, input sys_rst_n, output beep, input key);wire key_value;wire key_flag;key_debounce inst_key_debounce( .clk (sys_clk), .rstn (sys_rst_n), .key (key), .key_flag (key_flag), .key_value (key_value));beep_ctrl inst_beep_ctrl( .clk (sys_clk), .rstn (sys_rst_n), .key_flag (key_flag), .key_value (key_value), .beep (beep));endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//key_debounce.vmodule key_debounce( input clk, input rstn, input key, output reg key_value, output reg key_flag);reg [31:0] delay_cnt;reg key_reg;//delay timealways@(posedge clk or negedge rstn)begin if(!rstn) begin key_reg &lt;= 1&#x27;b1; delay_cnt &lt;= 32&#x27;d0; end else begin key_reg &lt;= key; if(key_reg!=key) //in shaked delay_cnt &lt;= 32&#x27;d1000000; else if(key_reg==key) begin if(delay_cnt &gt; 32&#x27;d0) delay_cnt &lt;= delay_cnt-1&#x27;b1; else delay_cnt &lt;= delay_cnt; end endend//output valuealways@(posedge clk or negedge rstn)begin if(!rstn) begin key_flag &lt;= 1&#x27;b0; key_value &lt;= 1&#x27;b1; end else begin if(delay_cnt == 32&#x27;d1) begin key_flag &lt;= 1&#x27;b1; key_value &lt;= key; end else begin key_flag &lt;= 1&#x27;b0; key_value &lt;= key; end endendendmodule 123456789101112131415161718192021222324//beep_ctrl.vmodule beep_ctrl( input clk, input rstn, output reg beep, input key_value, input key_flag);always@(posedge clk or negedge rstn)begin if(!rstn) beep &lt;= 1&#x27;b1; else begin if(key_flag&amp;&amp;(~key_value)) beep &lt;= ~beep; else beep &lt;= beep; endendendmodule 管脚约束(表头列出项中，默认default值应在之后的列中留空，如下)： 1234567# demo.txtTo, Location, Current Strengthsys_clk, PIN_E1,sys_rst_n, PIN_M1,beep, PIN_D12, 12mAkey, PIN_E16, 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire beep; reg key; parameter T=1000000;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; key = 1&#x27;b1; #20 sys_rst_n = 1&#x27;b1; #(30*T) //30ms down key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(170*T) //240ms up key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(170*T) //450ms down key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(30*T) //520ms up key = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo inst_key_beep( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .beep (beep), .key (key));endmodule 运行结果(联合Modelsim工具)： 上板 运行结果： 略","categories":[{"name":"EP4CE10 型","slug":"EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilog例程（2）按键控灯","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-002","date":"2022-11-07T19:29:18.000Z","updated":"2023-06-03T05:57:55.819Z","comments":true,"path":"posts/3020230158.html","link":"","permalink":"https://sirius-blog.github.io/posts/3020230158.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。 器件 主芯片：Altera EP4CE10F17C8 。 目的 主要实现点触式按键控制LED灯点亮的效果。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input E1 此处时钟50MHz sys_rst_n input M1 此处复位低有效 led[0] output D11 LED0，高电平点亮 led[1] output C11 LED1，高电平点亮 led[2] output E10 LED2，高电平点亮 led[3] output F9 LED3，高电平点亮 key[0] input E16 KEY0，低电平按下 key[1] input E15 KEY1，低电平按下 key[2] input M2 KEY2，低电平按下 key[3] input M16 KEY3，低电平按下 思路 驱动 采用模块化设计： 12345678910111213141516171819//demo.vmodule demo( input sys_clk, input sys_rst_n, output [3:0] led, input [3:0] key);key_led inst_key_led( .clk (sys_clk), .rstn (sys_rst_n), .led (led), .key (key));endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//key_led.vmodule key_led( input clk, input rstn, output reg [3:0] led, input [3:0] key);reg [23:0] cnt;reg [1:0] led_ctrl;//delayalways@(posedge clk or negedge rstn)begin if(!rstn) cnt &lt;= 24&#x27;d0; else if(cnt&lt;24&#x27;d10000000) cnt &lt;= cnt+1&#x27;b1; else cnt&lt;=24&#x27;d0;end//controlalways@(posedge clk or negedge rstn)begin if(!rstn) led_ctrl &lt;= 2&#x27;d0; else if(cnt==(24&#x27;d10000000-1&#x27;b1)) led_ctrl &lt;= led_ctrl+1&#x27;b1; else led_ctrl&lt;= led_ctrl;end//keyalways@(posedge clk or negedge rstn)begin if(!rstn) led &lt;= 4&#x27;b0000; else if(key[0]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b1000; 2&#x27;d1 : led &lt;= 4&#x27;b0100; 2&#x27;d2 : led &lt;= 4&#x27;b0010; 2&#x27;d3 : led &lt;= 4&#x27;b0001; default : led &lt;= 4&#x27;b0000; endcase else if(key[1]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b0001; 2&#x27;d1 : led &lt;= 4&#x27;b0010; 2&#x27;d2 : led &lt;= 4&#x27;b0100; 2&#x27;d3 : led &lt;= 4&#x27;b1000; default : led &lt;= 4&#x27;b0000; endcase else if(key[2]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b1111; 2&#x27;d1 : led &lt;= 4&#x27;b0000; 2&#x27;d2 : led &lt;= 4&#x27;b1111; 2&#x27;d3 : led &lt;= 4&#x27;b0000; default : led &lt;= 4&#x27;b0000; endcase else if(key[3]==1&#x27;b0) led &lt;= 4&#x27;b1111; else led &lt;= 4&#x27;b0000;endendmodule 管脚约束： 1234567891011121314#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1led[0], PIN_F9led[1], PIN_E10led[2], PIN_C11led[3], PIN_D11key[0], PIN_E16key[1], PIN_E15key[2], PIN_M2key[3], PIN_M16 验证 功能仿真TestBench： 1234567891011121314151617181920212223242526272829303132333435363738394041//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); parameter T=20; reg sys_clk; reg sys_rst_n; wire [3:0] led; reg [3:0] key;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; key = 4&#x27;b1111; #T sys_rst_n = 1&#x27;b1; key[0] = 1&#x27;b0; //down #(40000000*T) //800 key[0] = 1&#x27;b1; //up key[1] = 1&#x27;b0; #(40000000*T) key[1] = 1&#x27;b1; key[2] = 1&#x27;b0; #(40000000*T) key[2] = 1&#x27;b1; key[3] = 1&#x27;b0; #(40000000*T) key[3] = 1&#x27;b1;endalways#(T/2) sys_clk = ~sys_clk; demo inst_key_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led (led), .key (key));endmodule 运行结果(联合Modelsim工具)： 上板 运行结果： 略","categories":[{"name":"EP4CE10 型","slug":"EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilog例程（1）流水灯","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-001","date":"2022-11-07T18:29:18.000Z","updated":"2023-06-03T05:57:46.756Z","comments":true,"path":"posts/3765746710.html","link":"","permalink":"https://sirius-blog.github.io/posts/3765746710.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子开拓者开发板”，部分内容会有改动。 器件 主芯片：Altera EP4CE10F17C8 。 目的 主要实现LED灯按顺序以一定时间间隔逐个点亮及熄灭的效果。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input E1 此处时钟50MHz sys_rst_n input M1 此处复位低有效 led[0] output D11 LED0，高电平点亮 led[1] output C11 LED1，高电平点亮 led[2] output E10 LED2，高电平点亮 led[3] output F9 LED3，高电平点亮 思路 驱动 采用模块化设计： 1234567891011121314151617//demo.vmodule demo( input sys_clk, input sys_rst_n, output [3:0] led);flow_led inst_flow_led( .clk (sys_clk), .rstn (sys_rst_n), .led (led));endmodule 12345678910111213141516171819202122232425262728293031//flow_led.vmodule flow_led( input clk, input rstn, output reg [3:0] led);reg [25:0] cnt;always@(posedge clk or negedge rstn)//50MHz clkbegin if(!rstn) cnt &lt;= 26&#x27;d0; else if(cnt&lt;26&#x27;d10000000)//200ms cnt &lt;= cnt+1&#x27;b1; else cnt = 26&#x27;d0;endalways@(posedge clk or negedge rstn)//50MHz clkbegin if(!rstn) led &lt;= 4&#x27;b0001; else if(cnt==(26&#x27;d10000000-1&#x27;b1))//200ms led &lt;= &#123;led[2:0],led[3]&#125;; else led &lt;= led;endendmodule 管脚约束： 12345678910#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1led[0], PIN_F9led[1], PIN_E10led[2], PIN_C11led[3], PIN_D11 验证 功能仿真TestBench： 12345678910111213141516171819202122232425//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire [3:0] led;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo inst_flow_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led (led));endmodule 运行结果(联合Modelsim工具)： 上板 运行结果： 略","categories":[{"name":"EP4CE10 型","slug":"EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"}]},{"title":"STM32F1 库函数例程（1）跑马灯","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-001","date":"2022-11-07T18:29:18.000Z","updated":"2023-05-14T15:39:41.652Z","comments":true,"path":"posts/2499769614.html","link":"","permalink":"https://sirius-blog.github.io/posts/2499769614.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 对通用IO的基础操作——控制电平输出，实现跑马灯样式实验。 电路 硬件连接关系： STM32主要应用管脚分配： 信号 方向 管脚 说明 led0 output PB5 LED0驱动 led1 output PE5 LED1驱动 思路 调用官方库文件驱动GPIO口电平，根据电路连接关系可知如下预期结果： 端口 电平状态 现象 说明 PB5 输出低电平 LED0点亮 LED两端存在正向压降，满足点亮条件 PE5 输出低电平 LED1点亮 同上 PB5 输出高电平 LED0熄灭 LED两端无正向压降，不满足点亮条件 PE5 输出高电平 LED1熄灭 同上 驱动 led.c 1234567891011121314151617181920212223242526// led.c#include &quot;led.h&quot;//初始化PB5和PE5为输出口.并使能这两个口的时钟 //LED IO初始化void LED_Init(void)&#123; // 定义初始化结构体变量 GPIO_InitTypeDef GPIO_InitStructure; // 使能PB,PE端口时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE, ENABLE); // PB.5 PE.5 端口配置（结构体变量配值） GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO口速度为50MHz GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //结构体变量初始化GPIOB.5 GPIO_SetBits(GPIOB,GPIO_Pin_5); //PB.5 初始化输出置高 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_Init(GPIOE, &amp;GPIO_InitStructure); //结构体变量初始化GPIOE.5 GPIO_SetBits(GPIOE,GPIO_Pin_5); //PE.5 初始化输出置高 &#125;/******************* END OF FILE *********/ led.h 123456789101112131415// led.h#ifndef __LED_H#define __LED_H #include &quot;sys.h&quot;//LED端口定义（位带操作）#define LED0 PBout(5)// PB5#define LED1 PEout(5)// PE5 //端口初始化函数定义声明void LED_Init(void); #endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819 #include &quot;led.h&quot; //引入自定义的函数//main.c int main(void) &#123; delay_init(); //延时函数初始化 LED_Init(); //初始化与LED连接的硬件接口 while(1) &#123; LED0=0; LED1=1; delay_ms(300); //延时300ms LED0=1; LED1=0; delay_ms(300); //延时300ms &#125; &#125;/******************* END OF FILE *********/ 上板 运行结果： 略 闲谈 章节目的 本章主要是熟悉基础 GPIO 端口的驱动，涉及器件物理引脚电平变化以及驱动方向、方式。以有形的指示灯变化来表现端口电平的变化，表现逻辑程序对器件引脚的捆绑关系。 程序段分析 对端口的驱动，这里主要进行如下设置（见 led.c ）: 启动相应端口时钟 Clock; 初始化端配置，包括“具体引脚 PIN_x ”、“端口模式 Mode ”、“速度配置 Speed ”; 将上述配置使用官方库函数进行对对应端口引脚进行初始化(函数 GPIO_Init() ); 对相应端口引脚进行初始状态定义，如输出高电平（函数 GPIO_SetBits() ）或低电压（函数 GPIO_ResetBits() ），自定义函数需要进行声明处理方可跨文件调用; 主函数中对端口进行配置驱动，如常亮、常暗、闪烁等等。","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 寄存器例程（1）跑马灯","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vregister-001","date":"2022-11-07T18:29:18.000Z","updated":"2023-04-05T04:21:12.620Z","comments":true,"path":"posts/861685022.html","link":"","permalink":"https://sirius-blog.github.io/posts/861685022.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子精英开发板”，部分内容会有改动。 器件 主芯片：ST STM32F103 。 目的 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input E1 此处时钟50MHz sys_rst_n input M1 此处复位低有效 思路 驱动 采用模块化设计： 1 1 管脚约束： 12 验证 功能仿真TestBench： 123//tb_demo.c 运行结果(联合Modelsim工具)： 上板 运行结果： 略","categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 寄存器版","slug":"MCU-例程/STM32F1-寄存器版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%AF%84%E5%AD%98%E5%99%A8%E7%89%88/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"}]},{"title":"【未完】XC7A35T Verilog 例程（25）DDR3读写测试","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-025","date":"2022-10-29T07:35:18.000Z","updated":"2023-04-05T04:17:01.966Z","comments":true,"path":"posts/1351360347.html","link":"","permalink":"https://sirius-blog.github.io/posts/1351360347.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目标器件：CH340 （串口转USB,电平类型转换芯片，TTL电平与USB差分电平的转换） 目标器件：SP3232 （电平类型转换芯片，TTL电平与RS232电平的转换） 目的 主要实现串口通信协议的传输效果。 电路 {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 uart_rxd input U5 串口收 uart_txd output T6 串口发 思路 {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule 管脚约束： 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // 驱动时钟 50MHz ，20ns parameter UART_BPS = 115200; // 波特率 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // 单bit传输耗时 BPS_CNT 个驱动时钟周期 initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule 运行结果： 略 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"【未完】XC7A35T Verilog 例程（24）USB通信实验","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-024","date":"2022-10-29T06:35:18.000Z","updated":"2023-04-05T04:16:58.349Z","comments":true,"path":"posts/3799897035.html","link":"","permalink":"https://sirius-blog.github.io/posts/3799897035.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目标器件：CH340 （串口转USB,电平类型转换芯片，TTL电平与USB差分电平的转换） 目标器件：SP3232 （电平类型转换芯片，TTL电平与RS232电平的转换） 目的 主要实现串口通信协议的传输效果。 电路 {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 uart_rxd input U5 串口收 uart_txd output T6 串口发 思路 {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule 管脚约束： 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // 驱动时钟 50MHz ，20ns parameter UART_BPS = 115200; // 波特率 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // 单bit传输耗时 BPS_CNT 个驱动时钟周期 initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule 运行结果： 略 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"【未完】XC7A35T Verilog 例程（23）双路高速AD实验","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-023","date":"2022-10-29T05:35:18.000Z","updated":"2023-04-05T04:16:55.252Z","comments":true,"path":"posts/640324073.html","link":"","permalink":"https://sirius-blog.github.io/posts/640324073.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目标器件：CH340 （串口转USB,电平类型转换芯片，TTL电平与USB差分电平的转换） 目标器件：SP3232 （电平类型转换芯片，TTL电平与RS232电平的转换） 目的 主要实现串口通信协议的传输效果。 电路 {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 uart_rxd input U5 串口收 uart_txd output T6 串口发 思路 {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule 管脚约束： 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // 驱动时钟 50MHz ，20ns parameter UART_BPS = 115200; // 波特率 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // 单bit传输耗时 BPS_CNT 个驱动时钟周期 initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule 运行结果： 略 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"【未完】XC7A35T Verilog 例程（22）双路高速DA实验","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-022","date":"2022-10-29T04:35:18.000Z","updated":"2023-04-05T04:16:52.418Z","comments":true,"path":"posts/3185038605.html","link":"","permalink":"https://sirius-blog.github.io/posts/3185038605.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目标器件：CH340 （串口转USB,电平类型转换芯片，TTL电平与USB差分电平的转换） 目标器件：SP3232 （电平类型转换芯片，TTL电平与RS232电平的转换） 目的 主要实现串口通信协议的传输效果。 电路 {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 uart_rxd input U5 串口收 uart_txd output T6 串口发 思路 {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule 管脚约束： 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // 驱动时钟 50MHz ，20ns parameter UART_BPS = 115200; // 波特率 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // 单bit传输耗时 BPS_CNT 个驱动时钟周期 initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule 运行结果： 略 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"【未完】XC7A35T Verilog 例程（21）高速AD/DA实验","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-021","date":"2022-10-29T03:35:18.000Z","updated":"2023-04-05T04:16:48.719Z","comments":true,"path":"posts/2112430596.html","link":"","permalink":"https://sirius-blog.github.io/posts/2112430596.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目标器件：CH340 （串口转USB,电平类型转换芯片，TTL电平与USB差分电平的转换） 目标器件：SP3232 （电平类型转换芯片，TTL电平与RS232电平的转换） 目的 主要实现串口通信协议的传输效果。 电路 {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 uart_rxd input U5 串口收 uart_txd output T6 串口发 思路 {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule 管脚约束： 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // 驱动时钟 50MHz ，20ns parameter UART_BPS = 115200; // 波特率 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // 单bit传输耗时 BPS_CNT 个驱动时钟周期 initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule 运行结果： 略 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"【未完】XC7A35T Verilog 例程（19）RTC实时时钟","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-019","date":"2022-10-29T02:35:18.000Z","updated":"2023-04-05T04:16:45.269Z","comments":true,"path":"posts/4222622403.html","link":"","permalink":"https://sirius-blog.github.io/posts/4222622403.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目标器件：PCF8563 （工业级多功能时钟/日历芯片） {width=“400px”} {width=“400px”} {width=“400px”} 目的 主要实现串口通信协议的传输效果。 电路 {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 iic_scl output R6 时钟线 iic_sda inout T4 数据线 思路 {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule 管脚约束： 12345#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN R6 IOSTANDARD LVCMOS33&#125; [get_ports iic_scl] set_property -dict &#123;PACKAGE_PIN T4 IOSTANDARD LVCMOS33&#125; [get_ports iic_sda] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // 驱动时钟 50MHz ，20ns parameter UART_BPS = 115200; // 波特率 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // 单bit传输耗时 BPS_CNT 个驱动时钟周期 initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule 运行结果： 略 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"【未完】XC7A35T Verilog 例程（18）EEPROM读写测试","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-018","date":"2022-10-29T01:35:18.000Z","updated":"2023-04-05T04:16:41.676Z","comments":true,"path":"posts/1648067106.html","link":"","permalink":"https://sirius-blog.github.io/posts/1648067106.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目标器件：AT24C64 （64Kbit存储容量EEPROM）。 {width=“400px”} ###主要参数 1.接口总线物理样式 {width=“400px”} 2.接口协议时序 3.器件地址格式 4.写时序 5.读时序 目的 主要实现访问EEPROM存储器。 EEPROM是一种用于计算机系统得非易失性存储器存储，AT24C64采用两线串行接口的双向数据传输协议——I2C协议实现读写操作。 电路 {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 iic_scl output R6 时钟线 iic_sda inout T4 数据线 led output R2 LED指示灯 思路 {width=“400px”} 驱动 采用模块化设计： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//demo.vmodule demo( input sys_clk , //系统时钟 input sys_rst_n , //系统复位 //eeprom interface output iic_scl , //eeprom的时钟线scl inout iic_sda , //eeprom的数据线sda //user interface output led //led显示);//parameter defineparameter SLAVE_ADDR = 7&#x27;b1010000 ; //器件地址(SLAVE_ADDR)parameter BIT_CTRL = 1&#x27;b1 ; //字地址位控制参数(16b/8b)parameter CLK_FREQ = 26&#x27;d50_000_000; //i2c_dri模块的驱动时钟频率(CLK_FREQ)parameter I2C_FREQ = 18&#x27;d250_000 ; //I2C的SCL时钟频率parameter L_TIME = 17&#x27;d125_000 ; //led闪烁时间参数//wire definewire dri_clk ; //I2C操作时钟wire i2c_exec ; //I2C触发控制wire [15:0] i2c_addr ; //I2C操作地址wire [ 7:0] i2c_data_w; //I2C写入的数据wire i2c_done ; //I2C操作结束标志wire i2c_ack ; //I2C应答标志 0:应答 1:未应答wire i2c_rh_wl ; //I2C读写控制wire [ 7:0] i2c_data_r; //I2C读出的数据wire rw_done ; //E2PROM读写测试完成wire rw_result ; //E2PROM读写测试结果 0:失败 1:成功 //e2prom读写测试模块e2prom_rw u_e2prom_rw( .clk (dri_clk ), //时钟信号 .rst_n (sys_rst_n ), //复位信号 //i2c interface .i2c_exec (i2c_exec ), //I2C触发执行信号 .i2c_rh_wl (i2c_rh_wl ), //I2C读写控制信号 .i2c_addr (i2c_addr ), //I2C器件内地址 .i2c_data_w (i2c_data_w), //I2C要写的数据 .i2c_data_r (i2c_data_r), //I2C读出的数据 .i2c_done (i2c_done ), //I2C一次操作完成 .i2c_ack (i2c_ack ), //I2C应答标志 //user interface .rw_done (rw_done ), //E2PROM读写测试完成 .rw_result (rw_result ) //E2PROM读写测试结果 0:失败 1:成功);//i2c驱动模块i2c_driver #( .SLAVE_ADDR (SLAVE_ADDR), //EEPROM从机地址 .CLK_FREQ (CLK_FREQ ), //模块输入的时钟频率 .I2C_FREQ (I2C_FREQ ) //IIC_SCL的时钟频率) u_i2c_driver( .clk (sys_clk ), .rst_n (sys_rst_n ), //i2c interface .i2c_exec (i2c_exec ), //I2C触发执行信号 .bit_ctrl (BIT_CTRL ), //器件地址位控制(16b/8b) .i2c_rh_wl (i2c_rh_wl ), //I2C读写控制信号 .i2c_addr (i2c_addr ), //I2C器件内地址 .i2c_data_w (i2c_data_w), //I2C要写的数据 .i2c_data_r (i2c_data_r), //I2C读出的数据 .i2c_done (i2c_done ), //I2C一次操作完成 .i2c_ack (i2c_ack ), //I2C应答标志 .scl (iic_scl ), //I2C的SCL时钟信号 .sda (iic_sda ), //I2C的SDA信号 //user interface .dri_clk (dri_clk ) //I2C操作时钟);//led指示模块led_alarm #(.L_TIME(L_TIME ) //控制led闪烁时间) u_led_alarm( .clk (dri_clk ), .rst_n (sys_rst_n ), .rw_done (rw_done ), .rw_result (rw_result ), .led (led ) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496// i2c_driver.vmodule i2c_driver #( parameter SLAVE_ADDR = 7&#x27;b1010000 , //EEPROM从机地址 parameter CLK_FREQ = 26&#x27;d50_000_000, //模块输入的时钟频率 parameter I2C_FREQ = 18&#x27;d250_000 //IIC_SCL的时钟频率 ) ( input clk , input rst_n , //i2c interface input i2c_exec , //I2C触发执行信号 input bit_ctrl , //字地址位控制(16b/8b) input i2c_rh_wl , //I2C读写控制信号 input [15:0] i2c_addr , //I2C器件内地址 input [ 7:0] i2c_data_w , //I2C要写的数据 output reg [ 7:0] i2c_data_r , //I2C读出的数据 output reg i2c_done , //I2C一次操作完成 output reg i2c_ack , //I2C应答标志 0:应答 1:未应答 output reg scl , //I2C的SCL时钟信号 inout sda , //I2C的SDA信号 //user interface output reg dri_clk //驱动I2C操作的驱动时钟 );//localparam definelocalparam st_idle = 8&#x27;b0000_0001; //空闲状态localparam st_sladdr = 8&#x27;b0000_0010; //发送器件地址(slave address)localparam st_addr16 = 8&#x27;b0000_0100; //发送16位字地址localparam st_addr8 = 8&#x27;b0000_1000; //发送8位字地址localparam st_data_wr = 8&#x27;b0001_0000; //写数据(8 bit)localparam st_addr_rd = 8&#x27;b0010_0000; //发送器件地址读localparam st_data_rd = 8&#x27;b0100_0000; //读数据(8 bit)localparam st_stop = 8&#x27;b1000_0000; //结束I2C操作//reg definereg sda_dir ; //I2C数据(SDA)方向控制reg sda_out ; //SDA输出信号reg st_done ; //状态结束reg wr_flag ; //写标志reg [ 6:0] cnt ; //计数reg [ 7:0] cur_state ; //状态机当前状态reg [ 7:0] next_state; //状态机下一状态reg [15:0] addr_t ; //地址reg [ 7:0] data_r ; //读取的数据reg [ 7:0] data_wr_t ; //I2C需写的数据的临时寄存reg [ 9:0] clk_cnt ; //分频时钟计数//wire definewire sda_in ; //SDA输入信号wire [8:0] clk_divide ; //模块驱动时钟的分频系数//SDA控制assign sda = sda_dir ? sda_out : 1&#x27;bz; //SDA数据输出或高阻assign sda_in = sda ; //SDA数据输入assign clk_divide = (CLK_FREQ/I2C_FREQ) &gt;&gt; 2&#x27;d2;//模块驱动时钟的分频系数//生成I2C的SCL的四倍频率的驱动时钟用于驱动i2c的操作always @(posedge clk or negedge rst_n) begin if(!rst_n) begin dri_clk &lt;= 1&#x27;b0; clk_cnt &lt;= 10&#x27;d0; end else if(clk_cnt == clk_divide[8:1] - 1&#x27;d1) begin clk_cnt &lt;= 10&#x27;d0; dri_clk &lt;= ~dri_clk; end else clk_cnt &lt;= clk_cnt + 1&#x27;b1;end//(三段式状态机)同步时序描述状态转移always @(posedge dri_clk or negedge rst_n) begin if(!rst_n) cur_state &lt;= st_idle; else cur_state &lt;= next_state;end//组合逻辑判断状态转移条件always @(*) begin next_state = st_idle; case(cur_state) st_idle: begin //空闲状态 if(i2c_exec) begin next_state = st_sladdr; end else next_state = st_idle; end st_sladdr: begin if(st_done) begin if(bit_ctrl) //判断是16位还是8位字地址 next_state = st_addr16; else next_state = st_addr8 ; end else next_state = st_sladdr; end st_addr16: begin //写16位字地址 if(st_done) begin next_state = st_addr8; end else begin next_state = st_addr16; end end st_addr8: begin //8位字地址 if(st_done) begin if(wr_flag==1&#x27;b0) //读写判断 next_state = st_data_wr; else next_state = st_addr_rd; end else begin next_state = st_addr8; end end st_data_wr: begin //写数据(8 bit) if(st_done) next_state = st_stop; else next_state = st_data_wr; end st_addr_rd: begin //写地址以进行读数据 if(st_done) begin next_state = st_data_rd; end else begin next_state = st_addr_rd; end end st_data_rd: begin //读取数据(8 bit) if(st_done) next_state = st_stop; else next_state = st_data_rd; end st_stop: begin //结束I2C操作 if(st_done) next_state = st_idle; else next_state = st_stop ; end default: next_state= st_idle; endcaseend//时序电路描述状态输出always @(posedge dri_clk or negedge rst_n) begin //复位初始化 if(!rst_n) begin scl &lt;= 1&#x27;b1; sda_out &lt;= 1&#x27;b1; sda_dir &lt;= 1&#x27;b1; i2c_done &lt;= 1&#x27;b0; i2c_ack &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; st_done &lt;= 1&#x27;b0; data_r &lt;= 1&#x27;b0; i2c_data_r&lt;= 1&#x27;b0; wr_flag &lt;= 1&#x27;b0; addr_t &lt;= 1&#x27;b0; data_wr_t &lt;= 1&#x27;b0; end else begin st_done &lt;= 1&#x27;b0 ; cnt &lt;= cnt +1&#x27;b1 ; case(cur_state) st_idle: begin //空闲状态 scl &lt;= 1&#x27;b1; sda_out &lt;= 1&#x27;b1; sda_dir &lt;= 1&#x27;b1; i2c_done&lt;= 1&#x27;b0; cnt &lt;= 7&#x27;b0; if(i2c_exec) begin wr_flag &lt;= i2c_rh_wl ; addr_t &lt;= i2c_addr ; data_wr_t &lt;= i2c_data_w; i2c_ack &lt;= 1&#x27;b0; end end st_sladdr: begin //写地址(器件地址和字地址) case(cnt) 7&#x27;d1 : sda_out &lt;= 1&#x27;b0; //开始I2C 7&#x27;d3 : scl &lt;= 1&#x27;b0; 7&#x27;d4 : sda_out &lt;= SLAVE_ADDR[6]; //传送器件地址 7&#x27;d5 : scl &lt;= 1&#x27;b1; 7&#x27;d7 : scl &lt;= 1&#x27;b0; 7&#x27;d8 : sda_out &lt;= SLAVE_ADDR[5]; 7&#x27;d9 : scl &lt;= 1&#x27;b1; 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d12: sda_out &lt;= SLAVE_ADDR[4]; 7&#x27;d13: scl &lt;= 1&#x27;b1; 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d16: sda_out &lt;= SLAVE_ADDR[3]; 7&#x27;d17: scl &lt;= 1&#x27;b1; 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d20: sda_out &lt;= SLAVE_ADDR[2]; 7&#x27;d21: scl &lt;= 1&#x27;b1; 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d24: sda_out &lt;= SLAVE_ADDR[1]; 7&#x27;d25: scl &lt;= 1&#x27;b1; 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d28: sda_out &lt;= SLAVE_ADDR[0]; 7&#x27;d29: scl &lt;= 1&#x27;b1; 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: sda_out &lt;= 1&#x27;b0; //0:写 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d35: scl &lt;= 1&#x27;b0; 7&#x27;d36: begin sda_dir &lt;= 1&#x27;b0; sda_out &lt;= 1&#x27;b1; end 7&#x27;d37: scl &lt;= 1&#x27;b1; 7&#x27;d38: begin //从机应答 st_done &lt;= 1&#x27;b1; if(sda_in == 1&#x27;b1) //高电平表示未应答 i2c_ack &lt;= 1&#x27;b1; //拉高应答标志位 end 7&#x27;d39: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; end default : ; endcase end st_addr16: begin case(cnt) 7&#x27;d0 : begin sda_dir &lt;= 1&#x27;b1 ; sda_out &lt;= addr_t[15]; //传送字地址 end 7&#x27;d1 : scl &lt;= 1&#x27;b1; 7&#x27;d3 : scl &lt;= 1&#x27;b0; 7&#x27;d4 : sda_out &lt;= addr_t[14]; 7&#x27;d5 : scl &lt;= 1&#x27;b1; 7&#x27;d7 : scl &lt;= 1&#x27;b0; 7&#x27;d8 : sda_out &lt;= addr_t[13]; 7&#x27;d9 : scl &lt;= 1&#x27;b1; 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d12: sda_out &lt;= addr_t[12]; 7&#x27;d13: scl &lt;= 1&#x27;b1; 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d16: sda_out &lt;= addr_t[11]; 7&#x27;d17: scl &lt;= 1&#x27;b1; 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d20: sda_out &lt;= addr_t[10]; 7&#x27;d21: scl &lt;= 1&#x27;b1; 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d24: sda_out &lt;= addr_t[9]; 7&#x27;d25: scl &lt;= 1&#x27;b1; 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d28: sda_out &lt;= addr_t[8]; 7&#x27;d29: scl &lt;= 1&#x27;b1; 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: begin sda_dir &lt;= 1&#x27;b0; sda_out &lt;= 1&#x27;b1; end 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d34: begin //从机应答 st_done &lt;= 1&#x27;b1; if(sda_in == 1&#x27;b1) //高电平表示未应答 i2c_ack &lt;= 1&#x27;b1; //拉高应答标志位 end 7&#x27;d35: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; end default : ; endcase end st_addr8: begin case(cnt) 7&#x27;d0: begin sda_dir &lt;= 1&#x27;b1 ; sda_out &lt;= addr_t[7]; //字地址 end 7&#x27;d1 : scl &lt;= 1&#x27;b1; 7&#x27;d3 : scl &lt;= 1&#x27;b0; 7&#x27;d4 : sda_out &lt;= addr_t[6]; 7&#x27;d5 : scl &lt;= 1&#x27;b1; 7&#x27;d7 : scl &lt;= 1&#x27;b0; 7&#x27;d8 : sda_out &lt;= addr_t[5]; 7&#x27;d9 : scl &lt;= 1&#x27;b1; 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d12: sda_out &lt;= addr_t[4]; 7&#x27;d13: scl &lt;= 1&#x27;b1; 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d16: sda_out &lt;= addr_t[3]; 7&#x27;d17: scl &lt;= 1&#x27;b1; 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d20: sda_out &lt;= addr_t[2]; 7&#x27;d21: scl &lt;= 1&#x27;b1; 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d24: sda_out &lt;= addr_t[1]; 7&#x27;d25: scl &lt;= 1&#x27;b1; 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d28: sda_out &lt;= addr_t[0]; 7&#x27;d29: scl &lt;= 1&#x27;b1; 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: begin sda_dir &lt;= 1&#x27;b0; sda_out &lt;= 1&#x27;b1; end 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d34: begin //从机应答 st_done &lt;= 1&#x27;b1; if(sda_in == 1&#x27;b1) //高电平表示未应答 i2c_ack &lt;= 1&#x27;b1; //拉高应答标志位 end 7&#x27;d35: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; end default : ; endcase end st_data_wr: begin //写数据(8 bit) case(cnt) 7&#x27;d0: begin sda_out &lt;= data_wr_t[7]; //I2C写8位数据 sda_dir &lt;= 1&#x27;b1; end 7&#x27;d1 : scl &lt;= 1&#x27;b1; 7&#x27;d3 : scl &lt;= 1&#x27;b0; 7&#x27;d4 : sda_out &lt;= data_wr_t[6]; 7&#x27;d5 : scl &lt;= 1&#x27;b1; 7&#x27;d7 : scl &lt;= 1&#x27;b0; 7&#x27;d8 : sda_out &lt;= data_wr_t[5]; 7&#x27;d9 : scl &lt;= 1&#x27;b1; 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d12: sda_out &lt;= data_wr_t[4]; 7&#x27;d13: scl &lt;= 1&#x27;b1; 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d16: sda_out &lt;= data_wr_t[3]; 7&#x27;d17: scl &lt;= 1&#x27;b1; 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d20: sda_out &lt;= data_wr_t[2]; 7&#x27;d21: scl &lt;= 1&#x27;b1; 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d24: sda_out &lt;= data_wr_t[1]; 7&#x27;d25: scl &lt;= 1&#x27;b1; 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d28: sda_out &lt;= data_wr_t[0]; 7&#x27;d29: scl &lt;= 1&#x27;b1; 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: begin sda_dir &lt;= 1&#x27;b0; sda_out &lt;= 1&#x27;b1; end 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d34: begin //从机应答 st_done &lt;= 1&#x27;b1; if(sda_in == 1&#x27;b1) //高电平表示未应答 i2c_ack &lt;= 1&#x27;b1; //拉高应答标志位 end 7&#x27;d35: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; end default : ; endcase end st_addr_rd: begin //写地址以进行读数据 case(cnt) 7&#x27;d0 : begin sda_dir &lt;= 1&#x27;b1; sda_out &lt;= 1&#x27;b1; end 7&#x27;d1 : scl &lt;= 1&#x27;b1; 7&#x27;d2 : sda_out &lt;= 1&#x27;b0; //重新开始 7&#x27;d3 : scl &lt;= 1&#x27;b0; 7&#x27;d4 : sda_out &lt;= SLAVE_ADDR[6]; //传送器件地址 7&#x27;d5 : scl &lt;= 1&#x27;b1; 7&#x27;d7 : scl &lt;= 1&#x27;b0; 7&#x27;d8 : sda_out &lt;= SLAVE_ADDR[5]; 7&#x27;d9 : scl &lt;= 1&#x27;b1; 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d12: sda_out &lt;= SLAVE_ADDR[4]; 7&#x27;d13: scl &lt;= 1&#x27;b1; 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d16: sda_out &lt;= SLAVE_ADDR[3]; 7&#x27;d17: scl &lt;= 1&#x27;b1; 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d20: sda_out &lt;= SLAVE_ADDR[2]; 7&#x27;d21: scl &lt;= 1&#x27;b1; 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d24: sda_out &lt;= SLAVE_ADDR[1]; 7&#x27;d25: scl &lt;= 1&#x27;b1; 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d28: sda_out &lt;= SLAVE_ADDR[0]; 7&#x27;d29: scl &lt;= 1&#x27;b1; 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: sda_out &lt;= 1&#x27;b1; //1:读 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d35: scl &lt;= 1&#x27;b0; 7&#x27;d36: begin sda_dir &lt;= 1&#x27;b0; sda_out &lt;= 1&#x27;b1; end 7&#x27;d37: scl &lt;= 1&#x27;b1; 7&#x27;d38: begin //从机应答 st_done &lt;= 1&#x27;b1; if(sda_in == 1&#x27;b1) //高电平表示未应答 i2c_ack &lt;= 1&#x27;b1; //拉高应答标志位 end 7&#x27;d39: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; end default : ; endcase end st_data_rd: begin //读取数据(8 bit) case(cnt) 7&#x27;d0: sda_dir &lt;= 1&#x27;b0; 7&#x27;d1: begin data_r[7] &lt;= sda_in; scl &lt;= 1&#x27;b1; end 7&#x27;d3: scl &lt;= 1&#x27;b0; 7&#x27;d5: begin data_r[6] &lt;= sda_in ; scl &lt;= 1&#x27;b1 ; end 7&#x27;d7: scl &lt;= 1&#x27;b0; 7&#x27;d9: begin data_r[5] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d13: begin data_r[4] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d17: begin data_r[3] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d21: begin data_r[2] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d25: begin data_r[1] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d29: begin data_r[0] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: begin sda_dir &lt;= 1&#x27;b1; sda_out &lt;= 1&#x27;b1; end 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d34: st_done &lt;= 1&#x27;b1; //非应答 7&#x27;d35: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; i2c_data_r &lt;= data_r; end default : ; endcase end st_stop: begin //结束I2C操作 case(cnt) 7&#x27;d0: begin sda_dir &lt;= 1&#x27;b1; //结束I2C sda_out &lt;= 1&#x27;b0; end 7&#x27;d1 : scl &lt;= 1&#x27;b1; 7&#x27;d3 : sda_out &lt;= 1&#x27;b1; 7&#x27;d15: st_done &lt;= 1&#x27;b1; 7&#x27;d16: begin cnt &lt;= 1&#x27;b0; i2c_done &lt;= 1&#x27;b1; //向上层模块传递I2C结束信号 end default : ; endcase end endcase endendendmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// e2prom_rw.vmodule e2prom_rw( input clk , //时钟信号 input rst_n , //复位信号 //i2c interface output reg i2c_rh_wl , //I2C读写控制信号 output reg i2c_exec , //I2C触发执行信号 output reg [15:0] i2c_addr , //I2C器件内地址 output reg [ 7:0] i2c_data_w , //I2C要写的数据 input [ 7:0] i2c_data_r , //I2C读出的数据 input i2c_done , //I2C一次操作完成 input i2c_ack , //I2C应答标志 //user interface output reg rw_done , //E2PROM读写测试完成 output reg rw_result //E2PROM读写测试结果 0:失败 1:成功);//parameter define//EEPROM写数据需要添加间隔时间,读数据则不需要parameter WR_WAIT_TIME = 14&#x27;d5000; //写入间隔时间parameter MAX_BYTE = 16&#x27;d256 ; //读写测试的字节个数//reg definereg [1:0] flow_cnt ; //状态流控制reg [13:0] wait_cnt ; //延时计数器//EEPROM读写测试,先写后读，并比较读出的值与写入的值是否一致always @(posedge clk or negedge rst_n) begin if(!rst_n) begin flow_cnt &lt;= 2&#x27;b0; i2c_rh_wl &lt;= 1&#x27;b0; i2c_exec &lt;= 1&#x27;b0; i2c_addr &lt;= 16&#x27;b0; i2c_data_w &lt;= 8&#x27;b0; wait_cnt &lt;= 14&#x27;b0; rw_done &lt;= 1&#x27;b0; rw_result &lt;= 1&#x27;b0; end else begin i2c_exec &lt;= 1&#x27;b0; rw_done &lt;= 1&#x27;b0; case(flow_cnt) 2&#x27;d0 : begin wait_cnt &lt;= wait_cnt + 1&#x27;b1; //延时计数 if(wait_cnt == WR_WAIT_TIME - 1&#x27;b1) begin //EEPROM写操作延时完成 wait_cnt &lt;= 1&#x27;b0; if(i2c_addr == MAX_BYTE) begin //256个字节写入完成 i2c_addr &lt;= 1&#x27;b0; i2c_rh_wl &lt;= 1&#x27;b1; flow_cnt &lt;= 2&#x27;d2; end else begin flow_cnt &lt;= flow_cnt + 1&#x27;b1; i2c_exec &lt;= 1&#x27;b1; end end end 2&#x27;d1 : begin if(i2c_done == 1&#x27;b1) begin //EEPROM单次写入完成 flow_cnt &lt;= 2&#x27;d0; i2c_addr &lt;= i2c_addr + 1&#x27;b1; //地址0~255分别写入 i2c_data_w &lt;= i2c_data_w + 1&#x27;b1; //数据0~255 end end 2&#x27;d2 : begin flow_cnt &lt;= flow_cnt + 1&#x27;b1; i2c_exec &lt;= 1&#x27;b1; end 2&#x27;d3 : begin if(i2c_done == 1&#x27;b1) begin //EEPROM单次读出完成 //读出的值错误或者I2C未应答,读写测试失败 if((i2c_addr[7:0] != i2c_data_r) || (i2c_ack == 1&#x27;b1)) begin rw_done &lt;= 1&#x27;b1; rw_result &lt;= 1&#x27;b0; end else if(i2c_addr == MAX_BYTE - 1&#x27;b1) begin //读写测试成功 rw_done &lt;= 1&#x27;b1; rw_result &lt;= 1&#x27;b1; end else begin flow_cnt &lt;= 2&#x27;d2; i2c_addr &lt;= i2c_addr + 1&#x27;b1; end end end default : ; endcase endend endmodule 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// led_alarm.vmodule led_alarm #(parameter L_TIME = 25&#x27;d25_000_000 ) ( input clk , //时钟信号 input rst_n , //复位信号 input rw_done , //错误标志 input rw_result , //E2PROM读写测试完成 output reg led //E2PROM读写测试结果 0:失败 1:成功);//reg definereg rw_done_flag; //读写测试完成标志reg [24:0] led_cnt ; //led计数//读写测试完成标志always @(posedge clk or negedge rst_n) begin if(!rst_n) rw_done_flag &lt;= 1&#x27;b0; else if(rw_done) rw_done_flag &lt;= 1&#x27;b1;end //错误标志为1时PL_LED0闪烁，否则PL_LED0常亮always @(posedge clk or negedge rst_n) begin if(!rst_n) begin led_cnt &lt;= 25&#x27;d0; led &lt;= 1&#x27;b0; end else begin if(rw_done_flag) begin if(rw_result) //读写测试正确 led &lt;= 1&#x27;b1; //led灯常亮 else begin //读写测试错误 led_cnt &lt;= led_cnt + 25&#x27;d1; if(led_cnt == L_TIME - 1&#x27;b1) begin led_cnt &lt;= 25&#x27;d0; led &lt;= ~led; //led灯闪烁 end end end else led &lt;= 1&#x27;b0; //读写测试完成之前,led灯熄灭 end endendmodule 管脚约束： 123456#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk]set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n]set_property -dict &#123;PACKAGE_PIN R6 IOSTANDARD LVCMOS33&#125; [get_ports iic_scl]set_property -dict &#123;PACKAGE_PIN T4 IOSTANDARD LVCMOS33&#125; [get_ports iic_sda]set_property -dict &#123;PACKAGE_PIN R2 IOSTANDARD LVCMOS15&#125; [get_ports led] 验证 功能仿真TestBench： 12//tb_demo.v 运行结果： 略 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（17）数字频率计","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-017","date":"2022-10-29T00:35:18.000Z","updated":"2023-04-05T04:16:38.500Z","comments":true,"path":"posts/3335218492.html","link":"","permalink":"https://sirius-blog.github.io/posts/3335218492.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目的 主要实现输入时钟的频率测试。 电路 无 FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 clk_fx input U5 被测时钟 思路 在一次实际闸门时间GATE_TIME中，计数器对被测信号的计数值未fx_cnt，对基准时钟的频率为fs_cnt，而基准时钟的频率为CLK_FS，则被测信号的频率为clk_fx，即由公式 fs_cnt/CLK_FS = GATE_TIME = fx_cnt/clk_fx 得 clk_fx = fx_cnt*(CLK_FS/fs_cnt) 驱动 采用模块化设计： 123456789101112131415161718192021//demo.vmodule demo ( //system clock input clk_fs , // 基准时钟信号 input rst_n , // 复位信号 input clk_fx // 被测时钟信号); cymometer #(.CLK_FS(26&#x27;d50000000)) // 基准时钟频率值 inst_cymometer ( //system clock .clk_fs (.clk_fs ), // 基准时钟信号 .rst_n (.rst_n ), // 复位信号 .clk_fx (.clk_fx ), // 被测时钟信号 .data_fx () // 被测时钟频率输出 );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163//cymometer.vmodule cymometer #(parameter CLK_FS = 26&#x27;d50000000) // 基准时钟频率值 ( //system clock input clk_fs , // 基准时钟信号 input rst_n , // 复位信号 //cymometer interface input clk_fx , // 被测时钟信号 output reg [19:0] data_fx // 被测时钟频率输出);//parameter definelocalparam MAX = 6&#x27;d32; // 定义fs_cnt、fx_cnt的最大位宽localparam GATE_TIME = 16&#x27;d5_000; // 门控时间设置//reg definereg gate ; // 门控信号reg gate_fs ; // 同步到基准时钟的门控信号reg gate_fs_r ; // 用于同步gate信号的寄存器reg gate_fs_d0 ; // 用于采集基准时钟下gate下降沿reg gate_fs_d1 ; // reg gate_fx_d0 ; // 用于采集被测时钟下gate下降沿reg gate_fx_d1 ; // reg [ 63:0] data_fx_t ; // reg [ 15:0] gate_cnt ; // 门控计数reg [MAX-1:0] fs_cnt ; // 门控时间内基准时钟的计数值reg [MAX-1:0] fs_cnt_temp ; // fs_cnt 临时值reg [MAX-1:0] fx_cnt ; // 门控时间内被测时钟的计数值reg [MAX-1:0] fx_cnt_temp ; // fx_cnt 临时值//wire definewire neg_gate_fs; // 基准时钟下门控信号下降沿wire neg_gate_fx; // 被测时钟下门控信号下降沿//边沿检测，捕获信号下降沿assign neg_gate_fs = gate_fs_d1 &amp; (~gate_fs_d0);assign neg_gate_fx = gate_fx_d1 &amp; (~gate_fx_d0);//门控信号计数器，使用被测时钟计数always @(posedge clk_fx or negedge rst_n) begin if(!rst_n) gate_cnt &lt;= 16&#x27;d0; else if(gate_cnt == GATE_TIME + 5&#x27;d20) gate_cnt &lt;= 16&#x27;d0; else gate_cnt &lt;= gate_cnt + 1&#x27;b1;end//门控信号，拉高时间为GATE_TIME个实测时钟周期always @(posedge clk_fx or negedge rst_n) begin if(!rst_n) gate &lt;= 1&#x27;b0; else if(gate_cnt &lt; 4&#x27;d10) gate &lt;= 1&#x27;b0; else if(gate_cnt &lt; GATE_TIME + 4&#x27;d10) gate &lt;= 1&#x27;b1; else if(gate_cnt &lt;= GATE_TIME + 5&#x27;d20) gate &lt;= 1&#x27;b0; else gate &lt;= 1&#x27;b0;end//将门控信号同步到基准时钟下always @(posedge clk_fs or negedge rst_n) begin if(!rst_n) begin gate_fs_r &lt;= 1&#x27;b0; gate_fs &lt;= 1&#x27;b0; end else begin gate_fs_r &lt;= gate; gate_fs &lt;= gate_fs_r; endend//打拍采门控信号的下降沿（被测时钟下）always @(posedge clk_fx or negedge rst_n) begin if(!rst_n) begin gate_fx_d0 &lt;= 1&#x27;b0; gate_fx_d1 &lt;= 1&#x27;b0; end else begin gate_fx_d0 &lt;= gate; gate_fx_d1 &lt;= gate_fx_d0; endend//打拍采门控信号的下降沿（基准时钟下）always @(posedge clk_fs or negedge rst_n) begin if(!rst_n) begin gate_fs_d0 &lt;= 1&#x27;b0; gate_fs_d1 &lt;= 1&#x27;b0; end else begin gate_fs_d0 &lt;= gate_fs; gate_fs_d1 &lt;= gate_fs_d0; endend //门控时间内对被测时钟计数always @(posedge clk_fx or negedge rst_n) begin if(!rst_n) begin fx_cnt_temp &lt;= 32&#x27;d0; fx_cnt &lt;= 32&#x27;d0; end else if(gate) fx_cnt_temp &lt;= fx_cnt_temp + 1&#x27;b1; else if(neg_gate_fx) begin fx_cnt_temp &lt;= 32&#x27;d0; fx_cnt &lt;= fx_cnt_temp; endend //门控时间内对基准时钟计数always @(posedge clk_fs or negedge rst_n) begin if(!rst_n) begin fs_cnt_temp &lt;= 32&#x27;d0; fs_cnt &lt;= 32&#x27;d0; end else if(gate_fs) fs_cnt_temp &lt;= fs_cnt_temp + 1&#x27;b1; else if(neg_gate_fs) begin fs_cnt_temp &lt;= 32&#x27;d0; fs_cnt &lt;= fs_cnt_temp; endend//计算被测信号频率always @(posedge clk_fs or negedge rst_n) begin if(!rst_n) data_fx_t &lt;= 64&#x27;d0; else if(gate_fs == 1&#x27;b0) data_fx_t &lt;= CLK_FS * fx_cnt ;endalways @(posedge clk_fs or negedge rst_n) begin if(!rst_n) data_fx &lt;= 20&#x27;d0; else if(gate_fs == 1&#x27;b0) data_fx &lt;= data_fx_t / fs_cnt ;endendmodule 管脚约束： 1234#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk]set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n]set_property -dict &#123;PACKAGE_PIN K16 IOSTANDARD LVCMOS33&#125; [get_ports clk_fx] 验证 功能仿真TestBench： 12//tb_demo.v 运行结果： 略 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"【未完】XC7A35T Verilog 例程（13）RGB-LCD彩条显示驱动","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-013","date":"2022-10-28T23:35:18.000Z","updated":"2023-04-05T04:15:29.369Z","comments":true,"path":"posts/1384587248.html","link":"","permalink":"https://sirius-blog.github.io/posts/1384587248.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目标器件：LCD显示器（RGB-LCD）。 主要应用参数 1.分辨率 积点成线，线连成面，显示器就是由一个个发光点组成。这里的点作为显示器显示的最小单元共同汇聚成了一块显示屏，1080P的意思，就是一块LCD显示屏上的像素数量是1920*1080个（即2073600个像素点），即一列1080个像素点，一共1920列。 2.像素格式 像素的显示格式，就是通过三原色的光亮控制配比来完成更多色彩的显示，光亮是通过控制字节来完成的，控制字节就是将光亮亮度等比例划分，控制字节越多，光亮等级划分越细，能够产生的颜色配置更细腻。 RGB888指的是红光（R）使用8bit控制、绿光（G）使用8bit控制、蓝光（B）使用8bit控制，共24bit（即3字节），即一个像素点的显示使用3字节来控制； RGB565指的是红光（R）使用5bit控制、绿光（G）使用6bit控制、蓝光（B）使用5bit控制，共16bit（即2字节）。 3.LCD接口 信号线 说明 R[7:0] 红色数据线 G[7:0] 绿色数据线 B[7:0] 蓝色数据线 DE 数据使能端 VSYNC 垂直同步信号线 HSYNC 水平同步信号线 PCLK 像素时钟信号线 4.LCD时间参数 目的 电路 FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 思路 驱动 采用模块化设计： 1 1 1 管脚约束： 1 验证 功能仿真TestBench： 1 运行结果： 略 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（12）接口UART RS232驱动","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-012","date":"2022-10-28T02:20:18.000Z","updated":"2023-04-05T04:15:26.316Z","comments":true,"path":"posts/1836737662.html","link":"","permalink":"https://sirius-blog.github.io/posts/1836737662.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目标器件：CH340 （串口转USB,电平类型转换芯片，TTL电平与USB差分电平的转换） 目标器件：SP3232 （电平类型转换芯片，TTL电平与RS232电平的转换） 目的 主要实现串口通信协议的传输效果。 电路 {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 uart_rxd input U5 串口收 uart_txd output T6 串口发 思路 {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule 管脚约束： 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // 驱动时钟 50MHz ，20ns parameter UART_BPS = 115200; // 波特率 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // 单bit传输耗时 BPS_CNT 个驱动时钟周期 initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule 运行结果： 略 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（11）Xilinx FIFO核应用","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-011","date":"2022-10-28T01:59:18.000Z","updated":"2023-04-05T04:15:22.431Z","comments":true,"path":"posts/1239873178.html","link":"","permalink":"https://sirius-blog.github.io/posts/1239873178.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目的 主要通过FIFO核熟悉FIFO的读写及IP核使用。 电路 略 FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 思路 配置位宽 {width=“400px”} IP配置 {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//demo.vmodule demo( input sys_clk, input sys_rst_n, output wire almost_empty, output wire almost_full, output wire fifo_rd_en, output wire [7:0]fifo_dout, output wire fifo_wr_en, output wire [7:0] fifo_din, output wire fifo_empty, output wire fifo_full, output wire [7 : 0] fifo_rd_data_count, output wire [7 : 0] fifo_wr_data_count);fifo_read inst_fifo_read( . clk (sys_clk), . rst_n (sys_rst_n), . almost_empty (almost_empty), . almost_full (almost_full), . rd_en (fifo_rd_en), . rd_data (fifo_dout));fifo_write inst_fifo_write( . clk (sys_clk), . rst_n (sys_rst_n), . almost_empty (almost_empty), . almost_full (almost_full), . wr_en (fifo_wr_en), . wr_data (fifo_din));fifo_generator_0 your_instance_name ( .wr_clk(sys_clk), // input wire wr_clk .rd_clk(sys_clk), // input wire rd_clk .din(fifo_din), // input wire [7 : 0] din .wr_en(fifo_wr_en), // input wire wr_en .rd_en(fifo_rd_en), // input wire rd_en .dout(fifo_dout), // output wire [7 : 0] dout .full(fifo_full), // output wire full .almost_full(almost_full), // output wire almost_full .empty(fifo_empty), // output wire empty .almost_empty(almost_empty), // output wire almost_empty .rd_data_count(fifo_rd_data_count), // output wire [7 : 0] rd_data_count .wr_data_count(fifo_wr_data_count) // output wire [7 : 0] wr_data_count);endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//fifo_write.vmodule fifo_write( input clk, input rst_n, input almost_empty, input almost_full, output reg wr_en, output reg [7:0] wr_data);reg [1:0] state;reg almost_empty_d0,almost_empty_d1;reg [3:0] delay_cnt;always@(posedge clk or negedge rst_n)begin if(!rst_n) begin almost_empty_d0 &lt;= 1&#x27;b0; almost_empty_d1 &lt;= 1&#x27;b0; end else begin almost_empty_d0 &lt;= almost_empty; almost_empty_d1 &lt;= almost_empty_d0; endendalways@(posedge clk or negedge rst_n)begin if(!rst_n) begin wr_en &lt;= 1&#x27;b0; wr_data &lt;= 8&#x27;d0; state &lt;= 2&#x27;d0; delay_cnt &lt;= 4&#x27;d0; end else begin case(state) 2&#x27;d0 : begin //IDEL if(almost_empty_d1) state &lt;= 2&#x27;d1; else state &lt;= state; end 2&#x27;d1 : begin //DELAY if(delay_cnt==4&#x27;d10) begin delay_cnt &lt;= 4&#x27;d0; state &lt;= 2&#x27;d2; wr_en &lt;= 1&#x27;b1; end else delay_cnt &lt;= delay_cnt+4&#x27;d1; end 2&#x27;d2 : begin //WRITE if(almost_full) begin wr_en &lt;= 1&#x27;b0; wr_data &lt;= 8&#x27;d0; state &lt;= 2&#x27;d0; end else begin wr_en &lt;= 1&#x27;b1; wr_data &lt;= wr_data+1&#x27;b1; end end default:state &lt;= 2&#x27;d0; endcase endendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//fifo_read.vmodule fifo_read( input clk, input rst_n, input almost_empty, input almost_full, output reg rd_en, input [7:0] rd_data);reg [1:0] state;reg almost_full_d0,almost_full_d1;reg [3:0] delay_cnt;always@(posedge clk or negedge rst_n)begin if(!rst_n) begin almost_full_d0 &lt;= 1&#x27;b0; almost_full_d1 &lt;= 1&#x27;b0; end else begin almost_full_d0 &lt;= almost_full; almost_full_d1 &lt;= almost_full_d0; endendalways@(posedge clk or negedge rst_n)begin if(!rst_n) begin rd_en &lt;= 1&#x27;b0; state &lt;= 2&#x27;d0; delay_cnt &lt;= 4&#x27;d0; end else begin case(state) 2&#x27;d0 : begin //IDEL if(almost_full_d1) state &lt;= 2&#x27;d1; else state &lt;= state; end 2&#x27;d1 : begin //DELAY if(delay_cnt==4&#x27;d10) begin delay_cnt &lt;= 4&#x27;d0; state &lt;= 2&#x27;d2; end else delay_cnt &lt;= delay_cnt+4&#x27;d1; end 2&#x27;d2 : begin //READ if(almost_empty) begin rd_en &lt;= 1&#x27;b0; state &lt;= 2&#x27;d0; end else begin rd_en &lt;= 1&#x27;b1; end end default:state &lt;= 2&#x27;d0; endcase endendendmodule 管脚约束： 1234#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #30 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; wire almost_empty;wire almost_full;wire fifo_rd_en;wire [7:0]fifo_dout;wire fifo_wr_en;wire [7:0] fifo_din;wire fifo_empty;wire fifo_full;wire [7 : 0] fifo_rd_data_count;wire [7 : 0] fifo_wr_data_count;demo inst_demo ( .sys_clk(sys_clk), // input wire rd_clk .sys_rst_n(sys_rst_n), // input wire rd_clk .fifo_din(fifo_din), // input wire [7 : 0] din .fifo_wr_en(fifo_wr_en), // input wire wr_en .fifo_rd_en(fifo_rd_en), // input wire rd_en .fifo_dout(fifo_dout), // output wire [7 : 0] dout .fifo_full(fifo_full), // output wire full .almost_full(almost_full), // output wire almost_full .fifo_empty(fifo_empty), // output wire empty .almost_empty(almost_empty), // output wire almost_empty .fifo_rd_data_count(fifo_rd_data_count), // output wire [7 : 0] rd_data_count .fifo_wr_data_count(fifo_wr_data_count) // output wire [7 : 0] wr_data_count);endmodule 运行结果： “启动-复位释放-写状态机IDEL-写状态机DELAY-写状态机WRITE”过程 “写状态机WRITE”阶段的FIFO核的状态变化，可以看到由空到非空状态 din、almost_empty、empty与rd_count、wr_count的关系 “写状态机WRITE”阶段的FIFO核的状态变化，可以看到由非满到满状态 din、almost_full、full与rd_count、wr_count的关系 “写状态机-读状态机”过程的FIFO核的状态变化，可以看到由满到非满状态 din、almost_full、full与rd_count、wr_count的关系 “读状态机READ”阶段的FIFO核的状态变化，可以看到由非空到空状态 din、almost_empty、empty与rd_count、wr_count的关系 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（10）Xilinx RAM核应用","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-010","date":"2022-10-28T01:00:18.000Z","updated":"2023-04-05T04:15:19.200Z","comments":true,"path":"posts/2451945340.html","link":"","permalink":"https://sirius-blog.github.io/posts/2451945340.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目的 主要通过RAM核熟悉RAM的读写及IP核使用。 电路 硬件连接关系： FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 思路 使用IP核构建位宽为8，深度为32的单端口RAM，并进行读写测试。 IP配置 {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718192021222324252627282930313233//demo.vmodule demo( input sys_clk, input sys_rst_n); wire ram_en; wire ram_wea; wire [4:0] ram_addr ; wire [7:0] ram_wr_data ; wire [7:0] ram_rd_data ;ram_rw inst_rw_ram ( .clk(sys_clk), .rst_n(sys_rst_n), .ram_en(ram_en), .ram_wea(ram_wea), .ram_addr(ram_addr), .ram_wr_data(ram_wr_data), .ram_rd_data(ram_rd_data) );blk_mem_gen_0 inst_IP_ram ( .clka(sys_clk), // input wire clka .ena(ram_en), // input wire ena .wea(ram_wea), // input wire [0 : 0] wea .addra(ram_addr), // input wire [4 : 0] addra .dina(ram_wr_data), // input wire [7 : 0] dina .douta(ram_rd_data) // output wire [7 : 0] douta);endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445//ram_rw.vmodule ram_rw( input clk , input rst_n , output ram_en , output ram_wea , output reg [4:0] ram_addr , output reg [7:0] ram_wr_data, input [7:0] ram_rd_data);reg [5:0] rw_cnt ;assign ram_en = rst_n;assign ram_wea = (rw_cnt &lt;= 6&#x27;d31 &amp;&amp; ram_en == 1&#x27;b1) ? 1&#x27;b1 : 1&#x27;b0;always @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) rw_cnt &lt;= 1&#x27;b0; else if(rw_cnt == 6&#x27;d63) rw_cnt &lt;= 1&#x27;b0; else rw_cnt &lt;= rw_cnt + 1&#x27;b1;endalways @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) ram_wr_data &lt;= 1&#x27;b0; else if(rw_cnt &lt;= 6&#x27;d31) ram_wr_data &lt;= ram_wr_data + 1&#x27;b1; else ram_wr_data &lt;= 1&#x27;b0 ;endalways @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) ram_addr &lt;= 1&#x27;b0; else if(ram_addr == 5&#x27;d31) ram_addr &lt;= 1&#x27;b0; else ram_addr &lt;= ram_addr + 1&#x27;b1;endendmodule 管脚约束： 123#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] 验证 功能仿真TestBench： 12345678910111213141516171819202122//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; always #10 sys_clk = ~sys_clk; initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; end demo inst_ram_rw ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk)); endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（9）Xilinx PLL核应用","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-009","date":"2022-10-28T00:47:18.000Z","updated":"2023-04-05T04:15:15.928Z","comments":true,"path":"posts/2382141945.html","link":"","permalink":"https://sirius-blog.github.io/posts/2382141945.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目的 主要通过PLL这一时钟IP核实现对官方IP应用的认知。 电路 硬件连接关系： {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 clk_100M output M16 100MHz时钟 clk_100M_pd output L15 100MHz时钟,反相 clk_50M output M15 50MHz时钟 clk_25M output L14 25MHz时钟 思路 通过参数配置PLL核，实现分频和倍频以及相位偏移。 IP配置 参数：单端输入50MHz,从4输出端口分别输出100MHz倍频钟、反相100MHz、50MHz、25MHz分频。 {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 1234567891011121314151617181920212223242526//demo.vmodule demo( input sys_clk, input sys_rst_n, output clk_100M, output clk_100M_pd, output clk_50M, output clk_25M); wire locked; clk_wiz_0 inst_IP_clock ( // Clock out ports .clk_out1(clk_100M), // output clk_out1 .clk_out2(clk_100M_pd), // output clk_out2 .clk_out3(clk_50M), // output clk_out3 .clk_out4(clk_25M), // output clk_out4 // Status and control signals .reset(!sys_rst_n), // input reset .locked(locked), // output locked // Clock in ports .clk_in1(sys_clk)); // input clk_in1endmodule 管脚约束： 1234567#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN M16 IOSTANDARD LVCMOS33&#125; [get_ports clk_100m] set_property -dict &#123;PACKAGE_PIN L15 IOSTANDARD LVCMOS33&#125; [get_ports clk_100m_pd] set_property -dict &#123;PACKAGE_PIN M15 IOSTANDARD LVCMOS33&#125; [get_ports clk_50m] set_property -dict &#123;PACKAGE_PIN L14 IOSTANDARD LVCMOS33&#125; [get_ports clk_25m] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031//tb_demo.vmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire clk_100M; wire clk_100M_pd; wire clk_50M; wire clk_25M; always #10 sys_clk = ~sys_clk; initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; end demo inst_clock_gen ( // Clock out ports .clk_out1(clk_100M), // output clk_out1 .clk_out2(clk_100M_pd), // output clk_out2 .clk_out3(clk_50M), // output clk_out3 .clk_out4(clk_25M), // output clk_out4 // Status and control signals .reset(!sys_rst_n), // input reset // Clock in ports .clk_in1(sys_clk)); // input clk_in1endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（8）动态数码管","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-008","date":"2022-10-28T00:39:18.000Z","updated":"2023-04-05T04:15:11.091Z","comments":true,"path":"posts/314178488.html","link":"","permalink":"https://sirius-blog.github.io/posts/314178488.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 控制对象：8段数码管。 目的 主要以有限端口实现多组8段数码管显示的效果。","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（7）静态数码管显示","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-007","date":"2022-10-28T00:35:18.000Z","updated":"2023-04-05T04:15:08.000Z","comments":true,"path":"posts/2686831974.html","link":"","permalink":"https://sirius-blog.github.io/posts/2686831974.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 控制对象：8段数码管。 {width=“400px”} 目的 主要实现8段数码管显示的效果。 电路 硬件连接关系： {width=“400px”} {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U2 此处复位低有效 seg_led[0] output H15 数码管段选a seg_led[1] output G16 数码管段选b seg_led[2] output L13 数码管段选c seg_led[3] output G15 数码管段选d seg_led[4] output K13 数码管段选e seg_led[5] output G13 数码管段选f seg_led[6] output H14 数码管段选g seg_led[7] output J14 数码管段选h seg_sel[0] output J15 数码管位选0 seg_sel[1] output H17 数码管位选1 seg_sel[2] output H13 数码管位选2 seg_sel[3] output G17 数码管位选3 seg_sel[4] output H18 数码管位选4 seg_sel[5] output G18 数码管位选5 思路 {width=“400px”} 驱动 采用模块化设计： 1234567891011121314151617181920212223242526272829303132//demo.vmodule demo( input sys_clk, input sys_rst_n, output [5:0] seg_sel, output [7:0] seg_led);parameter TIME_SHOW = 25&#x27;d25000000; //驻留时间wire increase_flag;seg_display_static inst_seg_display_static( .clk (sys_clk), .rstn (sys_rst_n), .seg_sel(seg_sel), .seg_led(seg_led), .increase_flag(increase_flag));time_count #(.MAX_NUM(TIME_SHOW ))inst_time_count( .clk (sys_clk), .rstn (sys_rst_n), .flag(increase_flag));endmodule 数码管静态驱动及显示样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//seg_display_static.vmodule seg_display_static( input clk, input rstn, input increase_flag, output reg [5:0] seg_sel, output reg [7:0] seg_led);reg [3:0] num;//位选驱动，硬件连接中低电平驱动PNP三极管导通always @ (posedge clk or negedge rstn) begin if (!rstn) seg_sel &lt;= 6&#x27;b111111; else seg_sel &lt;= 6&#x27;b000000;endalways @ (posedge clk or negedge rstn) begin if (!rstn) num &lt;= 4&#x27;h0; else if(increase_flag) begin if(num &lt; 4&#x27;hf) num &lt;= num + 1&#x27;b1; else num &lt;= 4&#x27;h0; end else num &lt;= num;endalways @ (posedge clk or negedge rstn) begin if (!rstn) //全点亮 seg_led &lt;= 8&#x27;b0000_0000; else begin case(num) //共阳极型驱动，低电平点亮 4&#x27;h0 : seg_led &lt;= 8&#x27;b1100_0000;//&#x27;hC0 4&#x27;h1 : seg_led &lt;= 8&#x27;b1111_1001;//&#x27;hF9 4&#x27;h2 : seg_led &lt;= 8&#x27;b1010_0100;//&#x27;hA4 4&#x27;h3 : seg_led &lt;= 8&#x27;b1011_0000;//&#x27;hB0 4&#x27;h4 : seg_led &lt;= 8&#x27;b1001_1001;//&#x27;h99 4&#x27;h5 : seg_led &lt;= 8&#x27;b1001_0010;//&#x27;h92 4&#x27;h6 : seg_led &lt;= 8&#x27;b1000_0010;//&#x27;h82 4&#x27;h7 : seg_led &lt;= 8&#x27;b1111_1000;//&#x27;hF8 4&#x27;h8 : seg_led &lt;= 8&#x27;b1000_0000;//&#x27;h80 4&#x27;h9 : seg_led &lt;= 8&#x27;b1001_0000;//&#x27;h90 4&#x27;ha : seg_led &lt;= 8&#x27;b1000_1000;//&#x27;h88 4&#x27;hb : seg_led &lt;= 8&#x27;b1000_0011;//&#x27;h83 4&#x27;hc : seg_led &lt;= 8&#x27;b1100_0110;//&#x27;hC6 4&#x27;hd : seg_led &lt;= 8&#x27;b1010_0001;//&#x27;hA1 4&#x27;he : seg_led &lt;= 8&#x27;b1000_0110;//&#x27;h86 4&#x27;hf : seg_led &lt;= 8&#x27;b1000_1110;//&#x27;h8E default : seg_led &lt;= 8&#x27;b1100_0000;//&#x27;hC0 endcase endendendmodule 单个样式显示驻留时长 123456789101112131415161718192021222324252627282930//time_count.vmodule time_count( input clk, input rstn, output reg flag);parameter MAX_NUM = 25000000;reg [24:0] cnt;always@(posedge clk or negedge rstn)begin if (!rstn) begin flag &lt;= 1&#x27;b0; cnt &lt;= 24&#x27;d0; end else if(cnt &lt; MAX_NUM - 1&#x27;b1) begin flag &lt;= 1&#x27;b0; cnt &lt;= cnt + 1&#x27;b1; end else begin flag &lt;= 1&#x27;b1; cnt &lt;= 24&#x27;d0; endendendmodule 管脚约束： 12345678910111213141516171819#demo.xdcset_property IOSTANDARD LVCMOS33[get_ports sys_clk] set_property IOSTANDARD LVCMOS33 [get_ports sys_rst_n] set_property PACKAGE_PIN U2 [get_ports sys_rst_n] set_property PACKAGE_PIN R4 [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN G18 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[5]&#125;] set_property -dict &#123;PACKAGE_PIN H18 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[4]&#125;] set_property -dict &#123;PACKAGE_PIN G17 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[3]&#125;] set_property -dict &#123;PACKAGE_PIN H13 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[2]&#125;] set_property -dict &#123;PACKAGE_PIN H17 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[1]&#125;] set_property -dict &#123;PACKAGE_PIN J15 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[0]&#125;] set_property -dict &#123;PACKAGE_PIN H15 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[0]&#125;] set_property -dict &#123;PACKAGE_PIN G16 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[1]&#125;] set_property -dict &#123;PACKAGE_PIN L13 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[2]&#125;] set_property -dict &#123;PACKAGE_PIN G15 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[3]&#125;] set_property -dict &#123;PACKAGE_PIN K13 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[4]&#125;] set_property -dict &#123;PACKAGE_PIN G13 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[5]&#125;] set_property -dict &#123;PACKAGE_PIN H14 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[6]&#125;] set_property -dict &#123;PACKAGE_PIN J14 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[7]&#125;] 验证 功能仿真TestBench： 1234567891011121314151617181920212223242526272829303132//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire [7:0] seg_led; wire [5:0] seg_sel;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #20 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo #( .TIME_SHOW (25&#x27;d250) //驻留时间)inst_seg_display_static( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .seg_led (seg_led), .seg_sel(seg_sel));endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（6）呼吸灯","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-006","date":"2022-10-28T00:27:18.000Z","updated":"2023-04-05T04:15:05.114Z","comments":true,"path":"posts/2356580398.html","link":"","permalink":"https://sirius-blog.github.io/posts/2356580398.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目的 主要实现灯光由暗渐亮、由亮渐暗的效果。 电路 硬件连接关系： {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U7 此处复位低有效 led output V9 LED0，高电平点亮 思路 {width=“400px”} 驱动 采用模块化设计： 12345678910111213141516//demo.vmodule demo( input sys_clk, input sys_rst_n, output led);breath_led inst_breath_led( .clk (sys_clk), .rstn (sys_rst_n), .led(led));endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//breath_led.vmodule breath_led( input clk, input rstn, output led);reg [15:0] period_cnt;reg [15:0] duty_cycle;reg inc_dec_flag;//outputassign led = (period_cnt &gt;= duty_cycle) ? 1&#x27;b1 : 1&#x27;b0;always@(posedge clk or negedge rstn)begin if(!rstn) period_cnt &lt;= 16&#x27;d0; else if(period_cnt == 16&#x27;d50000) period_cnt &lt;= 16&#x27;d0; else period_cnt &lt;= period_cnt+1&#x27;b1;end//output valuealways@(posedge clk or negedge rstn)begin if(!rstn) begin duty_cycle &lt;= 16&#x27;d0; inc_dec_flag &lt;= 1&#x27;b0; end else begin if(period_cnt == 16&#x27;d50000) begin if(inc_dec_flag == 1&#x27;b0) begin if(duty_cycle == 16&#x27;d50000) inc_dec_flag &lt;= 1&#x27;b1; else duty_cycle &lt;= duty_cycle + 16&#x27;d25; end else begin if(duty_cycle == 16&#x27;d0) inc_dec_flag &lt;= 1&#x27;b0; else duty_cycle &lt;= duty_cycle - 16&#x27;d25; end end endendendmodule 管脚约束： 1234#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN V9 IOSTANDARD LVCMOS15&#125; [get_ports led] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire led;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #20 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo breath_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led(led));endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（5）触摸键控灯","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-005","date":"2022-10-28T00:20:18.000Z","updated":"2023-06-03T05:59:24.949Z","comments":true,"path":"posts/1138237653.html","link":"","permalink":"https://sirius-blog.github.io/posts/1138237653.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目的 主要实现触摸式电容按键控制灯的开关效果。 电路 硬件连接关系： {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U7 此处复位低有效 led output V9 LED0，高电平点亮 touch_key input V8 触摸键信号 思路 {width=“400px”} 驱动 采用模块化设计： 123456789101112131415161718//demo.vmodule demo( input sys_clk, input sys_rst_n, output led, input touch_key);touch_led inst_touch_led( .clk (sys_clk), .rstn (sys_rst_n), .touch_key (touch_key), .led(led));endmodule 1234567891011121314151617181920212223242526272829303132333435//touch_led.vmodule touch_led( input clk, input rstn, input touch_key, output reg led);reg [1:0] touch_key_r;wire touch_en;//check posedgeassign touch_en = (~touch_key_r[1]) &amp; touch_key_r[0];always@(posedge clk or negedge rstn)begin if(!rstn) touch_key_r &lt;= 2&#x27;d0; else touch_key_r &lt;= &#123;touch_key_r[0],touch_key&#125;;end//output valuealways@(posedge clk or negedge rstn)begin if(!rstn) led &lt;= 1&#x27;b0; else if(touch_en) led &lt;= ~led; else led &lt;= led;endendmodule 管脚约束： 12345#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN V8 IOSTANDARD LVCMOS15&#125; [get_ports touch_key] set_property -dict &#123;PACKAGE_PIN V9 IOSTANDARD LVCMOS15&#125; [get_ports led] 验证 功能仿真TestBench： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire led; reg key;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; key = 1&#x27;b0; #20 sys_rst_n = 1&#x27;b1; #30 //50ms down key = 1&#x27;b1; #200 //250ms up key = 1&#x27;b0; #30 //280ms down key = 1&#x27;b1; #200 //480ms up key = 1&#x27;b0; #30 //510ms down key = 1&#x27;b1; #200 //710ms up key = 1&#x27;b0; #30 //740ms down key = 1&#x27;b1; #200 //940ms up key = 1&#x27;b0;endalways#10 sys_clk = ~sys_clk; demo inst_touch_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .touch_key (key), .led(led));endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（4）按键控蜂鸣器","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-004","date":"2022-10-28T00:15:18.000Z","updated":"2023-06-03T05:59:07.537Z","comments":true,"path":"posts/66328353.html","link":"","permalink":"https://sirius-blog.github.io/posts/66328353.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目的 主要实现点触式按键控制有源蜂鸣器发声效果。 电路 硬件连接关系： {width=“400px”} {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U7 此处复位低有效 beep output V7 BEEP，高电平驱动 key input T4 KEY0，低电平按下 思路 {width=“400px”} {width=“400px”} 驱动 采用模块化设计： 12345678910111213141516171819202122232425262728293031//demo.vmodule demo( input sys_clk, input sys_rst_n, output beep, input key);wire key_value;wire key_flag;key_debounce inst_key_debounce( .clk (sys_clk), .rstn (sys_rst_n), .key (key), .key_flag (key_flag), .key_value (key_value));beep_ctrl inst_beep_ctrl( .clk (sys_clk), .rstn (sys_rst_n), .key_flag (key_flag), .key_value (key_value), .beep (beep));endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//key_debounce.vmodule key_debounce( input clk, input rstn, input key, output reg key_value, output reg key_flag);reg [31:0] delay_cnt;reg key_reg;//delay timealways@(posedge clk or negedge rstn)begin if(!rstn) begin key_reg &lt;= 1&#x27;b1; delay_cnt &lt;= 32&#x27;d0; end else begin key_reg &lt;= key; if(key_reg!=key) //in shaked delay_cnt &lt;= 32&#x27;d1000000; else if(key_reg==key) begin if(delay_cnt &gt; 32&#x27;d0) delay_cnt &lt;= delay_cnt-1&#x27;b1; else delay_cnt &lt;= delay_cnt; end endend//output valuealways@(posedge clk or negedge rstn)begin if(!rstn) begin key_flag &lt;= 1&#x27;b0; key_value &lt;= 1&#x27;b1; end else begin if(delay_cnt == 32&#x27;d1) begin key_flag &lt;= 1&#x27;b1; key_value &lt;= key; end else begin key_flag &lt;= 1&#x27;b0; key_value &lt;= key; end endendendmodule 123456789101112131415161718192021222324//beep_ctrl.vmodule beep_ctrl( input clk, input rstn, output reg beep, input key_value, input key_flag);always@(posedge clk or negedge rstn)begin if(!rstn) beep &lt;= 1&#x27;b1; else begin if(key_flag&amp;&amp;(~key_value)) beep &lt;= ~beep; else beep &lt;= beep; endendendmodule 管脚约束： 12345#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN T4 IOSTANDARD LVCMOS15&#125; [get_ports key] set_property -dict &#123;PACKAGE_PIN V7 IOSTANDARD LVCMOS15&#125; [get_ports beep] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire beep; reg key; parameter T=1000000;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; key = 1&#x27;b1; #20 sys_rst_n = 1&#x27;b1; #(30*T) //30ms down key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(170*T) //240ms up key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(170*T) //450ms down key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(30*T) //520ms up key = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo inst_key_beep( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .beep (beep), .key (key));endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/categories/FPGA/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（3）按键控灯","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-003","date":"2022-10-27T23:55:18.000Z","updated":"2023-06-03T05:58:49.938Z","comments":true,"path":"posts/3244215014.html","link":"","permalink":"https://sirius-blog.github.io/posts/3244215014.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目的 主要实现点触式按键控制LED灯点亮的效果。 电路 硬件连接关系： {width=“400px”} {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U7 此处复位低有效 led[0] output V9 LED0，高电平点亮 led[1] output Y8 LED1，高电平点亮 led[2] output Y7 LED2，高电平点亮 led[3] output W7 LED3，高电平点亮 key[0] input T4 KEY0，低电平按下 key[1] input T3 KEY1，低电平按下 key[2] input R6 KEY2，低电平按下 key[3] input T6 KEY3，低电平按下 思路 {width=“400px”} 驱动 采用模块化设计： 12345678910111213141516171819//demo.vmodule demo( input sys_clk, input sys_rst_n, output [3:0] led, input [3:0] key);key_led inst_key_led( .clk (sys_clk), .rstn (sys_rst_n), .led (led), .key (key));endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//key_led.vmodule key_led( input clk, input rstn, output reg [3:0] led, input [3:0] key);reg [23:0] cnt;reg [1:0] led_ctrl;//delayalways@(posedge clk or negedge rstn)begin if(!rstn) cnt &lt;= 24&#x27;d0; else if(cnt&lt;24&#x27;d10000000) cnt &lt;= cnt+1&#x27;b1; else cnt&lt;=24&#x27;d0;end//controlalways@(posedge clk or negedge rstn)begin if(!rstn) led_ctrl &lt;= 2&#x27;d0; else if(cnt==(24&#x27;d10000000-1&#x27;b1)) led_ctrl &lt;= led_ctrl+1&#x27;b1; else led_ctrl&lt;= led_ctrl;end//keyalways@(posedge clk or negedge rstn)begin if(!rstn) led &lt;= 4&#x27;b0000; else if(key[0]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b1000; 2&#x27;d1 : led &lt;= 4&#x27;b0100; 2&#x27;d2 : led &lt;= 4&#x27;b0010; 2&#x27;d3 : led &lt;= 4&#x27;b0001; default : led &lt;= 4&#x27;b0000; endcase else if(key[1]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b0001; 2&#x27;d1 : led &lt;= 4&#x27;b0010; 2&#x27;d2 : led &lt;= 4&#x27;b0100; 2&#x27;d3 : led &lt;= 4&#x27;b1000; default : led &lt;= 4&#x27;b0000; endcase else if(key[2]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b1111; 2&#x27;d1 : led &lt;= 4&#x27;b0000; 2&#x27;d2 : led &lt;= 4&#x27;b1111; 2&#x27;d3 : led &lt;= 4&#x27;b0000; default : led &lt;= 4&#x27;b0000; endcase else if(key[3]==1&#x27;b0) led &lt;= 4&#x27;b1111; else led &lt;= 4&#x27;b0000;endendmodule 管脚约束： 1234567891011#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk]set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n]set_property -dict &#123;PACKAGE_PIN V9 IOSTANDARD LVCMOS15&#125; [get_ports led[0]]set_property -dict &#123;PACKAGE_PIN Y8 IOSTANDARD LVCMOS15&#125; [get_ports led[1]]set_property -dict &#123;PACKAGE_PIN Y7 IOSTANDARD LVCMOS15&#125; [get_ports led[2]] set_property -dict &#123;PACKAGE_PIN W7 IOSTANDARD LVCMOS15&#125; [get_ports led[3]]set_property -dict &#123;PACKAGE_PIN T4 IOSTANDARD LVCMOS15&#125; [get_ports key[0]] set_property -dict &#123;PACKAGE_PIN T3 IOSTANDARD LVCMOS15&#125; [get_ports key[1]] set_property -dict &#123;PACKAGE_PIN R6 IOSTANDARD LVCMOS15&#125; [get_ports key[2]] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS15&#125; [get_ports key[3]] 验证 功能仿真TestBench： 1234567891011121314151617181920212223242526272829303132333435363738394041//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); parameter T=20; reg sys_clk; reg sys_rst_n; wire [3:0] led; reg [3:0] key;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; key = 4&#x27;b1111; #T sys_rst_n = 1&#x27;b1; key[0] = 1&#x27;b0; //down #(40000000*T) //800 key[0] = 1&#x27;b1; //up key[1] = 1&#x27;b0; #(40000000*T) key[1] = 1&#x27;b1; key[2] = 1&#x27;b0; #(40000000*T) key[2] = 1&#x27;b1; key[3] = 1&#x27;b0; #(40000000*T) key[3] = 1&#x27;b1;endalways#(T/2) sys_clk = ~sys_clk; demo inst_key_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led (led), .key (key));endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/categories/Xilinx/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（2）流水灯","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-002","date":"2022-10-27T23:29:18.000Z","updated":"2023-06-03T05:58:36.726Z","comments":true,"path":"posts/3427372113.html","link":"","permalink":"https://sirius-blog.github.io/posts/3427372113.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目的 主要实现LED灯按顺序以一定时间间隔逐个点亮及熄灭的效果。 电路 硬件连接关系： {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U7 此处复位低有效 led[0] output V9 LED0，高电平点亮 led[1] output Y8 LED1，高电平点亮 led[2] output Y7 LED2，高电平点亮 led[3] output W7 LED3，高电平点亮 思路 {width=“400px”} 驱动 采用模块化设计： 1234567891011121314151617//demo.vmodule demo( input sys_clk, input sys_rst_n, output [3:0] led);flow_led inst_flow_led( .clk (sys_clk), .rstn (sys_rst_n), .led (led));endmodule 12345678910111213141516171819202122232425262728293031//flow_led.vmodule flow_led( input clk, input rstn, output reg [3:0] led);reg [25:0] cnt;always@(posedge clk or negedge rstn)//50MHz clkbegin if(!rstn) cnt &lt;= 26&#x27;d0; else if(cnt&lt;26&#x27;d10000000)//200ms cnt &lt;= cnt+1&#x27;b1; else cnt = 26&#x27;d0;endalways@(posedge clk or negedge rstn)//50MHz clkbegin if(!rstn) led &lt;= 4&#x27;b0001; else if(cnt==(26&#x27;d10000000-1&#x27;b1))//200ms led &lt;= &#123;led[2:0],led[3]&#125;; else led &lt;= led;endendmodule 管脚约束： 1234567#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n]set_property -dict &#123;PACKAGE_PIN V9 IOSTANDARD LVCMOS15&#125; [get_ports led[0]] set_property -dict &#123;PACKAGE_PIN Y8 IOSTANDARD LVCMOS15&#125; [get_ports led[1]] set_property -dict &#123;PACKAGE_PIN Y7 IOSTANDARD LVCMOS15&#125; [get_ports led[2]] set_property -dict &#123;PACKAGE_PIN W7 IOSTANDARD LVCMOS15&#125; [get_ports led[3]] 验证 功能仿真TestBench： 12345678910111213141516171819202122232425//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire [3:0] led;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo inst_flow_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led (led));endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"XC7A35T 型","slug":"XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog 例程（1）闪灯","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-001","date":"2022-10-27T18:29:18.000Z","updated":"2023-06-03T05:58:29.099Z","comments":true,"path":"posts/3954518670.html","link":"","permalink":"https://sirius-blog.github.io/posts/3954518670.html","excerpt":"","text":"说明：硬件环境及例程参考“正点原子达芬奇开发板”，部分内容会有改动。 器件 主芯片：Xilinx XC7A35TFGG484 。 目的 主要实现LED灯点亮并交替闪烁的效果。 电路 硬件连接关系： {width=“400px”} FPGA管脚分配： 信号 方向 管脚 说明 sys_clk input R4 此处时钟50MHz sys_rst_n input U7 此处复位低有效 led[0] output V9 LED0，高电平点亮 led[1] output Y8 LED1，高电平点亮 思路 {width=“400px”} 驱动 采用模块化设计： 1234567891011121314151617//demo.vmodule demo( input sys_clk, input sys_rst_n, output [1:0] led);led_twinkle inst_led_twinkle( .clk (sys_clk), .rstn (sys_rst_n), .led (led));endmodule 1234567891011121314151617181920212223//led_twinkle.vmodule led_twinkle( input clk, input rstn, output [1:0] led);reg [25:0] cnt;always@(posedge clk or negedge rstn)//50MHz clkbegin if(!rstn) cnt &lt;= 26&#x27;d0; else if(cnt&lt;26&#x27;d50000000)//1s cnt &lt;= cnt+1&#x27;b1; else cnt = 26&#x27;d0;endassign led = (cnt&lt;26&#x27;d25000000)?2&#x27;b01:2&#x27;b10;endmodule 管脚约束： 12345#demo.xdcset_property -dict &#123;PACKAGE_PIN Y8 IOSTANDARD LVCMOS15&#125; [get_ports &#123;led[1]&#125;] set_property -dict &#123;PACKAGE_PIN V9 IOSTANDARD LVCMOS15&#125; [get_ports &#123;led[0]&#125;] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n] 验证 功能仿真TestBench： 1234567891011121314151617181920212223//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire [1:0] led;initial beginsys_clk = 1&#x27;b0;sys_rst_n = 1&#x27;b0;#200sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo inst_led_twinkle( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led (led));endmodule 运行结果： 上板 运行结果： 略","categories":[{"name":"XC7A35T 型","slug":"XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]}],"categories":[{"name":"MCU 例程","slug":"MCU-例程","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 库函数版","slug":"MCU-例程/STM32F1-库函数版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"},{"name":"Altera-FPGA 例程","slug":"Altera-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 型","slug":"Altera-FPGA-例程/EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"},{"name":"EP4CE10 型","slug":"EP4CE10-型","permalink":"https://sirius-blog.github.io/categories/EP4CE10-%E5%9E%8B/"},{"name":"STM32F1 寄存器版","slug":"MCU-例程/STM32F1-寄存器版","permalink":"https://sirius-blog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%AF%84%E5%AD%98%E5%99%A8%E7%89%88/"},{"name":"Xilinx-FPGA 例程","slug":"Xilinx-FPGA-例程","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T 型","slug":"Xilinx-FPGA-例程/XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"},{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/categories/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/categories/FPGA/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/categories/Xilinx/"},{"name":"XC7A35T 型","slug":"XC7A35T-型","permalink":"https://sirius-blog.github.io/categories/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"硬件电路","slug":"硬件电路","permalink":"https://sirius-blog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"例程","slug":"例程","permalink":"https://sirius-blog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-blog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-blog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-blog.github.io/tags/STM32F1/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-blog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-blog.github.io/tags/FPGA/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-blog.github.io/tags/EP4CE10/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-blog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-blog.github.io/tags/XC7A35T/"}]}